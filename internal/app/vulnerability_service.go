package app

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/openctemio/api/pkg/domain/shared"
	"github.com/openctemio/api/pkg/domain/user"
	"github.com/openctemio/api/pkg/domain/vulnerability"
	"github.com/openctemio/api/pkg/logger"
	"github.com/openctemio/api/pkg/pagination"
	"github.com/google/uuid"
)

// FindingNotifier is an interface for sending finding notifications asynchronously.
// Deprecated: Use NotificationService with transactional outbox pattern instead.
type FindingNotifier interface {
	// NotifyNewFinding sends a notification for a new finding.
	// This should be called asynchronously to not block finding creation.
	NotifyNewFinding(tenantID, title, body, severity, url string)
}

// VulnerabilityService handles vulnerability-related business operations.
type VulnerabilityService struct {
	vulnRepo            vulnerability.VulnerabilityRepository
	findingRepo         vulnerability.FindingRepository
	commentRepo         vulnerability.FindingCommentRepository
	dataFlowRepo        vulnerability.DataFlowRepository // For loading data flows
	userRepo            user.Repository                  // For user lookup (activity recording)
	activityService     *FindingActivityService          // Activity tracking for audit trail
	findingNotifier     FindingNotifier                  // Deprecated: use notificationService
	notificationService *NotificationService             // Transactional outbox pattern
	aiTriageService     *AITriageService                 // AI-powered vulnerability triage
	db                  *sql.DB                          // For transaction support
	logger              *logger.Logger
}

// NewVulnerabilityService creates a new VulnerabilityService.
func NewVulnerabilityService(
	vulnRepo vulnerability.VulnerabilityRepository,
	findingRepo vulnerability.FindingRepository,
	log *logger.Logger,
) *VulnerabilityService {
	return &VulnerabilityService{
		vulnRepo:    vulnRepo,
		findingRepo: findingRepo,
		logger:      log.With("service", "vulnerability"),
	}
}

// SetFindingNotifier sets the notifier for new findings.
// Deprecated: Use SetNotificationService for reliable transactional notifications.
func (s *VulnerabilityService) SetFindingNotifier(notifier FindingNotifier) {
	s.findingNotifier = notifier
}

// SetNotificationService sets the notification service for transactional outbox pattern.
// When set, notifications are enqueued in the same transaction as finding creation,
// ensuring reliable delivery even if the server crashes.
func (s *VulnerabilityService) SetNotificationService(db *sql.DB, svc *NotificationService) {
	s.db = db
	s.notificationService = svc
}

// SetUserRepository sets the user repository for user lookup (e.g., for activity recording).
func (s *VulnerabilityService) SetUserRepository(repo user.Repository) {
	s.userRepo = repo
}

// SetDataFlowRepository sets the data flow repository for loading data flow traces.
func (s *VulnerabilityService) SetDataFlowRepository(repo vulnerability.DataFlowRepository) {
	s.dataFlowRepo = repo
}

// SetAITriageService sets the AI triage service for auto-triage on finding creation.
func (s *VulnerabilityService) SetAITriageService(svc *AITriageService) {
	s.aiTriageService = svc
}

// ============================================
// VULNERABILITY OPERATIONS
// ============================================

// CreateVulnerabilityInput represents the input for creating a vulnerability.
type CreateVulnerabilityInput struct {
	CVEID            string   `validate:"required,cve_id"`
	Title            string   `validate:"required,min=1,max=500"`
	Description      string   `validate:"max=10000"`
	Severity         string   `validate:"required,severity"`
	CVSSScore        *float64 `validate:"omitempty,min=0,max=10"`
	CVSSVector       string   `validate:"max=100"`
	EPSSScore        *float64 `validate:"omitempty,min=0,max=1"`
	EPSSPercentile   *float64 `validate:"omitempty,min=0,max=1"`
	ExploitAvailable bool
	ExploitMaturity  string   `validate:"omitempty,exploit_maturity"`
	FixedVersions    []string `validate:"max=50,dive,max=100"`
	Remediation      string   `validate:"max=5000"`
}

// CreateVulnerability creates a new vulnerability.
func (s *VulnerabilityService) CreateVulnerability(ctx context.Context, input CreateVulnerabilityInput) (*vulnerability.Vulnerability, error) {
	s.logger.Info("creating vulnerability", "cve_id", input.CVEID)

	severity, err := vulnerability.ParseSeverity(input.Severity)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	v, err := vulnerability.NewVulnerability(input.CVEID, input.Title, severity)
	if err != nil {
		return nil, err
	}

	if input.Description != "" {
		v.UpdateDescription(input.Description)
	}

	if input.CVSSScore != nil {
		v.UpdateCVSS(*input.CVSSScore, input.CVSSVector)
	}

	if input.EPSSScore != nil && input.EPSSPercentile != nil {
		v.UpdateEPSS(*input.EPSSScore, *input.EPSSPercentile)
	}

	v.SetExploitAvailable(input.ExploitAvailable)

	if input.ExploitMaturity != "" {
		v.SetExploitMaturity(vulnerability.ExploitMaturity(input.ExploitMaturity))
	}

	if len(input.FixedVersions) > 0 {
		v.SetFixedVersions(input.FixedVersions)
	}

	if input.Remediation != "" {
		v.UpdateRemediation(input.Remediation)
	}

	if err := s.vulnRepo.Create(ctx, v); err != nil {
		return nil, fmt.Errorf("failed to create vulnerability: %w", err)
	}

	s.logger.Info("vulnerability created", "id", v.ID().String(), "cve_id", v.CVEID())
	return v, nil
}

// GetVulnerability retrieves a vulnerability by ID.
func (s *VulnerabilityService) GetVulnerability(ctx context.Context, vulnID string) (*vulnerability.Vulnerability, error) {
	parsedID, err := shared.IDFromString(vulnID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	return s.vulnRepo.GetByID(ctx, parsedID)
}

// GetVulnerabilityByCVE retrieves a vulnerability by CVE ID.
func (s *VulnerabilityService) GetVulnerabilityByCVE(ctx context.Context, cveID string) (*vulnerability.Vulnerability, error) {
	return s.vulnRepo.GetByCVE(ctx, cveID)
}

// UpdateVulnerabilityInput represents the input for updating a vulnerability.
type UpdateVulnerabilityInput struct {
	Title            *string  `validate:"omitempty,min=1,max=500"`
	Description      *string  `validate:"omitempty,max=10000"`
	Severity         *string  `validate:"omitempty,severity"`
	CVSSScore        *float64 `validate:"omitempty,min=0,max=10"`
	CVSSVector       *string  `validate:"omitempty,max=100"`
	EPSSScore        *float64 `validate:"omitempty,min=0,max=1"`
	EPSSPercentile   *float64 `validate:"omitempty,min=0,max=1"`
	ExploitAvailable *bool
	ExploitMaturity  *string  `validate:"omitempty,exploit_maturity"`
	FixedVersions    []string `validate:"omitempty,max=50,dive,max=100"`
	Remediation      *string  `validate:"omitempty,max=5000"`
	Status           *string  `validate:"omitempty,vulnerability_status"`
}

// UpdateVulnerability updates an existing vulnerability.
func (s *VulnerabilityService) UpdateVulnerability(ctx context.Context, vulnID string, input UpdateVulnerabilityInput) (*vulnerability.Vulnerability, error) {
	parsedID, err := shared.IDFromString(vulnID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	v, err := s.vulnRepo.GetByID(ctx, parsedID)
	if err != nil {
		return nil, err
	}

	if input.Title != nil {
		if err := v.UpdateTitle(*input.Title); err != nil {
			return nil, err
		}
	}

	if input.Description != nil {
		v.UpdateDescription(*input.Description)
	}

	if input.Severity != nil {
		severity, err := vulnerability.ParseSeverity(*input.Severity)
		if err != nil {
			return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
		}
		if err := v.UpdateSeverity(severity); err != nil {
			return nil, err
		}
	}

	if input.CVSSScore != nil {
		vector := ""
		if input.CVSSVector != nil {
			vector = *input.CVSSVector
		}
		v.UpdateCVSS(*input.CVSSScore, vector)
	}

	if input.EPSSScore != nil && input.EPSSPercentile != nil {
		v.UpdateEPSS(*input.EPSSScore, *input.EPSSPercentile)
	}

	if input.ExploitAvailable != nil {
		v.SetExploitAvailable(*input.ExploitAvailable)
	}

	if input.ExploitMaturity != nil {
		v.SetExploitMaturity(vulnerability.ExploitMaturity(*input.ExploitMaturity))
	}

	if input.FixedVersions != nil {
		v.SetFixedVersions(input.FixedVersions)
	}

	if input.Remediation != nil {
		v.UpdateRemediation(*input.Remediation)
	}

	if input.Status != nil {
		status := vulnerability.VulnerabilityStatus(*input.Status)
		if err := v.UpdateStatus(status); err != nil {
			return nil, err
		}
	}

	if err := s.vulnRepo.Update(ctx, v); err != nil {
		return nil, fmt.Errorf("failed to update vulnerability: %w", err)
	}

	s.logger.Info("vulnerability updated", "id", v.ID().String())
	return v, nil
}

// DeleteVulnerability deletes a vulnerability by ID.
func (s *VulnerabilityService) DeleteVulnerability(ctx context.Context, vulnID string) error {
	parsedID, err := shared.IDFromString(vulnID)
	if err != nil {
		return fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	if err := s.vulnRepo.Delete(ctx, parsedID); err != nil {
		return err
	}

	s.logger.Info("vulnerability deleted", "id", vulnID)
	return nil
}

// ListVulnerabilitiesInput represents the input for listing vulnerabilities.
type ListVulnerabilitiesInput struct {
	CVEIDs           []string `validate:"max=50,dive,max=20"`
	Severities       []string `validate:"max=5,dive,severity"`
	MinCVSS          *float64 `validate:"omitempty,min=0,max=10"`
	MaxCVSS          *float64 `validate:"omitempty,min=0,max=10"`
	MinEPSS          *float64 `validate:"omitempty,min=0,max=1"`
	ExploitAvailable *bool
	CISAKEVOnly      *bool
	Statuses         []string `validate:"max=5,dive,vulnerability_status"`
	Search           string   `validate:"max=255"` // Full-text search across CVE ID and description
	Sort             string   `validate:"max=100"` // Sort field (e.g., "-cvss_score", "cve_id")
	Page             int      `validate:"min=0"`
	PerPage          int      `validate:"min=0,max=100"`
}

// ListVulnerabilities retrieves vulnerabilities with filtering and pagination.
func (s *VulnerabilityService) ListVulnerabilities(ctx context.Context, input ListVulnerabilitiesInput) (pagination.Result[*vulnerability.Vulnerability], error) {
	filter := vulnerability.NewVulnerabilityFilter()

	if len(input.CVEIDs) > 0 {
		filter = filter.WithCVEIDs(input.CVEIDs...)
	}

	if len(input.Severities) > 0 {
		severities := make([]vulnerability.Severity, 0, len(input.Severities))
		for _, sev := range input.Severities {
			if parsed, err := vulnerability.ParseSeverity(sev); err == nil {
				severities = append(severities, parsed)
			}
		}
		filter = filter.WithSeverities(severities...)
	}

	if input.MinCVSS != nil {
		filter = filter.WithMinCVSS(*input.MinCVSS)
	}

	if input.MaxCVSS != nil {
		filter = filter.WithMaxCVSS(*input.MaxCVSS)
	}

	if input.MinEPSS != nil {
		filter = filter.WithMinEPSS(*input.MinEPSS)
	}

	if input.ExploitAvailable != nil {
		filter = filter.WithExploitAvailable(*input.ExploitAvailable)
	}

	if input.CISAKEVOnly != nil {
		filter = filter.WithCISAKEVOnly(*input.CISAKEVOnly)
	}

	if len(input.Statuses) > 0 {
		statuses := make([]vulnerability.VulnerabilityStatus, 0, len(input.Statuses))
		for _, st := range input.Statuses {
			statuses = append(statuses, vulnerability.VulnerabilityStatus(st))
		}
		filter = filter.WithStatuses(statuses...)
	}

	if input.Search != "" {
		filter = filter.WithSearch(input.Search)
	}

	// Build list options with sorting
	opts := vulnerability.NewVulnerabilityListOptions()
	if input.Sort != "" {
		sortOpt := pagination.NewSortOption(vulnerability.VulnerabilityAllowedSortFields()).Parse(input.Sort)
		opts = opts.WithSort(sortOpt)
	}

	page := pagination.New(input.Page, input.PerPage)
	return s.vulnRepo.List(ctx, filter, opts, page)
}

// ============================================
// FINDING OPERATIONS
// ============================================

// CreateFindingInput represents the input for creating a finding.
type CreateFindingInput struct {
	TenantID        string `validate:"required,uuid"`
	AssetID         string `validate:"required,uuid"`
	BranchID        string `validate:"omitempty,uuid"`
	VulnerabilityID string `validate:"omitempty,uuid"`
	ComponentID     string `validate:"omitempty,uuid"`
	Source          string `validate:"required,finding_source"`
	ToolName        string `validate:"required,max=100"`
	ToolVersion     string `validate:"max=50"`
	RuleID          string `validate:"max=255"`
	FilePath        string `validate:"max=500"`
	StartLine       int    `validate:"min=0"`
	EndLine         int    `validate:"min=0"`
	StartColumn     int    `validate:"min=0"`
	EndColumn       int    `validate:"min=0"`
	Snippet         string `validate:"max=5000"`
	Message         string `validate:"required,max=2000"`
	Severity        string `validate:"required,severity"`
	ScanID          string `validate:"max=100"`
}

// CreateFinding creates a new finding.
func (s *VulnerabilityService) CreateFinding(ctx context.Context, input CreateFindingInput) (*vulnerability.Finding, error) {
	s.logger.Info("creating finding", "tool", input.ToolName, "asset_id", input.AssetID)

	tenantID, err := shared.IDFromString(input.TenantID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	assetID, err := shared.IDFromString(input.AssetID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
	}

	source, err := vulnerability.ParseFindingSource(input.Source)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	severity, err := vulnerability.ParseSeverity(input.Severity)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	f, err := vulnerability.NewFinding(tenantID, assetID, source, input.ToolName, severity, input.Message)
	if err != nil {
		return nil, err
	}

	if input.BranchID != "" {
		branchID, err := shared.IDFromString(input.BranchID)
		if err != nil {
			return nil, fmt.Errorf("%w: invalid branch id format", shared.ErrValidation)
		}
		f.SetBranchID(branchID)
	}

	if input.VulnerabilityID != "" {
		vulnID, err := shared.IDFromString(input.VulnerabilityID)
		if err != nil {
			return nil, fmt.Errorf("%w: invalid vulnerability id format", shared.ErrValidation)
		}
		f.SetVulnerabilityID(vulnID)
	}

	if input.ComponentID != "" {
		compID, err := shared.IDFromString(input.ComponentID)
		if err != nil {
			return nil, fmt.Errorf("%w: invalid component id format", shared.ErrValidation)
		}
		f.SetComponentID(compID)
	}

	if input.ToolVersion != "" {
		f.SetToolVersion(input.ToolVersion)
	}

	if input.RuleID != "" {
		f.SetRuleID(input.RuleID)
	}

	if input.FilePath != "" {
		f.SetLocation(input.FilePath, input.StartLine, input.EndLine, input.StartColumn, input.EndColumn)
	}

	if input.Snippet != "" {
		f.SetSnippet(input.Snippet)
	}

	if input.ScanID != "" {
		f.SetScanID(input.ScanID)
	}

	// Generate fingerprint
	f.GenerateFingerprint()

	// Use transactional outbox pattern if NotificationService is configured
	if s.notificationService != nil && s.db != nil {
		if err := s.createFindingWithNotification(ctx, f, input); err != nil {
			return nil, err
		}
	} else {
		// Fallback to non-transactional create
		if err := s.findingRepo.Create(ctx, f); err != nil {
			return nil, fmt.Errorf("failed to create finding: %w", err)
		}

		// Send notification asynchronously (fire-and-forget) - deprecated
		if s.findingNotifier != nil {
			go s.findingNotifier.NotifyNewFinding(
				input.TenantID,
				fmt.Sprintf("New %s Finding: %s", f.Severity().String(), input.ToolName),
				f.Message(),
				f.Severity().String(),
				fmt.Sprintf("/findings/%s", f.ID().String()),
			)
		}
	}

	s.logger.Info("finding created", "id", f.ID().String(), "severity", f.Severity().String())

	// Trigger auto-triage if enabled
	s.triggerAutoTriageIfEnabled(ctx, f)

	return f, nil
}

// createFindingWithNotification creates a finding and enqueues notification in the same transaction.
func (s *VulnerabilityService) createFindingWithNotification(ctx context.Context, f *vulnerability.Finding, input CreateFindingInput) error {
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}
	defer func() { _ = tx.Rollback() }()

	// Create finding in transaction
	if err := s.findingRepo.CreateInTx(ctx, tx, f); err != nil {
		return fmt.Errorf("failed to create finding: %w", err)
	}

	// Enqueue notification in the same transaction
	findingUUID, _ := uuid.Parse(f.ID().String())
	err = s.notificationService.EnqueueNotificationInTx(ctx, tx, EnqueueNotificationParams{
		TenantID:      f.TenantID(),
		EventType:     "new_finding",
		AggregateType: "finding",
		AggregateID:   &findingUUID,
		Title:         fmt.Sprintf("New %s Finding: %s", f.Severity().String(), input.ToolName),
		Body:          f.Message(),
		Severity:      f.Severity().String(),
		URL:           fmt.Sprintf("/findings/%s", f.ID().String()),
	})
	if err != nil {
		return fmt.Errorf("enqueue notification: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("commit transaction: %w", err)
	}

	return nil
}

// triggerAutoTriageIfEnabled checks if auto-triage is enabled for this finding's
// tenant and severity, and if so, enqueues an AI triage job.
func (s *VulnerabilityService) triggerAutoTriageIfEnabled(ctx context.Context, f *vulnerability.Finding) {
	if s.aiTriageService == nil {
		return
	}

	// Check if auto-triage should be triggered
	shouldTriage, err := s.aiTriageService.ShouldAutoTriage(ctx, f.TenantID(), f.Severity().String())
	if err != nil {
		s.logger.Warn("failed to check auto-triage eligibility",
			"finding_id", f.ID().String(),
			"error", err,
		)
		return
	}

	if !shouldTriage {
		return
	}

	// Enqueue auto-triage job
	if err := s.aiTriageService.EnqueueAutoTriage(ctx, f.TenantID(), f.ID()); err != nil {
		s.logger.Warn("failed to enqueue auto-triage",
			"finding_id", f.ID().String(),
			"error", err,
		)
		return
	}

	s.logger.Info("auto-triage enqueued",
		"finding_id", f.ID().String(),
		"severity", f.Severity().String(),
	)
}

// GetFinding retrieves a finding by ID.
// tenantID is used for IDOR prevention - ensures the finding belongs to the caller's tenant.
func (s *VulnerabilityService) GetFinding(ctx context.Context, tenantID, findingID string) (*vulnerability.Finding, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(findingID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	f, err := s.findingRepo.GetByID(ctx, parsedTenantID, parsedID)
	if err != nil {
		return nil, err
	}

	// Load data flows if repository is available
	if s.dataFlowRepo != nil {
		dataFlows, err := s.loadDataFlowsForFinding(ctx, parsedID)
		if err != nil {
			// Log but don't fail - data flows are optional enrichment
			s.logger.Warn("failed to load data flows for finding",
				"finding_id", findingID,
				"error", err,
			)
		} else if len(dataFlows) > 0 {
			f.SetDataFlows(dataFlows)
		}
	}

	return f, nil
}

// loadDataFlowsForFinding loads data flows from the database and converts them to value objects.
// The database stores data flows in normalized tables (finding_data_flows + finding_flow_locations),
// but the Finding entity uses the DataFlow value object format.
//
// OPTIMIZATION: Uses GetDataFlowsWithLocations to load all data in 2 queries instead of N+1.
// Previous approach: 1 query for flows + N queries for locations = 1 + N queries
// New approach: 1 query for flows + 1 query for all locations = 2 queries
func (s *VulnerabilityService) loadDataFlowsForFinding(ctx context.Context, findingID shared.ID) ([]vulnerability.DataFlow, error) {
	// Load all data flow entities and their locations in optimized queries (2 queries total)
	flowEntities, locationsMap, err := s.dataFlowRepo.GetDataFlowsWithLocations(ctx, findingID)
	if err != nil {
		return nil, fmt.Errorf("failed to get data flows with locations: %w", err)
	}

	if len(flowEntities) == 0 {
		return nil, nil
	}

	// Convert each entity to a value object with its locations
	dataFlows := make([]vulnerability.DataFlow, 0, len(flowEntities))
	for _, flowEntity := range flowEntities {
		// Get locations from pre-loaded map (no additional query!)
		flowID := flowEntity.ID().String()
		locations := locationsMap[flowID]

		// Convert to value object format
		dataFlow := vulnerability.DataFlow{
			Index:      flowEntity.FlowIndex(),
			Message:    flowEntity.Message(),
			Importance: flowEntity.Importance(),
			Steps:      make([]vulnerability.DataFlowStep, 0, len(locations)),
		}

		for _, loc := range locations {
			step := vulnerability.DataFlowStep{
				Index:        loc.StepIndex(),
				LocationType: loc.LocationType(),
				Location: &vulnerability.FindingLocation{
					Path:        loc.FilePath(),
					StartLine:   loc.StartLine(),
					EndLine:     loc.EndLine(),
					StartColumn: loc.StartColumn(),
					EndColumn:   loc.EndColumn(),
					Snippet:     loc.Snippet(),
					Message:     loc.Message(),
				},
				Label:              loc.Label(),
				Message:            loc.Message(),
				NestingLevel:       loc.NestingLevel(),
				Importance:         loc.Importance(),
				FunctionName:       loc.FunctionName(),
				ClassName:          loc.ClassName(),
				ModuleName:         loc.ModuleName(),
				FullyQualifiedName: loc.FullyQualifiedName(),
			}
			dataFlow.Steps = append(dataFlow.Steps, step)
		}

		dataFlows = append(dataFlows, dataFlow)
	}

	return dataFlows, nil
}

// UpdateFindingStatusInput represents the input for updating a finding's status.
type UpdateFindingStatusInput struct {
	Status     string `validate:"required,finding_status"`
	Resolution string `validate:"max=1000"`
	ActorID    string // Authenticated user ID from middleware (required for audit trail and resolved_by)
}

// UpdateFindingStatus updates a finding's status.
// tenantID is used for IDOR prevention - ensures the finding belongs to the caller's tenant.
func (s *VulnerabilityService) UpdateFindingStatus(ctx context.Context, findingID string, tenantID string, input UpdateFindingStatusInput) (*vulnerability.Finding, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(findingID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	f, err := s.findingRepo.GetByID(ctx, parsedTenantID, parsedID)
	if err != nil {
		return nil, err
	}

	// Capture old status for activity recording
	oldStatus := f.Status().String()

	status, err := vulnerability.ParseFindingStatus(input.Status)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	// Parse actor ID for resolved_by (uses the authenticated user)
	var resolvedBy *shared.ID
	if input.ActorID != "" {
		actorID, err := shared.IDFromString(input.ActorID)
		if err == nil {
			resolvedBy = &actorID
		}
	}

	if err := f.UpdateStatus(status, input.Resolution, resolvedBy); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to update finding status: %w", err)
	}

	s.logger.Info("finding status updated", "id", f.ID().String(), "status", status.String())

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil && oldStatus != status.String() {
		var actorID *string
		if input.ActorID != "" {
			actorID = &input.ActorID
		}
		if _, actErr := s.activityService.RecordStatusChange(
			ctx,
			f.TenantID().String(),
			findingID,
			actorID,
			oldStatus,
			status.String(),
			input.Resolution,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record status_changed activity", "error", actErr)
		}
	}

	return f, nil
}

// DeleteFinding deletes a finding by ID.
// tenantID is used for IDOR prevention - ensures the finding belongs to the caller's tenant.
func (s *VulnerabilityService) DeleteFinding(ctx context.Context, findingID string, tenantID string) error {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(findingID)
	if err != nil {
		return fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	if err := s.findingRepo.Delete(ctx, parsedTenantID, parsedID); err != nil {
		return err
	}

	s.logger.Info("finding deleted", "id", findingID)
	return nil
}

// ListFindingsInput represents the input for listing findings.
type ListFindingsInput struct {
	TenantID        string   `validate:"required,uuid"`
	AssetID         string   `validate:"omitempty,uuid"`
	BranchID        string   `validate:"omitempty,uuid"`
	ComponentID     string   `validate:"omitempty,uuid"`
	VulnerabilityID string   `validate:"omitempty,uuid"`
	Severities      []string `validate:"max=5,dive,severity"`
	Statuses        []string `validate:"max=10,dive,finding_status"`
	Sources         []string `validate:"max=5,dive,finding_source"`
	ToolName        string   `validate:"max=100"`
	RuleID          string   `validate:"max=255"`
	ScanID          string   `validate:"max=100"`
	FilePath        string   `validate:"max=500"`
	Search          string   `validate:"max=255"` // Full-text search across title, description, and file path
	Sort            string   `validate:"max=100"` // Sort field (e.g., "-severity", "created_at")
	Page            int      `validate:"min=0"`
	PerPage         int      `validate:"min=0,max=100"`
}

// ListFindings retrieves findings with filtering and pagination.
func (s *VulnerabilityService) ListFindings(ctx context.Context, input ListFindingsInput) (pagination.Result[*vulnerability.Finding], error) {
	tenantID, err := shared.IDFromString(input.TenantID)
	if err != nil {
		return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	filter := vulnerability.NewFindingFilter().WithTenantID(tenantID)

	if input.AssetID != "" {
		assetID, err := shared.IDFromString(input.AssetID)
		if err != nil {
			return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
		}
		filter = filter.WithAssetID(assetID)
	}

	if input.BranchID != "" {
		branchID, err := shared.IDFromString(input.BranchID)
		if err != nil {
			return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid branch id format", shared.ErrValidation)
		}
		filter = filter.WithBranchID(branchID)
	}

	if input.ComponentID != "" {
		compID, err := shared.IDFromString(input.ComponentID)
		if err != nil {
			return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid component id format", shared.ErrValidation)
		}
		filter = filter.WithComponentID(compID)
	}

	if input.VulnerabilityID != "" {
		vulnID, err := shared.IDFromString(input.VulnerabilityID)
		if err != nil {
			return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid vulnerability id format", shared.ErrValidation)
		}
		filter = filter.WithVulnerabilityID(vulnID)
	}

	if len(input.Severities) > 0 {
		severities := make([]vulnerability.Severity, 0, len(input.Severities))
		for _, sev := range input.Severities {
			if parsed, err := vulnerability.ParseSeverity(sev); err == nil {
				severities = append(severities, parsed)
			}
		}
		filter = filter.WithSeverities(severities...)
	}

	if len(input.Statuses) > 0 {
		statuses := make([]vulnerability.FindingStatus, 0, len(input.Statuses))
		for _, st := range input.Statuses {
			if parsed, err := vulnerability.ParseFindingStatus(st); err == nil {
				statuses = append(statuses, parsed)
			}
		}
		filter = filter.WithStatuses(statuses...)
	}

	if len(input.Sources) > 0 {
		sources := make([]vulnerability.FindingSource, 0, len(input.Sources))
		for _, src := range input.Sources {
			if parsed, err := vulnerability.ParseFindingSource(src); err == nil {
				sources = append(sources, parsed)
			}
		}
		filter = filter.WithSources(sources...)
	}

	if input.ToolName != "" {
		filter = filter.WithToolName(input.ToolName)
	}

	if input.RuleID != "" {
		filter = filter.WithRuleID(input.RuleID)
	}

	if input.ScanID != "" {
		filter = filter.WithScanID(input.ScanID)
	}

	if input.FilePath != "" {
		filter = filter.WithFilePath(input.FilePath)
	}

	if input.Search != "" {
		filter = filter.WithSearch(input.Search)
	}

	// Build list options with sorting
	opts := vulnerability.NewFindingListOptions()
	if input.Sort != "" {
		sortOpt := pagination.NewSortOption(vulnerability.FindingAllowedSortFields()).Parse(input.Sort)
		opts = opts.WithSort(sortOpt)
	}

	page := pagination.New(input.Page, input.PerPage)
	return s.findingRepo.List(ctx, filter, opts, page)
}

// GetFindingStats retrieves aggregated statistics for findings of a tenant.
func (s *VulnerabilityService) GetFindingStats(ctx context.Context, tenantID string) (*vulnerability.FindingStats, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	return s.findingRepo.GetStats(ctx, parsedTenantID)
}

// ListAssetFindings retrieves findings for a specific asset.
// tenantID is used for IDOR prevention - ensures the findings belong to the caller's tenant.
func (s *VulnerabilityService) ListAssetFindings(
	ctx context.Context,
	tenantID string,
	assetID string,
	sort string,
	page,
	perPage int,
) (pagination.Result[*vulnerability.Finding], error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedAssetID, err := shared.IDFromString(assetID)
	if err != nil {
		return pagination.Result[*vulnerability.Finding]{}, fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
	}

	opts := vulnerability.NewFindingListOptions()
	if sort != "" {
		sortOpt := pagination.NewSortOption(vulnerability.FindingAllowedSortFields()).Parse(sort)
		opts = opts.WithSort(sortOpt)
	}

	p := pagination.New(page, perPage)
	return s.findingRepo.ListByAssetID(ctx, parsedTenantID, parsedAssetID, opts, p)
}

// CountAssetFindings counts findings for an asset.
// tenantID is used for IDOR prevention - ensures the findings belong to the caller's tenant.
func (s *VulnerabilityService) CountAssetFindings(
	ctx context.Context,
	tenantID string,
	assetID string,
) (int64, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return 0, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedAssetID, err := shared.IDFromString(assetID)
	if err != nil {
		return 0, fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
	}

	return s.findingRepo.CountByAssetID(ctx, parsedTenantID, parsedAssetID)
}

// CountOpenAssetFindings counts open findings for an asset.
// tenantID is used for IDOR prevention - ensures the findings belong to the caller's tenant.
func (s *VulnerabilityService) CountOpenAssetFindings(
	ctx context.Context,
	tenantID string,
	assetID string,
) (int64, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return 0, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedAssetID, err := shared.IDFromString(assetID)
	if err != nil {
		return 0, fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
	}

	return s.findingRepo.CountOpenByAssetID(ctx, parsedTenantID, parsedAssetID)
}

// DeleteAssetFindings deletes all findings for an asset.
// tenantID is used for IDOR prevention - ensures the findings belong to the caller's tenant.
func (s *VulnerabilityService) DeleteAssetFindings(
	ctx context.Context,
	tenantID string,
	assetID string,
) error {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedAssetID, err := shared.IDFromString(assetID)
	if err != nil {
		return fmt.Errorf("%w: invalid asset id format", shared.ErrValidation)
	}

	if err := s.findingRepo.DeleteByAssetID(ctx, parsedTenantID, parsedAssetID); err != nil {
		return fmt.Errorf("failed to delete asset findings: %w", err)
	}

	s.logger.Info("asset findings deleted", "asset_id", assetID)
	return nil
}

// ============================================
// FINDING COMMENT OPERATIONS
// ============================================

// SetCommentRepository sets the comment repository for comment operations.
// This is optional and can be called after service creation.
func (s *VulnerabilityService) SetCommentRepository(repo vulnerability.FindingCommentRepository) {
	s.commentRepo = repo
}

// SetActivityService sets the activity service for audit trail tracking.
// When set, the service will automatically record activities for finding changes.
func (s *VulnerabilityService) SetActivityService(svc *FindingActivityService) {
	s.activityService = svc
}

// ListFindingComments retrieves all comments for a finding.
func (s *VulnerabilityService) ListFindingComments(ctx context.Context, findingID string) ([]*vulnerability.FindingComment, error) {
	if s.commentRepo == nil {
		return nil, fmt.Errorf("%w: comment repository not configured", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(findingID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid finding id format", shared.ErrValidation)
	}

	return s.commentRepo.ListByFinding(ctx, parsedID)
}

// AddFindingComment adds a comment to a finding.
// tenantID is used for IDOR prevention and activity logging.
func (s *VulnerabilityService) AddFindingComment(ctx context.Context, tenantID, findingID, authorID, content string) (*vulnerability.FindingComment, error) {
	if s.commentRepo == nil {
		return nil, fmt.Errorf("%w: comment repository not configured", shared.ErrValidation)
	}

	parsedFindingID, err := shared.IDFromString(findingID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid finding id format", shared.ErrValidation)
	}

	parsedAuthorID, err := shared.IDFromString(authorID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid author id format", shared.ErrValidation)
	}

	comment, err := vulnerability.NewFindingComment(parsedFindingID, parsedAuthorID, content)
	if err != nil {
		return nil, err
	}

	if err := s.commentRepo.Create(ctx, comment); err != nil {
		return nil, fmt.Errorf("failed to create comment: %w", err)
	}

	s.logger.Info("comment added", "comment_id", comment.ID().String(), "finding_id", findingID)

	// Record activity for audit trail (fire and forget - don't fail if activity recording fails)
	if s.activityService != nil {
		// Pass full content - RecordCommentAdded will store both full content and preview
		if _, actErr := s.activityService.RecordCommentAdded(
			ctx,
			tenantID,
			findingID,
			&authorID,
			comment.ID().String(),
			content, // Full content for display
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record comment_added activity", "error", actErr)
		}
	}

	return comment, nil
}

// UpdateFindingComment updates a comment's content.
// tenantID is used for activity logging.
func (s *VulnerabilityService) UpdateFindingComment(ctx context.Context, tenantID, commentID, authorID, content string) (*vulnerability.FindingComment, error) {
	if s.commentRepo == nil {
		return nil, fmt.Errorf("%w: comment repository not configured", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(commentID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid comment id format", shared.ErrValidation)
	}

	comment, err := s.commentRepo.GetByID(ctx, parsedID)
	if err != nil {
		return nil, err
	}

	// Only the author can update their comment
	if authorID != "" && comment.AuthorID().String() != authorID {
		return nil, fmt.Errorf("%w: only the author can update this comment", shared.ErrForbidden)
	}

	// Cannot edit status change comments
	if comment.IsStatusChange() {
		return nil, fmt.Errorf("%w: cannot edit status change comments", shared.ErrValidation)
	}

	if err := comment.UpdateContent(content); err != nil {
		return nil, err
	}

	if err := s.commentRepo.Update(ctx, comment); err != nil {
		return nil, fmt.Errorf("failed to update comment: %w", err)
	}

	s.logger.Info("comment updated", "comment_id", commentID)

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil {
		findingID := comment.FindingID()
		if _, actErr := s.activityService.RecordCommentUpdated(
			ctx,
			tenantID,
			findingID.String(),
			&authorID,
			commentID,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record comment_updated activity", "error", actErr)
		}
	}

	return comment, nil
}

// DeleteFindingComment deletes a comment.
// tenantID is used for activity logging.
func (s *VulnerabilityService) DeleteFindingComment(ctx context.Context, tenantID, commentID, authorID string) error {
	if s.commentRepo == nil {
		return fmt.Errorf("%w: comment repository not configured", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(commentID)
	if err != nil {
		return fmt.Errorf("%w: invalid comment id format", shared.ErrValidation)
	}

	comment, err := s.commentRepo.GetByID(ctx, parsedID)
	if err != nil {
		return err
	}

	// Only the author can delete their comment
	if authorID != "" && comment.AuthorID().String() != authorID {
		return fmt.Errorf("%w: only the author can delete this comment", shared.ErrForbidden)
	}

	// Cannot delete status change comments
	if comment.IsStatusChange() {
		return fmt.Errorf("%w: cannot delete status change comments", shared.ErrValidation)
	}

	// Store finding ID before deleting comment
	findingID := comment.FindingID()

	if err := s.commentRepo.Delete(ctx, parsedID); err != nil {
		return err
	}

	s.logger.Info("comment deleted", "comment_id", commentID)

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil {
		if _, actErr := s.activityService.RecordCommentDeleted(
			ctx,
			tenantID,
			findingID.String(),
			&authorID,
			commentID,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record comment_deleted activity", "error", actErr)
		}
	}

	return nil
}

// ============================================
// FINDING MANAGEMENT OPERATIONS
// ============================================

// AssignFinding assigns a finding to a user.
func (s *VulnerabilityService) AssignFinding(ctx context.Context, findingID, tenantID, userID, assignerID string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	parsedUserID, err := shared.IDFromString(userID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid user id format", shared.ErrValidation)
	}

	parsedAssignerID := shared.ID{}
	if assignerID != "" {
		parsedAssignerID, _ = shared.IDFromString(assignerID)
	}

	if err := f.Assign(parsedUserID, parsedAssignerID); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to assign finding: %w", err)
	}

	s.logger.Info("finding assigned", "id", findingID, "user_id", userID)

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil {
		var actorID *string
		if assignerID != "" {
			actorID = &assignerID
		}

		// Look up assignee's name and email for activity record
		var assigneeName, assigneeEmail string
		if s.userRepo != nil {
			if assignee, userErr := s.userRepo.GetByID(ctx, parsedUserID); userErr == nil && assignee != nil {
				assigneeName = assignee.Name()
				assigneeEmail = assignee.Email()
			}
		}

		if _, actErr := s.activityService.RecordAssignment(
			ctx,
			tenantID,
			findingID,
			actorID,
			userID,
			assigneeName,
			assigneeEmail,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record assigned activity", "error", actErr)
		}
	}

	return f, nil
}

// UnassignFinding removes the assignment from a finding.
func (s *VulnerabilityService) UnassignFinding(ctx context.Context, findingID, tenantID, actorID string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	// Capture previous assignee info before unassigning (for activity record)
	var previousAssigneeID, previousAssigneeName string
	if f.AssignedTo() != nil {
		previousAssigneeID = f.AssignedTo().String()
		// Look up previous assignee's name for activity record
		if s.userRepo != nil {
			if prevUser, userErr := s.userRepo.GetByID(ctx, *f.AssignedTo()); userErr == nil && prevUser != nil {
				previousAssigneeName = prevUser.Name()
			}
		}
		// Fall back to ID if name lookup fails
		if previousAssigneeName == "" {
			previousAssigneeName = previousAssigneeID
		}
	}

	f.Unassign()

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to unassign finding: %w", err)
	}

	s.logger.Info("finding unassigned", "id", findingID)

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil && previousAssigneeID != "" {
		var actorIDPtr *string
		if actorID != "" {
			actorIDPtr = &actorID
		}
		if _, actErr := s.activityService.RecordUnassignment(
			ctx,
			tenantID,
			findingID,
			actorIDPtr,
			previousAssigneeName,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record unassigned activity", "error", actErr)
		}
	}

	return f, nil
}

// ClassifyFindingInput represents input for classification.
type ClassifyFindingInput struct {
	CVEID      string
	CVSSScore  *float64
	CVSSVector string
	CWEIDs     []string
	OWASPIDs   []string
}

// ClassifyFinding sets classification data on a finding.
func (s *VulnerabilityService) ClassifyFinding(ctx context.Context, findingID, tenantID string, input ClassifyFindingInput) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	if err := f.SetClassification(input.CVEID, input.CVSSScore, input.CVSSVector, input.CWEIDs, input.OWASPIDs); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to classify finding: %w", err)
	}

	s.logger.Info("finding classified", "id", findingID, "cve_id", input.CVEID)
	return f, nil
}

// UpdateFindingSeverity updates a finding's severity.
func (s *VulnerabilityService) UpdateFindingSeverity(ctx context.Context, findingID, tenantID, severityStr, actorID string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	// Capture old severity before update
	oldSeverity := f.Severity().String()

	severity, err := vulnerability.ParseSeverity(severityStr)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	if err := f.UpdateSeverity(severity); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to update finding severity: %w", err)
	}

	s.logger.Info("finding severity updated", "id", findingID, "severity", severityStr)

	// Record activity for audit trail (fire and forget)
	if s.activityService != nil && oldSeverity != severityStr {
		var actorIDPtr *string
		if actorID != "" {
			actorIDPtr = &actorID
		}
		if _, actErr := s.activityService.RecordSeverityChange(
			ctx,
			tenantID,
			findingID,
			actorIDPtr,
			oldSeverity,
			severityStr,
			string(vulnerability.SourceAPI),
		); actErr != nil {
			s.logger.Warn("failed to record severity_changed activity", "error", actErr)
		}
	}

	return f, nil
}

// TriageFinding confirms a finding (triage = confirm the finding is real).
// This is a convenience method that transitions status from "new" to "confirmed".
// For other status changes, use UpdateFindingStatus.
func (s *VulnerabilityService) TriageFinding(ctx context.Context, findingID, tenantID, userID, reason string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	// Parse user ID for resolved_by
	var resolvedBy *shared.ID
	if userID != "" {
		id, err := shared.IDFromString(userID)
		if err == nil {
			resolvedBy = &id
		}
	}

	// Triage = confirm the finding (not a terminal state, so resolvedBy won't be set)
	if err := f.UpdateStatusWithReason(vulnerability.FindingStatusConfirmed, reason, "", resolvedBy); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to triage finding: %w", err)
	}

	s.logger.Info("finding triaged (confirmed)", "id", findingID)
	return f, nil
}

// VerifyFinding marks a resolved finding as verified.
func (s *VulnerabilityService) VerifyFinding(ctx context.Context, findingID, tenantID, userID string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	parsedUserID, err := shared.IDFromString(userID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid user id format", shared.ErrValidation)
	}

	if err := f.Verify(parsedUserID); err != nil {
		return nil, err
	}

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to verify finding: %w", err)
	}

	s.logger.Info("finding verified", "id", findingID)
	return f, nil
}

// SetFindingTags sets tags on a finding.
func (s *VulnerabilityService) SetFindingTags(ctx context.Context, findingID, tenantID string, tags []string) (*vulnerability.Finding, error) {
	f, err := s.getFindingWithTenantCheck(ctx, findingID, tenantID)
	if err != nil {
		return nil, err
	}

	f.SetTags(tags)

	if err := s.findingRepo.Update(ctx, f); err != nil {
		return nil, fmt.Errorf("failed to set finding tags: %w", err)
	}

	s.logger.Info("finding tags updated", "id", findingID, "tags_count", len(tags))
	return f, nil
}

// ============================================
// BULK OPERATIONS
// ============================================

// BulkUpdateStatusInput represents input for bulk status update.
type BulkUpdateStatusInput struct {
	FindingIDs []string
	Status     string
	Resolution string
	ActorID    string // User performing the bulk update
}

// BulkUpdateResult represents the result of a bulk operation.
type BulkUpdateResult struct {
	Updated int
	Failed  int
	Errors  []string
}

// BulkUpdateFindingsStatus updates the status of multiple findings.
func (s *VulnerabilityService) BulkUpdateFindingsStatus(ctx context.Context, tenantID string, input BulkUpdateStatusInput) (*BulkUpdateResult, error) {
	status, err := vulnerability.ParseFindingStatus(input.Status)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", shared.ErrValidation, err)
	}

	// Parse actor ID for resolved_by
	var actorID *shared.ID
	if input.ActorID != "" {
		id, err := shared.IDFromString(input.ActorID)
		if err == nil {
			actorID = &id
		}
	}

	result := &BulkUpdateResult{}

	for _, idStr := range input.FindingIDs {
		f, err := s.getFindingWithTenantCheck(ctx, idStr, tenantID)
		if err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		// Check workflow transition
		if !f.CanTransitionTo(status) {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: cannot transition from %s to %s", idStr, f.Status(), status))
			continue
		}

		if err := f.TransitionStatus(status, input.Resolution, actorID); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		if err := s.findingRepo.Update(ctx, f); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		result.Updated++
	}

	s.logger.Info("bulk status update completed", "updated", result.Updated, "failed", result.Failed)
	return result, nil
}

// BulkAssignInput represents input for bulk assignment.
type BulkAssignInput struct {
	FindingIDs []string
	UserID     string
	AssignerID string
}

// BulkAssignFindings assigns multiple findings to a user.
func (s *VulnerabilityService) BulkAssignFindings(ctx context.Context, tenantID string, input BulkAssignInput) (*BulkUpdateResult, error) {
	parsedUserID, err := shared.IDFromString(input.UserID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid user id format", shared.ErrValidation)
	}

	parsedAssignerID := shared.ID{}
	if input.AssignerID != "" {
		parsedAssignerID, _ = shared.IDFromString(input.AssignerID)
	}

	result := &BulkUpdateResult{}

	for _, idStr := range input.FindingIDs {
		f, err := s.getFindingWithTenantCheck(ctx, idStr, tenantID)
		if err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		if err := f.Assign(parsedUserID, parsedAssignerID); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		if err := s.findingRepo.Update(ctx, f); err != nil {
			result.Failed++
			result.Errors = append(result.Errors, fmt.Sprintf("%s: %v", idStr, err))
			continue
		}

		result.Updated++
	}

	s.logger.Info("bulk assign completed", "updated", result.Updated, "failed", result.Failed)
	return result, nil
}

// ============================================
// HELPERS
// ============================================

// getFindingWithTenantCheck retrieves a finding and verifies tenant access.
func (s *VulnerabilityService) getFindingWithTenantCheck(ctx context.Context, findingID, tenantID string) (*vulnerability.Finding, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid tenant id format", shared.ErrValidation)
	}

	parsedID, err := shared.IDFromString(findingID)
	if err != nil {
		return nil, fmt.Errorf("%w: invalid id format", shared.ErrValidation)
	}

	f, err := s.findingRepo.GetByID(ctx, parsedTenantID, parsedID)
	if err != nil {
		return nil, err
	}

	return f, nil
}

// GetFindingCountsByScanID returns the count of findings by severity for a scan.
// Used for quality gate evaluation.
func (s *VulnerabilityService) GetFindingCountsByScanID(ctx context.Context, tenantID, scanID string) (vulnerability.SeverityCounts, error) {
	parsedTenantID, err := shared.IDFromString(tenantID)
	if err != nil {
		return vulnerability.SeverityCounts{}, fmt.Errorf("%w: invalid tenant id", shared.ErrValidation)
	}

	return s.findingRepo.CountBySeverityForScan(ctx, parsedTenantID, scanID)
}
