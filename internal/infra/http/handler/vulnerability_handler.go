package handler

import (
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"time"

	"github.com/openctemio/api/internal/app"
	"github.com/openctemio/api/internal/infra/http/middleware"
	"github.com/openctemio/api/pkg/apierror"
	"github.com/openctemio/api/pkg/domain/component"
	"github.com/openctemio/api/pkg/domain/shared"
	"github.com/openctemio/api/pkg/domain/vulnerability"
	"github.com/openctemio/api/pkg/logger"
	"github.com/openctemio/api/pkg/validator"
)

// VulnerabilityHandler handles vulnerability and finding HTTP requests.
type VulnerabilityHandler struct {
	service      *app.VulnerabilityService
	userService  *app.UserService
	assetService *app.AssetService
	validator    *validator.Validator
	logger       *logger.Logger
}

// NewVulnerabilityHandler creates a new vulnerability handler.
func NewVulnerabilityHandler(svc *app.VulnerabilityService, v *validator.Validator, log *logger.Logger) *VulnerabilityHandler {
	return &VulnerabilityHandler{
		service:   svc,
		validator: v,
		logger:    log,
	}
}

// SetUserService sets the user service for fetching assigned user info.
func (h *VulnerabilityHandler) SetUserService(svc *app.UserService) {
	h.userService = svc
}

// SetAssetService sets the asset service for fetching asset info.
func (h *VulnerabilityHandler) SetAssetService(svc *app.AssetService) {
	h.assetService = svc
}

// ============================================
// HELPER FUNCTIONS
// ============================================

// idToStringPtr converts a shared.ID pointer to a string pointer.
func idToStringPtr(id *shared.ID) *string {
	if id == nil || id.IsZero() {
		return nil
	}
	s := id.String()
	return &s
}

// ============================================
// VULNERABILITY TYPES
// ============================================

// VulnerabilityResponse represents a vulnerability in API responses.
type VulnerabilityResponse struct {
	ID               string                    `json:"id"`
	CVEID            string                    `json:"cve_id"`
	Aliases          []string                  `json:"aliases,omitempty"`
	Title            string                    `json:"title"`
	Description      string                    `json:"description,omitempty"`
	Severity         string                    `json:"severity"`
	CVSSScore        *float64                  `json:"cvss_score,omitempty"`
	CVSSVector       string                    `json:"cvss_vector,omitempty"`
	EPSSScore        *float64                  `json:"epss_score,omitempty"`
	EPSSPercentile   *float64                  `json:"epss_percentile,omitempty"`
	CISAKEV          *CISAKEVResponse          `json:"cisa_kev,omitempty"`
	ExploitAvailable bool                      `json:"exploit_available"`
	ExploitMaturity  string                    `json:"exploit_maturity"`
	References       []ReferenceResponse       `json:"references,omitempty"`
	AffectedVersions []AffectedVersionResponse `json:"affected_versions,omitempty"`
	FixedVersions    []string                  `json:"fixed_versions,omitempty"`
	Remediation      string                    `json:"remediation,omitempty"`
	PublishedAt      *time.Time                `json:"published_at,omitempty"`
	ModifiedAt       *time.Time                `json:"modified_at,omitempty"`
	Status           string                    `json:"status"`
	RiskScore        float64                   `json:"risk_score"`
	CreatedAt        time.Time                 `json:"created_at"`
	UpdatedAt        time.Time                 `json:"updated_at"`
}

// CISAKEVResponse represents CISA KEV data in API responses.
type CISAKEVResponse struct {
	DateAdded     time.Time `json:"date_added"`
	DueDate       time.Time `json:"due_date"`
	RansomwareUse string    `json:"ransomware_use,omitempty"`
	Notes         string    `json:"notes,omitempty"`
	IsPastDue     bool      `json:"is_past_due"`
}

// ReferenceResponse represents a reference in API responses.
type ReferenceResponse struct {
	Type string `json:"type"`
	URL  string `json:"url"`
}

// AffectedVersionResponse represents an affected version in API responses.
type AffectedVersionResponse struct {
	Ecosystem  string `json:"ecosystem"`
	Package    string `json:"package"`
	Introduced string `json:"introduced,omitempty"`
	Fixed      string `json:"fixed,omitempty"`
}

// CreateVulnerabilityRequest represents the request to create a vulnerability.
type CreateVulnerabilityRequest struct {
	CVEID            string   `json:"cve_id" validate:"required"`
	Title            string   `json:"title" validate:"required,min=1,max=500"`
	Description      string   `json:"description" validate:"max=10000"`
	Severity         string   `json:"severity" validate:"required"`
	CVSSScore        *float64 `json:"cvss_score" validate:"omitempty,min=0,max=10"`
	CVSSVector       string   `json:"cvss_vector" validate:"max=100"`
	EPSSScore        *float64 `json:"epss_score" validate:"omitempty,min=0,max=1"`
	EPSSPercentile   *float64 `json:"epss_percentile" validate:"omitempty,min=0,max=1"`
	ExploitAvailable bool     `json:"exploit_available"`
	ExploitMaturity  string   `json:"exploit_maturity" validate:"omitempty"`
	FixedVersions    []string `json:"fixed_versions" validate:"max=50,dive,max=100"`
	Remediation      string   `json:"remediation" validate:"max=5000"`
}

// UpdateVulnerabilityRequest represents the request to update a vulnerability.
type UpdateVulnerabilityRequest struct {
	Title            *string  `json:"title" validate:"omitempty,min=1,max=500"`
	Description      *string  `json:"description" validate:"omitempty,max=10000"`
	Severity         *string  `json:"severity" validate:"omitempty"`
	CVSSScore        *float64 `json:"cvss_score" validate:"omitempty,min=0,max=10"`
	CVSSVector       *string  `json:"cvss_vector" validate:"omitempty,max=100"`
	EPSSScore        *float64 `json:"epss_score" validate:"omitempty,min=0,max=1"`
	EPSSPercentile   *float64 `json:"epss_percentile" validate:"omitempty,min=0,max=1"`
	ExploitAvailable *bool    `json:"exploit_available"`
	ExploitMaturity  *string  `json:"exploit_maturity" validate:"omitempty"`
	FixedVersions    []string `json:"fixed_versions" validate:"omitempty,max=50,dive,max=100"`
	Remediation      *string  `json:"remediation" validate:"omitempty,max=5000"`
	Status           *string  `json:"status" validate:"omitempty"`
}

// ============================================
// FINDING TYPES
// ============================================

// FindingAssignedUser contains basic info about the assigned user.
type FindingAssignedUser struct {
	ID    string `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

// FindingAssetInfo contains essential asset info for finding display.
type FindingAssetInfo struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Type   string `json:"type"`
	WebURL string `json:"web_url,omitempty"` // Repository web URL (e.g., github.com/org/repo)
}

// FindingComponentInfo contains component info for SCA findings.
// Industry-aligned with CycloneDX, Snyk, and Dependency-Track patterns.
type FindingComponentInfo struct {
	ID        string `json:"id"`                 // Global component ID
	Name      string `json:"name"`               // Package name (e.g., "lodash")
	Version   string `json:"version"`            // Package version (e.g., "4.17.20")
	Ecosystem string `json:"ecosystem"`          // Package ecosystem (e.g., "npm", "pypi")
	PURL      string `json:"purl,omitempty"`     // Package URL
	License   string `json:"license,omitempty"`  // License identifier
	IsDirect  bool   `json:"is_direct"`          // true if direct dependency
	Depth     int    `json:"depth"`              // Dependency depth (1=direct, 2+=transitive)
	FixedIn   string `json:"fixed_in,omitempty"` // Version that fixes the vulnerability
}

// DataFlowLocationResponse represents a single location in a data flow trace.
type DataFlowLocationResponse struct {
	// Physical location
	Path      string `json:"path,omitempty"`
	Line      int    `json:"line,omitempty"`
	EndLine   int    `json:"end_line,omitempty"`
	Column    int    `json:"column,omitempty"`
	EndColumn int    `json:"end_column,omitempty"`
	Snippet   string `json:"snippet,omitempty"` // Code at this location

	// Logical location (function/class context)
	FunctionName       string `json:"function_name,omitempty"`
	ClassName          string `json:"class_name,omitempty"`
	FullyQualifiedName string `json:"fully_qualified_name,omitempty"`
	ModuleName         string `json:"module_name,omitempty"`

	// Context
	Label        string `json:"label,omitempty"`         // Variable/expression name
	Message      string `json:"message,omitempty"`       // Description of what happens
	Index        int    `json:"index,omitempty"`         // Step order in the flow
	LocationType string `json:"location_type,omitempty"` // source, intermediate, sink, sanitizer
	NestingLevel int    `json:"nesting_level,omitempty"` // For display indentation
	Importance   string `json:"importance,omitempty"`    // essential, important, unimportant
}

// DataFlowStepResponse represents a single step in a data flow with full details.
type DataFlowStepResponse struct {
	Index        int                       `json:"index"`
	LocationType string                    `json:"location_type"` // source, intermediate, sink, sanitizer
	Location     *DataFlowLocationResponse `json:"location,omitempty"`
	Label        string                    `json:"label,omitempty"`
	Message      string                    `json:"message,omitempty"`
	Importance   string                    `json:"importance,omitempty"`
}

// DataFlowTraceResponse represents a single data flow trace (attack path).
type DataFlowTraceResponse struct {
	Index      int                    `json:"index"`                // Flow index within finding
	Message    string                 `json:"message,omitempty"`    // Flow summary
	Importance string                 `json:"importance,omitempty"` // essential, important, unimportant
	Steps      []DataFlowStepResponse `json:"steps"`                // Ordered steps from source to sink
}

// DataFlowResponse represents data flow traces for taint tracking/attack path.
// Provides both grouped (sources/intermediates/sinks) and ordered (traces) views.
type DataFlowResponse struct {
	// Grouped view - locations by type (for quick visualization)
	Sources       []DataFlowLocationResponse `json:"sources,omitempty"`
	Intermediates []DataFlowLocationResponse `json:"intermediates,omitempty"`
	Sinks         []DataFlowLocationResponse `json:"sinks,omitempty"`
	Sanitizers    []DataFlowLocationResponse `json:"sanitizers,omitempty"`

	// Ordered view - full traces with all details (for detailed analysis)
	Traces []DataFlowTraceResponse `json:"traces,omitempty"`

	// Summary
	TotalSteps int `json:"total_steps,omitempty"` // Total number of steps across all traces
}

// FixRegexResponse represents a regex-based fix pattern.
type FixRegexResponse struct {
	Regex       string `json:"regex"`           // Regex pattern to match
	Replacement string `json:"replacement"`     // Replacement string
	Count       int    `json:"count,omitempty"` // Number of replacements (0 = all)
}

// FindingRemediationResponse represents the remediation JSONB in API responses.
type FindingRemediationResponse struct {
	Recommendation string            `json:"recommendation,omitempty"` // Human-readable guidance
	FixCode        string            `json:"fix_code,omitempty"`       // Actual code to apply
	FixRegex       *FixRegexResponse `json:"fix_regex,omitempty"`      // Regex-based fix pattern
	Steps          []string          `json:"steps,omitempty"`          // Step-by-step instructions
	References     []string          `json:"references,omitempty"`     // Reference URLs
	Effort         string            `json:"effort,omitempty"`         // trivial, low, medium, high
	FixAvailable   bool              `json:"fix_available,omitempty"`  // Whether a fix is available
	AutoFixable    bool              `json:"auto_fixable,omitempty"`   // Whether the fix can be auto-applied
}

// FindingResponse represents a finding in API responses.
type FindingResponse struct {
	ID                  string                      `json:"id"`
	TenantID            string                      `json:"tenant_id"`
	VulnerabilityID     *string                     `json:"vulnerability_id,omitempty"`
	AssetID             string                      `json:"asset_id"`
	Asset               *FindingAssetInfo           `json:"asset,omitempty"` // Full asset info
	BranchID            *string                     `json:"branch_id,omitempty"`
	ComponentID         *string                     `json:"component_id,omitempty"`
	Component           *FindingComponentInfo       `json:"component,omitempty"` // Embedded component info for SCA findings
	Source              string                      `json:"source"`
	ToolName            string                      `json:"tool_name"`
	ToolVersion         string                      `json:"tool_version,omitempty"`
	RuleID              string                      `json:"rule_id,omitempty"`
	RuleName            string                      `json:"rule_name,omitempty"`
	FilePath            string                      `json:"file_path,omitempty"`
	StartLine           int                         `json:"start_line,omitempty"`
	EndLine             int                         `json:"end_line,omitempty"`
	StartColumn         int                         `json:"start_column,omitempty"`
	EndColumn           int                         `json:"end_column,omitempty"`
	Snippet             string                      `json:"snippet,omitempty"`
	ContextSnippet      string                      `json:"context_snippet,omitempty"`
	ContextStartLine    int                         `json:"context_start_line,omitempty"`
	Title               string                      `json:"title,omitempty"`
	Description         string                      `json:"description,omitempty"`
	Message             string                      `json:"message"`
	Recommendation      string                      `json:"recommendation,omitempty"`
	FixCode             string                      `json:"fix_code,omitempty"`    // Auto-fix code snippet
	FixRegex            *FixRegexResponse           `json:"fix_regex,omitempty"`   // Regex-based fix pattern
	Remediation         *FindingRemediationResponse `json:"remediation,omitempty"` // Full remediation JSONB
	Severity            string                      `json:"severity"`
	CVSSScore           *float64                    `json:"cvss_score,omitempty"`
	CVSSVector          string                      `json:"cvss_vector,omitempty"`
	CVEID               string                      `json:"cve_id,omitempty"`
	CWEIDs              []string                    `json:"cwe_ids,omitempty"`
	OWASPIDs            []string                    `json:"owasp_ids,omitempty"`
	Tags                []string                    `json:"tags,omitempty"`
	Status              string                      `json:"status"`
	Resolution          string                      `json:"resolution,omitempty"`
	ResolvedAt          *time.Time                  `json:"resolved_at,omitempty"`
	ResolvedBy          *string                     `json:"resolved_by,omitempty"` // User ID who resolved
	IsTriaged           bool                        `json:"is_triaged"`            // true if status != "new"
	AssignedTo          *string                     `json:"assigned_to,omitempty"`
	AssignedToUser      *FindingAssignedUser        `json:"assigned_to_user,omitempty"` // Full user info
	AssignedAt          *time.Time                  `json:"assigned_at,omitempty"`
	AssignedBy          *string                     `json:"assigned_by,omitempty"`
	VerifiedAt          *time.Time                  `json:"verified_at,omitempty"`
	VerifiedBy          *string                     `json:"verified_by,omitempty"`
	SLADeadline         *time.Time                  `json:"sla_deadline,omitempty"`
	SLAStatus           string                      `json:"sla_status,omitempty"`
	FirstDetectedAt     time.Time                   `json:"first_detected_at,omitempty"`
	LastSeenAt          time.Time                   `json:"last_seen_at,omitempty"`
	FirstDetectedBranch string                      `json:"first_detected_branch,omitempty"`
	FirstDetectedCommit string                      `json:"first_detected_commit,omitempty"`
	LastSeenBranch      string                      `json:"last_seen_branch,omitempty"`
	LastSeenCommit      string                      `json:"last_seen_commit,omitempty"`
	DuplicateOf         *string                     `json:"duplicate_of,omitempty"`
	DuplicateCount      int                         `json:"duplicate_count"`
	CommentsCount       int                         `json:"comments_count"`
	ScanID              string                      `json:"scan_id,omitempty"`
	Fingerprint         string                      `json:"fingerprint"`
	Location            string                      `json:"location,omitempty"`
	Metadata            map[string]any              `json:"metadata,omitempty"`
	CreatedAt           time.Time                   `json:"created_at"`
	UpdatedAt           time.Time                   `json:"updated_at"`

	// SARIF 2.1.0 Fields
	Confidence          *int                            `json:"confidence,omitempty"`
	Impact              string                          `json:"impact,omitempty"`
	Likelihood          string                          `json:"likelihood,omitempty"`
	VulnerabilityClass  []string                        `json:"vulnerability_class,omitempty"`
	Subcategory         []string                        `json:"subcategory,omitempty"`
	BaselineState       string                          `json:"baseline_state,omitempty"`
	Kind                string                          `json:"kind,omitempty"`
	Rank                *float64                        `json:"rank,omitempty"`
	OccurrenceCount     int                             `json:"occurrence_count,omitempty"`
	CorrelationID       string                          `json:"correlation_id,omitempty"`
	PartialFingerprints map[string]string               `json:"partial_fingerprints,omitempty"`
	RelatedLocations    []vulnerability.FindingLocation `json:"related_locations,omitempty"`
	Stacks              []vulnerability.StackTrace      `json:"stacks,omitempty"`
	Attachments         []vulnerability.Attachment      `json:"attachments,omitempty"`
	WorkItemURIs        []string                        `json:"work_item_uris,omitempty"`
	HostedViewerURI     string                          `json:"hosted_viewer_uri,omitempty"`

	// CTEM Fields
	ExposureVector       string   `json:"exposure_vector,omitempty"`
	IsNetworkAccessible  bool     `json:"is_network_accessible,omitempty"`
	IsInternetAccessible bool     `json:"is_internet_accessible,omitempty"`
	AttackPrerequisites  string   `json:"attack_prerequisites,omitempty"`
	RemediationType      string   `json:"remediation_type,omitempty"`
	EstimatedFixTime     *int     `json:"estimated_fix_time,omitempty"`
	FixComplexity        string   `json:"fix_complexity,omitempty"`
	RemedyAvailable      bool     `json:"remedy_available,omitempty"`
	DataExposureRisk     string   `json:"data_exposure_risk,omitempty"`
	ReputationalImpact   bool     `json:"reputational_impact,omitempty"`
	ComplianceImpact     []string `json:"compliance_impact,omitempty"`

	// Finding Type discriminator
	FindingType string `json:"finding_type,omitempty"` // vulnerability, secret, misconfiguration, compliance, web3

	// Data Flow / Taint Tracking (Attack Path)
	HasDataFlow bool              `json:"has_data_flow,omitempty"` // Lightweight flag for list views
	DataFlow    *DataFlowResponse `json:"data_flow,omitempty"`     // Full data when fetching single finding

	// Secret-specific fields
	SecretType    string `json:"secret_type,omitempty"`
	SecretService string `json:"secret_service,omitempty"`
	SecretValid   *bool  `json:"secret_valid,omitempty"`
	SecretRevoked *bool  `json:"secret_revoked,omitempty"`

	// Compliance-specific fields
	ComplianceFramework string `json:"compliance_framework,omitempty"`
	ComplianceControlID string `json:"compliance_control_id,omitempty"`
	ComplianceResult    string `json:"compliance_result,omitempty"`

	// Web3-specific fields
	Web3Chain           string `json:"web3_chain,omitempty"`
	Web3ContractAddress string `json:"web3_contract_address,omitempty"`
	Web3SwcID           string `json:"web3_swc_id,omitempty"`

	// Misconfiguration-specific fields
	MisconfigPolicyID     string `json:"misconfig_policy_id,omitempty"`
	MisconfigResourceType string `json:"misconfig_resource_type,omitempty"`
	MisconfigExpected     string `json:"misconfig_expected,omitempty"`
	MisconfigActual       string `json:"misconfig_actual,omitempty"`
}

// CreateFindingRequest represents the request to create a finding.
type CreateFindingRequest struct {
	AssetID         string `json:"asset_id" validate:"required,uuid"`
	BranchID        string `json:"branch_id" validate:"omitempty,uuid"`
	VulnerabilityID string `json:"vulnerability_id" validate:"omitempty,uuid"`
	ComponentID     string `json:"component_id" validate:"omitempty,uuid"`
	Source          string `json:"source" validate:"required"`
	ToolName        string `json:"tool_name" validate:"required,max=100"`
	ToolVersion     string `json:"tool_version" validate:"max=50"`
	RuleID          string `json:"rule_id" validate:"max=255"`
	FilePath        string `json:"file_path" validate:"max=500"`
	StartLine       int    `json:"start_line" validate:"min=0"`
	EndLine         int    `json:"end_line" validate:"min=0"`
	StartColumn     int    `json:"start_column" validate:"min=0"`
	EndColumn       int    `json:"end_column" validate:"min=0"`
	Snippet         string `json:"snippet" validate:"max=5000"`
	Message         string `json:"message" validate:"required,max=2000"`
	Severity        string `json:"severity" validate:"required"`
	ScanID          string `json:"scan_id" validate:"max=100"`
}

// UpdateFindingStatusRequest represents the request to update a finding's status.
// Note: resolved_by is automatically set from the authenticated user, not from request
type UpdateFindingStatusRequest struct {
	Status     string `json:"status" validate:"required"`
	Resolution string `json:"resolution" validate:"max=1000"`
}

// AssignFindingRequest represents the request to assign a finding to a user.
type AssignFindingRequest struct {
	UserID string `json:"user_id" validate:"required,uuid"`
}

// ClassifyFindingRequest represents the request to classify a finding with CVE/CWE/CVSS.
type ClassifyFindingRequest struct {
	CVEID      string   `json:"cve_id" validate:"max=20"`
	CVSSScore  *float64 `json:"cvss_score" validate:"omitempty,min=0,max=10"`
	CVSSVector string   `json:"cvss_vector" validate:"max=100"`
	CWEIDs     []string `json:"cwe_ids" validate:"max=20,dive,max=20"`
	OWASPIDs   []string `json:"owasp_ids" validate:"max=20,dive,max=50"`
}

// UpdateSeverityRequest represents the request to update a finding's severity.
type UpdateSeverityRequest struct {
	Severity string `json:"severity" validate:"required"`
}

// TriageFindingRequest represents the request to triage (confirm) a finding.
// Triage = confirm the finding is real (transitions from "new" to "confirmed")
type TriageFindingRequest struct {
	Reason string `json:"reason" validate:"max=1000"` // Optional reason for confirmation
}

// VerifyFindingRequest represents the request to verify a finding fix.
type VerifyFindingRequest struct {
	Notes string `json:"notes" validate:"max=1000"`
}

// SetTagsRequest represents the request to set tags on a finding.
type SetTagsRequest struct {
	Tags []string `json:"tags" validate:"max=50,dive,max=100"`
}

// BulkUpdateStatusRequest represents a bulk status update request.
type BulkUpdateStatusRequest struct {
	FindingIDs []string `json:"finding_ids" validate:"required,min=1,max=100,dive,uuid"`
	Status     string   `json:"status" validate:"required"`
	Resolution string   `json:"resolution" validate:"max=1000"`
}

// BulkAssignRequest represents a bulk assignment request.
type BulkAssignRequest struct {
	FindingIDs []string `json:"finding_ids" validate:"required,min=1,max=100,dive,uuid"`
	UserID     string   `json:"user_id" validate:"required,uuid"`
}

// BulkUpdateResponse represents the response for bulk operations.
type BulkUpdateResponse struct {
	Updated int      `json:"updated"`
	Failed  int      `json:"failed"`
	Errors  []string `json:"errors,omitempty"`
}

// ============================================
// CONVERTERS
// ============================================

func toVulnerabilityResponse(v *vulnerability.Vulnerability) VulnerabilityResponse {
	resp := VulnerabilityResponse{
		ID:               v.ID().String(),
		CVEID:            v.CVEID(),
		Aliases:          v.Aliases(),
		Title:            v.Title(),
		Description:      v.Description(),
		Severity:         v.Severity().String(),
		CVSSScore:        v.CVSSScore(),
		CVSSVector:       v.CVSSVector(),
		EPSSScore:        v.EPSSScore(),
		EPSSPercentile:   v.EPSSPercentile(),
		ExploitAvailable: v.ExploitAvailable(),
		ExploitMaturity:  v.ExploitMaturity().String(),
		FixedVersions:    v.FixedVersions(),
		Remediation:      v.Remediation(),
		PublishedAt:      v.PublishedAt(),
		ModifiedAt:       v.ModifiedAt(),
		Status:           v.Status().String(),
		RiskScore:        v.RiskScore(),
		CreatedAt:        v.CreatedAt(),
		UpdatedAt:        v.UpdatedAt(),
	}

	if kev := v.CISAKEV(); kev != nil && !kev.IsZero() {
		resp.CISAKEV = &CISAKEVResponse{
			DateAdded:     kev.DateAdded(),
			DueDate:       kev.DueDate(),
			RansomwareUse: kev.RansomwareUse(),
			Notes:         kev.Notes(),
			IsPastDue:     kev.IsPastDue(),
		}
	}

	refs := v.References()
	resp.References = make([]ReferenceResponse, len(refs))
	for i, r := range refs {
		resp.References[i] = ReferenceResponse{
			Type: r.Type(),
			URL:  r.URL(),
		}
	}

	affected := v.AffectedVersions()
	resp.AffectedVersions = make([]AffectedVersionResponse, len(affected))
	for i, av := range affected {
		resp.AffectedVersions[i] = AffectedVersionResponse{
			Ecosystem:  av.Ecosystem(),
			Package:    av.Package(),
			Introduced: av.Introduced(),
			Fixed:      av.Fixed(),
		}
	}

	return resp
}

// ToFindingComponentInfo converts a component to FindingComponentInfo.
// Used to enrich finding responses with component details for SCA findings.
// Exported so handlers can use it when enriching findings.
func ToFindingComponentInfo(c *component.Component, depth int, isDirect bool) *FindingComponentInfo {
	if c == nil {
		return nil
	}
	return &FindingComponentInfo{
		ID:        c.ID().String(),
		Name:      c.Name(),
		Version:   c.Version(),
		Ecosystem: c.Ecosystem().String(),
		PURL:      c.PURL(),
		License:   c.License(),
		IsDirect:  isDirect,
		Depth:     depth,
	}
}

// toFixRegexResponse converts a domain FixRegex to an API response.
func toFixRegexResponse(fr *vulnerability.FixRegex) *FixRegexResponse {
	if fr == nil || fr.IsEmpty() {
		return nil
	}
	return &FixRegexResponse{
		Regex:       fr.Regex,
		Replacement: fr.Replacement,
		Count:       fr.Count,
	}
}

// toFindingRemediationResponse converts a domain FindingRemediation to an API response.
func toFindingRemediationResponse(r *vulnerability.FindingRemediation) *FindingRemediationResponse {
	if r == nil || r.IsEmpty() {
		return nil
	}
	resp := &FindingRemediationResponse{
		Recommendation: r.Recommendation,
		FixCode:        r.FixCode,
		Steps:          r.Steps,
		References:     r.References,
		Effort:         r.Effort,
		FixAvailable:   r.FixAvailable,
		AutoFixable:    r.AutoFixable,
	}
	if r.FixRegex != nil && !r.FixRegex.IsEmpty() {
		resp.FixRegex = &FixRegexResponse{
			Regex:       r.FixRegex.Regex,
			Replacement: r.FixRegex.Replacement,
			Count:       r.FixRegex.Count,
		}
	}
	return resp
}

func toFindingResponse(f *vulnerability.Finding) FindingResponse {
	resp := FindingResponse{
		ID:                  f.ID().String(),
		TenantID:            f.TenantID().String(),
		AssetID:             f.AssetID().String(),
		Source:              f.Source().String(),
		ToolName:            f.ToolName(),
		ToolVersion:         f.ToolVersion(),
		RuleID:              f.RuleID(),
		RuleName:            f.RuleName(),
		FilePath:            f.FilePath(),
		StartLine:           f.StartLine(),
		EndLine:             f.EndLine(),
		StartColumn:         f.StartColumn(),
		EndColumn:           f.EndColumn(),
		Snippet:             f.Snippet(),
		ContextSnippet:      f.ContextSnippet(),
		ContextStartLine:    f.ContextStartLine(),
		Title:               f.Title(),
		Description:         f.Description(),
		Message:             f.Message(),
		Recommendation:      f.Recommendation(),
		FixCode:             f.FixCode(),
		FixRegex:            toFixRegexResponse(f.FixRegex()),
		Remediation:         toFindingRemediationResponse(f.Remediation()),
		Severity:            f.Severity().String(),
		CVSSScore:           f.CVSSScore(),
		CVSSVector:          f.CVSSVector(),
		CVEID:               f.CVEID(),
		CWEIDs:              f.CWEIDs(),
		OWASPIDs:            f.OWASPIDs(),
		Tags:                f.Tags(),
		Status:              f.Status().String(),
		Resolution:          f.Resolution(),
		ResolvedAt:          f.ResolvedAt(),
		ResolvedBy:          idToStringPtr(f.ResolvedBy()),
		IsTriaged:           f.IsTriaged(),
		SLAStatus:           f.SLAStatus().String(),
		FirstDetectedAt:     f.FirstDetectedAt(),
		LastSeenAt:          f.LastSeenAt(),
		FirstDetectedBranch: f.FirstDetectedBranch(),
		FirstDetectedCommit: f.FirstDetectedCommit(),
		LastSeenBranch:      f.LastSeenBranch(),
		LastSeenCommit:      f.LastSeenCommit(),
		DuplicateCount:      f.DuplicateCount(),
		CommentsCount:       f.CommentsCount(),
		ScanID:              f.ScanID(),
		Fingerprint:         f.Fingerprint(),
		Location:            f.Location(),
		Metadata:            f.Metadata(),
		CreatedAt:           f.CreatedAt(),
		UpdatedAt:           f.UpdatedAt(),
	}

	if vid := f.VulnerabilityID(); vid != nil {
		s := vid.String()
		resp.VulnerabilityID = &s
	}

	if bid := f.BranchID(); bid != nil {
		s := bid.String()
		resp.BranchID = &s
	}

	if cid := f.ComponentID(); cid != nil {
		s := cid.String()
		resp.ComponentID = &s
		// Note: Component field can be enriched by handler when needed using:
		// comp, _ := componentRepo.Get(ctx, *cid)
		// resp.Component = toFindingComponentInfo(comp)
	}

	if aid := f.AssignedTo(); aid != nil {
		s := aid.String()
		resp.AssignedTo = &s
	}
	resp.AssignedAt = f.AssignedAt()
	if aby := f.AssignedBy(); aby != nil {
		s := aby.String()
		resp.AssignedBy = &s
	}

	if vid := f.VerifiedBy(); vid != nil {
		s := vid.String()
		resp.VerifiedBy = &s
	}
	resp.VerifiedAt = f.VerifiedAt()

	resp.SLADeadline = f.SLADeadline()

	if dup := f.DuplicateOf(); dup != nil {
		s := dup.String()
		resp.DuplicateOf = &s
	}

	// SARIF 2.1.0 Fields
	resp.Confidence = f.Confidence()
	resp.Impact = f.Impact()
	resp.Likelihood = f.Likelihood()
	resp.VulnerabilityClass = f.VulnerabilityClass()
	resp.Subcategory = f.Subcategory()
	resp.BaselineState = f.BaselineState()
	resp.Kind = f.Kind()
	resp.Rank = f.Rank()
	resp.OccurrenceCount = f.OccurrenceCount()
	resp.CorrelationID = f.CorrelationID()
	resp.PartialFingerprints = f.PartialFingerprints()
	resp.RelatedLocations = f.RelatedLocations()
	resp.Stacks = f.Stacks()
	resp.Attachments = f.Attachments()
	resp.WorkItemURIs = f.WorkItemURIs()
	resp.HostedViewerURI = f.HostedViewerURI()

	// CTEM Fields
	resp.ExposureVector = f.ExposureVector().String()
	resp.IsNetworkAccessible = f.IsNetworkAccessible()
	resp.IsInternetAccessible = f.IsInternetAccessible()
	resp.AttackPrerequisites = f.AttackPrerequisites()
	resp.RemediationType = f.RemediationType().String()
	resp.EstimatedFixTime = f.EstimatedFixTime()
	resp.FixComplexity = f.FixComplexity().String()
	resp.RemedyAvailable = f.RemedyAvailable()
	resp.DataExposureRisk = f.DataExposureRisk().String()
	resp.ReputationalImpact = f.ReputationalImpact()
	resp.ComplianceImpact = f.ComplianceImpact()

	// Finding Type discriminator
	if ft := f.FindingType(); ft != "" {
		resp.FindingType = string(ft)
	}

	// Data Flow / Taint Tracking
	resp.HasDataFlow = f.HasDataFlow() // Lightweight flag for list views
	if dataFlows := f.DataFlows(); len(dataFlows) > 0 {
		resp.DataFlow = convertDataFlowsToResponse(dataFlows)
	}

	// Secret-specific fields
	if f.SecretType() != "" {
		resp.SecretType = f.SecretType()
		resp.SecretService = f.SecretService()
		if v := f.SecretValid(); v != nil {
			resp.SecretValid = v
		}
		if v := f.SecretRevoked(); v != nil {
			resp.SecretRevoked = v
		}
	}

	// Compliance-specific fields
	if f.ComplianceFramework() != "" {
		resp.ComplianceFramework = f.ComplianceFramework()
		resp.ComplianceControlID = f.ComplianceControlID()
		resp.ComplianceResult = f.ComplianceResult()
	}

	// Web3-specific fields
	if f.Web3Chain() != "" {
		resp.Web3Chain = f.Web3Chain()
		resp.Web3ContractAddress = f.Web3ContractAddress()
		resp.Web3SwcID = f.Web3SWCID()
	}

	// Misconfiguration-specific fields
	if f.MisconfigPolicyID() != "" {
		resp.MisconfigPolicyID = f.MisconfigPolicyID()
		resp.MisconfigResourceType = f.MisconfigResourceType()
		resp.MisconfigExpected = f.MisconfigExpected()
		resp.MisconfigActual = f.MisconfigActual()
	}

	return resp
}

// convertDataFlowsToResponse converts domain DataFlow slice to API response format.
// Provides both grouped view (for quick visualization) and ordered view (for detailed analysis).
func convertDataFlowsToResponse(dataFlows []vulnerability.DataFlow) *DataFlowResponse {
	if len(dataFlows) == 0 {
		return nil
	}

	resp := &DataFlowResponse{
		Traces: make([]DataFlowTraceResponse, 0, len(dataFlows)),
	}

	totalSteps := 0

	// Convert each data flow to a trace and collect grouped locations
	for _, df := range dataFlows {
		trace := DataFlowTraceResponse{
			Index:      df.Index,
			Message:    df.Message,
			Importance: df.Importance,
			Steps:      make([]DataFlowStepResponse, 0, len(df.Steps)),
		}

		for _, step := range df.Steps {
			// Build full location response
			loc := buildLocationResponse(step)

			// Add to trace steps (ordered view)
			stepResp := DataFlowStepResponse{
				Index:        step.Index,
				LocationType: step.LocationType,
				Location:     &loc,
				Label:        step.Label,
				Message:      step.Message,
				Importance:   step.Importance,
			}
			trace.Steps = append(trace.Steps, stepResp)

			// Add to grouped view by location type
			switch step.LocationType {
			case "source":
				resp.Sources = append(resp.Sources, loc)
			case "sink":
				resp.Sinks = append(resp.Sinks, loc)
			case "sanitizer":
				resp.Sanitizers = append(resp.Sanitizers, loc)
			default: // intermediate
				resp.Intermediates = append(resp.Intermediates, loc)
			}

			totalSteps++
		}

		resp.Traces = append(resp.Traces, trace)
	}

	resp.TotalSteps = totalSteps

	// Return nil if no locations found
	if totalSteps == 0 {
		return nil
	}

	return resp
}

// buildLocationResponse builds a full DataFlowLocationResponse from a DataFlowStep.
func buildLocationResponse(step vulnerability.DataFlowStep) DataFlowLocationResponse {
	loc := DataFlowLocationResponse{
		Index:              step.Index,
		LocationType:       step.LocationType,
		Label:              step.Label,
		Message:            step.Message,
		NestingLevel:       step.NestingLevel,
		Importance:         step.Importance,
		FunctionName:       step.FunctionName,
		ClassName:          step.ClassName,
		FullyQualifiedName: step.FullyQualifiedName,
		ModuleName:         step.ModuleName,
	}

	// Extract physical location if available
	if step.Location != nil {
		loc.Path = step.Location.Path
		loc.Line = step.Location.StartLine
		loc.EndLine = step.Location.EndLine
		loc.Column = step.Location.StartColumn
		loc.EndColumn = step.Location.EndColumn
		loc.Snippet = step.Location.Snippet
		if loc.Message == "" && step.Location.Message != "" {
			loc.Message = step.Location.Message
		}
	}

	return loc
}

// enrichFindingWithUserInfo populates the AssignedToUser field by looking up user info.
func (h *VulnerabilityHandler) enrichFindingWithUserInfo(ctx context.Context, resp *FindingResponse) {
	if h.userService == nil || resp.AssignedTo == nil {
		return
	}

	u, err := h.userService.GetProfile(ctx, *resp.AssignedTo)
	if err != nil {
		// Log but don't fail - user info is optional enhancement
		h.logger.Debug("failed to fetch assigned user info", "user_id", *resp.AssignedTo, "error", err)
		return
	}

	resp.AssignedToUser = &FindingAssignedUser{
		ID:    u.ID().String(),
		Name:  u.Name(),
		Email: u.Email(),
	}
}

// enrichFindingWithAssetInfo populates the Asset field by looking up asset info.
func (h *VulnerabilityHandler) enrichFindingWithAssetInfo(ctx context.Context, tenantID string, resp *FindingResponse) {
	if h.assetService == nil || resp.AssetID == "" {
		return
	}

	a, repo, err := h.assetService.GetAssetWithRepository(ctx, tenantID, resp.AssetID)
	if err != nil {
		// Log but don't fail - asset info is optional enhancement
		h.logger.Debug("failed to fetch asset info", "asset_id", resp.AssetID, "error", err)
		return
	}

	assetInfo := &FindingAssetInfo{
		ID:   a.ID().String(),
		Name: a.Name(),
		Type: a.Type().String(),
	}

	// Add repository web URL if available
	if repo != nil {
		assetInfo.WebURL = repo.WebURL()
	}

	resp.Asset = assetInfo
}

// ============================================
// ERROR HANDLERS
// ============================================

func (h *VulnerabilityHandler) handleValidationError(w http.ResponseWriter, err error) {
	var validationErrors validator.ValidationErrors
	if errors.As(err, &validationErrors) {
		apiErrors := make([]apierror.ValidationError, len(validationErrors))
		for i, ve := range validationErrors {
			apiErrors[i] = apierror.ValidationError{
				Field:   ve.Field,
				Message: ve.Message,
			}
		}
		apierror.ValidationFailed("Validation failed", apiErrors).WriteJSON(w)
		return
	}
	apierror.BadRequest("Validation error").WriteJSON(w)
}

func (h *VulnerabilityHandler) handleServiceError(w http.ResponseWriter, err error, resourceName string) {
	switch {
	case errors.Is(err, shared.ErrNotFound):
		apierror.NotFound(resourceName).WriteJSON(w)
	case errors.Is(err, shared.ErrAlreadyExists):
		apierror.Conflict(resourceName + " already exists").WriteJSON(w)
	case errors.Is(err, shared.ErrValidation):
		apierror.BadRequest(err.Error()).WriteJSON(w)
	default:
		h.logger.Error("service error", "error", err)
		apierror.InternalError(err).WriteJSON(w)
	}
}

// ============================================
// VULNERABILITY HANDLERS
// ============================================

// ListVulnerabilities handles GET /api/v1/vulnerabilities
// @Summary      List vulnerabilities
// @Description  Retrieves a paginated list of CVE vulnerabilities
// @Tags         Vulnerabilities
// @Produce      json
// @Param        cve_ids           query     string  false  "Filter by CVE IDs (comma-separated)"
// @Param        severities        query     string  false  "Filter by severities (comma-separated)"
// @Param        min_cvss          query     number  false  "Minimum CVSS score"
// @Param        max_cvss          query     number  false  "Maximum CVSS score"
// @Param        min_epss          query     number  false  "Minimum EPSS score"
// @Param        exploit_available query     bool    false  "Filter by exploit availability"
// @Param        cisa_kev_only     query     bool    false  "Only CISA KEV vulnerabilities"
// @Param        statuses          query     string  false  "Filter by statuses"
// @Param        page              query     int     false  "Page number"  default(1)
// @Param        per_page          query     int     false  "Items per page"  default(20)
// @Success      200  {object}  map[string]interface{}
// @Failure      400  {object}  map[string]string
// @Router       /vulnerabilities [get]
func (h *VulnerabilityHandler) ListVulnerabilities(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()

	exploitAvailable := parseQueryBool(query.Get("exploit_available"))
	cisaKEVOnly := parseQueryBool(query.Get("cisa_kev_only"))

	input := app.ListVulnerabilitiesInput{
		CVEIDs:           parseQueryArray(query.Get("cve_ids")),
		Severities:       parseQueryArray(query.Get("severities")),
		ExploitAvailable: exploitAvailable,
		CISAKEVOnly:      cisaKEVOnly,
		Statuses:         parseQueryArray(query.Get("statuses")),
		Page:             parseQueryInt(query.Get("page"), 1),
		PerPage:          parseQueryInt(query.Get("per_page"), 20),
	}

	// Parse float filters
	if minCVSS := query.Get("min_cvss"); minCVSS != "" {
		if val := parseQueryFloat(minCVSS); val != nil {
			input.MinCVSS = val
		}
	}
	if maxCVSS := query.Get("max_cvss"); maxCVSS != "" {
		if val := parseQueryFloat(maxCVSS); val != nil {
			input.MaxCVSS = val
		}
	}
	if minEPSS := query.Get("min_epss"); minEPSS != "" {
		if val := parseQueryFloat(minEPSS); val != nil {
			input.MinEPSS = val
		}
	}

	if err := h.validator.Validate(input); err != nil {
		h.handleValidationError(w, err)
		return
	}

	result, err := h.service.ListVulnerabilities(r.Context(), input)
	if err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	data := make([]VulnerabilityResponse, len(result.Data))
	for i, v := range result.Data {
		data[i] = toVulnerabilityResponse(v)
	}

	response := ListResponse[VulnerabilityResponse]{
		Data:       data,
		Total:      result.Total,
		Page:       result.Page,
		PerPage:    result.PerPage,
		TotalPages: result.TotalPages,
		Links:      NewPaginationLinks(r, result.Page, result.PerPage, result.TotalPages),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// CreateVulnerability handles POST /api/v1/vulnerabilities
// @Summary      Create vulnerability
// @Description  Creates a new CVE vulnerability record
// @Tags         Vulnerabilities
// @Accept       json
// @Produce      json
// @Param        request  body      CreateVulnerabilityRequest  true  "Vulnerability data"
// @Success      201  {object}  VulnerabilityResponse
// @Failure      400  {object}  map[string]string
// @Failure      409  {object}  map[string]string
// @Router       /vulnerabilities [post]
func (h *VulnerabilityHandler) CreateVulnerability(w http.ResponseWriter, r *http.Request) {
	var req CreateVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.CreateVulnerabilityInput{
		CVEID:            req.CVEID,
		Title:            req.Title,
		Description:      req.Description,
		Severity:         req.Severity,
		CVSSScore:        req.CVSSScore,
		CVSSVector:       req.CVSSVector,
		EPSSScore:        req.EPSSScore,
		EPSSPercentile:   req.EPSSPercentile,
		ExploitAvailable: req.ExploitAvailable,
		ExploitMaturity:  req.ExploitMaturity,
		FixedVersions:    req.FixedVersions,
		Remediation:      req.Remediation,
	}

	v, err := h.service.CreateVulnerability(r.Context(), input)
	if err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	_ = json.NewEncoder(w).Encode(toVulnerabilityResponse(v))
}

// GetVulnerability handles GET /api/v1/vulnerabilities/{id}
// @Summary      Get vulnerability
// @Description  Retrieves a vulnerability by ID
// @Tags         Vulnerabilities
// @Produce      json
// @Param        id   path      string  true  "Vulnerability ID"
// @Success      200  {object}  VulnerabilityResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /vulnerabilities/{id} [get]
func (h *VulnerabilityHandler) GetVulnerability(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Vulnerability ID is required").WriteJSON(w)
		return
	}

	v, err := h.service.GetVulnerability(r.Context(), id)
	if err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toVulnerabilityResponse(v))
}

// GetVulnerabilityByCVE handles GET /api/v1/vulnerabilities/cve/{cve_id}
// @Summary      Get vulnerability by CVE ID
// @Description  Retrieves a vulnerability by CVE ID
// @Tags         Vulnerabilities
// @Produce      json
// @Param        cve_id   path      string  true  "CVE ID"
// @Success      200  {object}  VulnerabilityResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /vulnerabilities/cve/{cve_id} [get]
func (h *VulnerabilityHandler) GetVulnerabilityByCVE(w http.ResponseWriter, r *http.Request) {
	cveID := r.PathValue("cve_id")
	if cveID == "" {
		apierror.BadRequest("CVE ID is required").WriteJSON(w)
		return
	}

	v, err := h.service.GetVulnerabilityByCVE(r.Context(), cveID)
	if err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toVulnerabilityResponse(v))
}

// UpdateVulnerability handles PUT /api/v1/vulnerabilities/{id}
// @Summary      Update vulnerability
// @Description  Updates a vulnerability
// @Tags         Vulnerabilities
// @Accept       json
// @Produce      json
// @Param        id       path      string                       true  "Vulnerability ID"
// @Param        request  body      UpdateVulnerabilityRequest   true  "Vulnerability data"
// @Success      200  {object}  VulnerabilityResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /vulnerabilities/{id} [put]
func (h *VulnerabilityHandler) UpdateVulnerability(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Vulnerability ID is required").WriteJSON(w)
		return
	}

	var req UpdateVulnerabilityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.UpdateVulnerabilityInput{
		Title:            req.Title,
		Description:      req.Description,
		Severity:         req.Severity,
		CVSSScore:        req.CVSSScore,
		CVSSVector:       req.CVSSVector,
		EPSSScore:        req.EPSSScore,
		EPSSPercentile:   req.EPSSPercentile,
		ExploitAvailable: req.ExploitAvailable,
		ExploitMaturity:  req.ExploitMaturity,
		FixedVersions:    req.FixedVersions,
		Remediation:      req.Remediation,
		Status:           req.Status,
	}

	v, err := h.service.UpdateVulnerability(r.Context(), id, input)
	if err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toVulnerabilityResponse(v))
}

// DeleteVulnerability handles DELETE /api/v1/vulnerabilities/{id}
// @Summary      Delete vulnerability
// @Description  Deletes a vulnerability
// @Tags         Vulnerabilities
// @Param        id   path      string  true  "Vulnerability ID"
// @Success      204  "No Content"
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /vulnerabilities/{id} [delete]
func (h *VulnerabilityHandler) DeleteVulnerability(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Vulnerability ID is required").WriteJSON(w)
		return
	}

	if err := h.service.DeleteVulnerability(r.Context(), id); err != nil {
		h.handleServiceError(w, err, "Vulnerability")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// ============================================
// FINDING HANDLERS
// ============================================

// ListFindings handles GET /api/v1/findings
// @Summary      List findings
// @Description  Retrieves a paginated list of findings for the current tenant
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Param        asset_id           query     string  false  "Filter by asset ID"
// @Param        branch_id          query     string  false  "Filter by branch ID"
// @Param        component_id       query     string  false  "Filter by component ID"
// @Param        vulnerability_id   query     string  false  "Filter by vulnerability ID"
// @Param        severities         query     string  false  "Filter by severities (comma-separated)"
// @Param        statuses           query     string  false  "Filter by statuses (comma-separated)"
// @Param        sources            query     string  false  "Filter by sources"
// @Param        tool_name          query     string  false  "Filter by tool name"
// @Param        page               query     int     false  "Page number"  default(1)
// @Param        per_page           query     int     false  "Items per page"  default(20)
// @Success      200  {object}  map[string]interface{}
// @Failure      400  {object}  map[string]string
// @Failure      401  {object}  map[string]string
// @Router       /findings [get]
func (h *VulnerabilityHandler) ListFindings(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	query := r.URL.Query()

	input := app.ListFindingsInput{
		TenantID:        tenantID,
		AssetID:         query.Get("asset_id"),
		BranchID:        query.Get("branch_id"),
		ComponentID:     query.Get("component_id"),
		VulnerabilityID: query.Get("vulnerability_id"),
		Severities:      parseQueryArray(query.Get("severities")),
		Statuses:        parseQueryArray(query.Get("statuses")),
		Sources:         parseQueryArray(query.Get("sources")),
		ToolName:        query.Get("tool_name"),
		RuleID:          query.Get("rule_id"),
		ScanID:          query.Get("scan_id"),
		FilePath:        query.Get("file_path"),
		Page:            parseQueryInt(query.Get("page"), 1),
		PerPage:         parseQueryInt(query.Get("per_page"), 20),
	}

	if err := h.validator.Validate(input); err != nil {
		h.handleValidationError(w, err)
		return
	}

	result, err := h.service.ListFindings(r.Context(), input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	data := make([]FindingResponse, len(result.Data))
	for i, f := range result.Data {
		data[i] = toFindingResponse(f)
	}

	response := ListResponse[FindingResponse]{
		Data:       data,
		Total:      result.Total,
		Page:       result.Page,
		PerPage:    result.PerPage,
		TotalPages: result.TotalPages,
		Links:      NewPaginationLinks(r, result.Page, result.PerPage, result.TotalPages),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// FindingStatsResponse represents finding statistics in API responses.
type FindingStatsResponse struct {
	Total         int64            `json:"total"`
	BySeverity    map[string]int64 `json:"by_severity"`
	ByStatus      map[string]int64 `json:"by_status"`
	BySource      map[string]int64 `json:"by_source"`
	OpenCount     int64            `json:"open_count"`
	ResolvedCount int64            `json:"resolved_count"`
}

// GetFindingStats handles GET /api/v1/findings/stats
// @Summary      Get finding statistics
// @Description  Returns aggregated statistics for findings
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Success      200  {object}  FindingStatsResponse
// @Failure      401  {object}  map[string]string
// @Failure      500  {object}  map[string]string
// @Router       /findings/stats [get]
func (h *VulnerabilityHandler) GetFindingStats(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	stats, err := h.service.GetFindingStats(r.Context(), tenantID)
	if err != nil {
		h.logger.Error("failed to get finding stats", "error", err)
		apierror.InternalError(err).WriteJSON(w)
		return
	}

	// Convert domain types to string keys for JSON response
	bySeverity := make(map[string]int64)
	for sev, count := range stats.BySeverity {
		bySeverity[sev.String()] = count
	}

	byStatus := make(map[string]int64)
	for st, count := range stats.ByStatus {
		byStatus[st.String()] = count
	}

	bySource := make(map[string]int64)
	for src, count := range stats.BySource {
		bySource[src.String()] = count
	}

	response := FindingStatsResponse{
		Total:         stats.Total,
		BySeverity:    bySeverity,
		ByStatus:      byStatus,
		BySource:      bySource,
		OpenCount:     stats.OpenCount,
		ResolvedCount: stats.ResolvedCount,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// CreateFinding handles POST /api/v1/findings
// @Summary      Create finding
// @Description  Creates a new finding for the current tenant
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      CreateFindingRequest  true  "Finding data"
// @Success      201  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      401  {object}  map[string]string
// @Router       /findings [post]
func (h *VulnerabilityHandler) CreateFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	var req CreateFindingRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.CreateFindingInput{
		TenantID:        tenantID,
		AssetID:         req.AssetID,
		BranchID:        req.BranchID,
		VulnerabilityID: req.VulnerabilityID,
		ComponentID:     req.ComponentID,
		Source:          req.Source,
		ToolName:        req.ToolName,
		ToolVersion:     req.ToolVersion,
		RuleID:          req.RuleID,
		FilePath:        req.FilePath,
		StartLine:       req.StartLine,
		EndLine:         req.EndLine,
		StartColumn:     req.StartColumn,
		EndColumn:       req.EndColumn,
		Snippet:         req.Snippet,
		Message:         req.Message,
		Severity:        req.Severity,
		ScanID:          req.ScanID,
	}

	f, err := h.service.CreateFinding(r.Context(), input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// GetFinding handles GET /api/v1/findings/{id}
// @Summary      Get finding
// @Description  Retrieves a finding by ID
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Param        id   path      string  true  "Finding ID"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id} [get]
func (h *VulnerabilityHandler) GetFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	// Security: Pass tenantID to service for tenant-scoped query (IDOR prevention)
	f, err := h.service.GetFinding(r.Context(), tenantID, id)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	resp := toFindingResponse(f)
	h.enrichFindingWithUserInfo(r.Context(), &resp)
	h.enrichFindingWithAssetInfo(r.Context(), tenantID, &resp)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(resp)
}

// UpdateFindingStatus handles PATCH /api/v1/findings/{id}/status
// @Summary      Update finding status
// @Description  Updates the status of a finding
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string                     true  "Finding ID"
// @Param        request  body      UpdateFindingStatusRequest true  "Status data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/status [patch]
func (h *VulnerabilityHandler) UpdateFindingStatus(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	actorID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req UpdateFindingStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.UpdateFindingStatusInput{
		Status:     req.Status,
		Resolution: req.Resolution,
		ActorID:    actorID, // resolved_by is set from authenticated user
	}

	f, err := h.service.UpdateFindingStatus(r.Context(), id, tenantID, input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// DeleteFinding handles DELETE /api/v1/findings/{id}
// @Summary      Delete finding
// @Description  Deletes a finding
// @Tags         Findings
// @Security     BearerAuth
// @Param        id   path      string  true  "Finding ID"
// @Success      204  "No Content"
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id} [delete]
func (h *VulnerabilityHandler) DeleteFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	if err := h.service.DeleteFinding(r.Context(), id, tenantID); err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// ListAssetFindings handles GET /api/v1/assets/{id}/findings
// @Summary      List asset findings
// @Description  Retrieves all findings for an asset
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Param        id        path      string  true   "Asset ID"
// @Param        sort      query     string  false  "Sort field"
// @Param        page      query     int     false  "Page number"  default(1)
// @Param        per_page  query     int     false  "Items per page"  default(20)
// @Success      200  {object}  map[string]interface{}
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /assets/{id}/findings [get]
func (h *VulnerabilityHandler) ListAssetFindings(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	assetID := r.PathValue("id")
	if assetID == "" {
		apierror.BadRequest("Asset ID is required").WriteJSON(w)
		return
	}

	query := r.URL.Query()
	sort := query.Get("sort")
	page := parseQueryInt(query.Get("page"), 1)
	perPage := parseQueryInt(query.Get("per_page"), 20)

	// Security: Pass tenantID for tenant-scoped query
	result, err := h.service.ListAssetFindings(r.Context(), tenantID, assetID, sort, page, perPage)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	data := make([]FindingResponse, len(result.Data))
	for i, f := range result.Data {
		data[i] = toFindingResponse(f)
	}

	response := ListResponse[FindingResponse]{
		Data:       data,
		Total:      result.Total,
		Page:       result.Page,
		PerPage:    result.PerPage,
		TotalPages: result.TotalPages,
		Links:      NewPaginationLinks(r, result.Page, result.PerPage, result.TotalPages),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// ============================================
// FINDING MANAGEMENT HANDLERS
// ============================================

// AssignFinding handles POST /api/v1/findings/{id}/assign
// @Summary      Assign finding
// @Description  Assigns a finding to a user
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string               true  "Finding ID"
// @Param        request  body      AssignFindingRequest true  "Assignment data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/assign [post]
func (h *VulnerabilityHandler) AssignFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	actorID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req AssignFindingRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	f, err := h.service.AssignFinding(r.Context(), id, tenantID, req.UserID, actorID)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// UnassignFinding handles POST /api/v1/findings/{id}/unassign
// @Summary      Unassign finding
// @Description  Removes assignment from a finding
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Param        id   path      string  true  "Finding ID"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/unassign [post]
func (h *VulnerabilityHandler) UnassignFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	actorID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	f, err := h.service.UnassignFinding(r.Context(), id, tenantID, actorID)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// ClassifyFinding handles PATCH /api/v1/findings/{id}/classify
// @Summary      Classify finding
// @Description  Sets CVE, CWE, and CVSS classification for a finding
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string                  true  "Finding ID"
// @Param        request  body      ClassifyFindingRequest  true  "Classification data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/classify [patch]
func (h *VulnerabilityHandler) ClassifyFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req ClassifyFindingRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.ClassifyFindingInput{
		CVEID:      req.CVEID,
		CVSSScore:  req.CVSSScore,
		CVSSVector: req.CVSSVector,
		CWEIDs:     req.CWEIDs,
		OWASPIDs:   req.OWASPIDs,
	}

	f, err := h.service.ClassifyFinding(r.Context(), id, tenantID, input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// UpdateFindingSeverity handles PATCH /api/v1/findings/{id}/severity
// @Summary      Update finding severity
// @Description  Updates the severity level of a finding
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string                 true  "Finding ID"
// @Param        request  body      UpdateSeverityRequest  true  "Severity data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/severity [patch]
func (h *VulnerabilityHandler) UpdateFindingSeverity(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	actorID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req UpdateSeverityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	f, err := h.service.UpdateFindingSeverity(r.Context(), id, tenantID, req.Severity, actorID)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// TriageFinding handles PATCH /api/v1/findings/{id}/triage
// @Summary      Triage finding
// @Description  Sets the triage status of a finding
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string               true  "Finding ID"
// @Param        request  body      TriageFindingRequest true  "Triage data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/triage [patch]
func (h *VulnerabilityHandler) TriageFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	userID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req TriageFindingRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	f, err := h.service.TriageFinding(r.Context(), id, tenantID, userID, req.Reason)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// VerifyFinding handles POST /api/v1/findings/{id}/verify
// @Summary      Verify finding fix
// @Description  Marks a resolved finding as verified
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id   path      string  true  "Finding ID"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/verify [post]
func (h *VulnerabilityHandler) VerifyFinding(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	userID := middleware.GetUserID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	f, err := h.service.VerifyFinding(r.Context(), id, tenantID, userID)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// SetFindingTags handles PUT /api/v1/findings/{id}/tags
// @Summary      Set finding tags
// @Description  Sets the tags for a finding
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        id       path      string          true  "Finding ID"
// @Param        request  body      SetTagsRequest  true  "Tags data"
// @Success      200  {object}  FindingResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/tags [put]
func (h *VulnerabilityHandler) SetFindingTags(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req SetTagsRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	f, err := h.service.SetFindingTags(r.Context(), id, tenantID, req.Tags)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingResponse(f))
}

// BulkUpdateFindingsStatus handles POST /api/v1/findings/bulk/status
// @Summary      Bulk update finding status
// @Description  Updates the status of multiple findings
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      BulkUpdateStatusRequest  true  "Bulk update data"
// @Success      200  {object}  BulkUpdateResponse
// @Failure      400  {object}  map[string]string
// @Router       /findings/bulk/status [post]
func (h *VulnerabilityHandler) BulkUpdateFindingsStatus(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	var req BulkUpdateStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.BulkUpdateStatusInput{
		FindingIDs: req.FindingIDs,
		Status:     req.Status,
		Resolution: req.Resolution,
	}

	result, err := h.service.BulkUpdateFindingsStatus(r.Context(), tenantID, input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	response := BulkUpdateResponse{
		Updated: result.Updated,
		Failed:  result.Failed,
		Errors:  result.Errors,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// BulkAssignFindings handles POST /api/v1/findings/bulk/assign
// @Summary      Bulk assign findings
// @Description  Assigns multiple findings to a user
// @Tags         Findings
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      BulkAssignRequest  true  "Bulk assign data"
// @Success      200  {object}  BulkUpdateResponse
// @Failure      400  {object}  map[string]string
// @Router       /findings/bulk/assign [post]
func (h *VulnerabilityHandler) BulkAssignFindings(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	actorID := middleware.GetUserID(r.Context())

	var req BulkAssignRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	input := app.BulkAssignInput{
		FindingIDs: req.FindingIDs,
		UserID:     req.UserID,
		AssignerID: actorID,
	}

	result, err := h.service.BulkAssignFindings(r.Context(), tenantID, input)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	response := BulkUpdateResponse{
		Updated: result.Updated,
		Failed:  result.Failed,
		Errors:  result.Errors,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// ============================================
// HELPERS
// ============================================

// parseQueryFloat parses a float query parameter.
func parseQueryFloat(s string) *float64 {
	if s == "" {
		return nil
	}
	var f float64
	if err := json.Unmarshal([]byte(s), &f); err == nil {
		return &f
	}
	return nil
}

// ============================================
// FINDING COMMENT TYPES
// ============================================

// FindingCommentResponse represents a finding comment in API responses.
type FindingCommentResponse struct {
	ID             string    `json:"id"`
	FindingID      string    `json:"finding_id"`
	AuthorID       string    `json:"author_id"`
	AuthorName     string    `json:"author_name,omitempty"`
	AuthorEmail    string    `json:"author_email,omitempty"`
	Content        string    `json:"content"`
	IsStatusChange bool      `json:"is_status_change"`
	OldStatus      string    `json:"old_status,omitempty"`
	NewStatus      string    `json:"new_status,omitempty"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
}

// AddCommentRequest represents the request to add a comment.
type AddCommentRequest struct {
	Content string `json:"content" validate:"required,min=1,max=10000"`
}

// UpdateCommentRequest represents the request to update a comment.
type UpdateCommentRequest struct {
	Content string `json:"content" validate:"required,min=1,max=10000"`
}

// toFindingCommentResponse converts a domain comment to API response.
func toFindingCommentResponse(c *vulnerability.FindingComment) FindingCommentResponse {
	resp := FindingCommentResponse{
		ID:             c.ID().String(),
		FindingID:      c.FindingID().String(),
		AuthorID:       c.AuthorID().String(),
		AuthorName:     c.AuthorName(),
		AuthorEmail:    c.AuthorEmail(),
		Content:        c.Content(),
		IsStatusChange: c.IsStatusChange(),
		CreatedAt:      c.CreatedAt(),
		UpdatedAt:      c.UpdatedAt(),
	}
	if c.IsStatusChange() {
		resp.OldStatus = c.OldStatus().String()
		resp.NewStatus = c.NewStatus().String()
	}
	return resp
}

// ============================================
// FINDING COMMENT HANDLERS
// ============================================

// ListComments handles GET /api/v1/findings/{id}/comments
func (h *VulnerabilityHandler) ListComments(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	findingID := r.PathValue("id")
	if findingID == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	// Security: Verify finding exists and belongs to tenant (IDOR prevention via tenant-scoped query)
	_, err := h.service.GetFinding(r.Context(), tenantID, findingID)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	comments, err := h.service.ListFindingComments(r.Context(), findingID)
	if err != nil {
		h.handleServiceError(w, err, "Comment")
		return
	}

	data := make([]FindingCommentResponse, len(comments))
	for i, c := range comments {
		data[i] = toFindingCommentResponse(c)
	}

	response := struct {
		Data  []FindingCommentResponse `json:"data"`
		Total int                      `json:"total"`
	}{
		Data:  data,
		Total: len(data),
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(response)
}

// AddComment handles POST /api/v1/findings/{id}/comments
func (h *VulnerabilityHandler) AddComment(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	// Use local user ID for activity recording (works with users table JOIN)
	localUserID := middleware.GetLocalUserID(r.Context())
	var userID string
	if !localUserID.IsZero() {
		userID = localUserID.String()
	}

	findingID := r.PathValue("id")
	if findingID == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	var req AddCommentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	// Security: Pass tenantID for tenant-scoped verification
	comment, err := h.service.AddFindingComment(r.Context(), tenantID, findingID, userID, req.Content)
	if err != nil {
		h.handleServiceError(w, err, "Comment")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	_ = json.NewEncoder(w).Encode(toFindingCommentResponse(comment))
}

// UpdateComment handles PUT /api/v1/findings/{findingId}/comments/{commentId}
func (h *VulnerabilityHandler) UpdateComment(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	// Use local user ID for activity recording (works with users table JOIN)
	localUserID := middleware.GetLocalUserID(r.Context())
	var userID string
	if !localUserID.IsZero() {
		userID = localUserID.String()
	}

	findingID := r.PathValue("findingId")
	commentID := r.PathValue("commentId")
	if findingID == "" || commentID == "" {
		apierror.BadRequest("Finding ID and Comment ID are required").WriteJSON(w)
		return
	}

	var req UpdateCommentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		apierror.BadRequest("Invalid request body").WriteJSON(w)
		return
	}

	if err := h.validator.Validate(req); err != nil {
		h.handleValidationError(w, err)
		return
	}

	// Security: Pass tenantID for tenant-scoped verification
	comment, err := h.service.UpdateFindingComment(r.Context(), tenantID, commentID, userID, req.Content)
	if err != nil {
		h.handleServiceError(w, err, "Comment")
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(toFindingCommentResponse(comment))
}

// DeleteComment handles DELETE /api/v1/findings/{findingId}/comments/{commentId}
func (h *VulnerabilityHandler) DeleteComment(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())
	// Use local user ID for activity recording (works with users table JOIN)
	localUserID := middleware.GetLocalUserID(r.Context())
	var userID string
	if !localUserID.IsZero() {
		userID = localUserID.String()
	}

	commentID := r.PathValue("commentId")
	if commentID == "" {
		apierror.BadRequest("Comment ID is required").WriteJSON(w)
		return
	}

	// Security: Pass tenantID for tenant-scoped verification
	if err := h.service.DeleteFindingComment(r.Context(), tenantID, commentID, userID); err != nil {
		h.handleServiceError(w, err, "Comment")
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// ============================================
// DATA FLOW ENDPOINTS
// ============================================

// GetFindingDataFlows handles GET /api/v1/findings/{id}/dataflows
// @Summary      Get finding data flows
// @Description  Returns the data flow traces (attack paths) for a finding
// @Tags         Findings
// @Produce      json
// @Security     BearerAuth
// @Param        id  path      string  true  "Finding ID"
// @Success      200  {object}  DataFlowResponse
// @Failure      400  {object}  map[string]string
// @Failure      404  {object}  map[string]string
// @Router       /findings/{id}/dataflows [get]
func (h *VulnerabilityHandler) GetFindingDataFlows(w http.ResponseWriter, r *http.Request) {
	tenantID := middleware.MustGetTenantID(r.Context())

	id := r.PathValue("id")
	if id == "" {
		apierror.BadRequest("Finding ID is required").WriteJSON(w)
		return
	}

	// Security: Pass tenantID for tenant-scoped query (IDOR prevention)
	f, err := h.service.GetFinding(r.Context(), tenantID, id)
	if err != nil {
		h.handleServiceError(w, err, "Finding")
		return
	}

	// Convert data flows to response
	dataFlows := f.DataFlows()
	if len(dataFlows) == 0 {
		// Return empty response if no data flows
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		_ = json.NewEncoder(w).Encode(map[string]any{
			"has_data_flow": false,
			"message":       "No data flow traces available for this finding",
		})
		return
	}

	resp := convertDataFlowsToResponse(dataFlows)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_ = json.NewEncoder(w).Encode(resp)
}
