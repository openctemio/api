package postgres

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/lib/pq"

	"github.com/openctemio/api/pkg/domain/shared"
	"github.com/openctemio/api/pkg/domain/vulnerability"
	"github.com/openctemio/api/pkg/pagination"
)

// VulnerabilityRepository implements vulnerability.VulnerabilityRepository using PostgreSQL.
type VulnerabilityRepository struct {
	db *DB
}

// NewVulnerabilityRepository creates a new VulnerabilityRepository.
func NewVulnerabilityRepository(db *DB) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

// Create persists a new vulnerability.
func (r *VulnerabilityRepository) Create(ctx context.Context, vuln *vulnerability.Vulnerability) error {
	refs, err := json.Marshal(r.referencesToJSON(vuln.References()))
	if err != nil {
		return fmt.Errorf("failed to marshal references: %w", err)
	}

	affectedVersions, err := json.Marshal(r.affectedVersionsToJSON(vuln.AffectedVersions()))
	if err != nil {
		return fmt.Errorf("failed to marshal affected versions: %w", err)
	}

	query := `
		INSERT INTO vulnerabilities (
			id, cve_id, aliases, title, description, severity, cvss_score, cvss_vector,
			epss_score, epss_percentile, cisa_kev_date_added, cisa_kev_due_date,
			cisa_kev_ransomware_use, cisa_kev_notes, exploit_available, exploit_maturity,
			reference_urls, affected_versions, fixed_versions, remediation,
			published_at, modified_at, status, created_at, updated_at
		)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)
	`

	cisaKEV := vuln.CISAKEV()
	var cisaDateAdded, cisaDueDate sql.NullTime
	var cisaRansomware, cisaNotes sql.NullString

	if cisaKEV != nil && !cisaKEV.IsZero() {
		cisaDateAdded = sql.NullTime{Time: cisaKEV.DateAdded(), Valid: true}
		cisaDueDate = sql.NullTime{Time: cisaKEV.DueDate(), Valid: true}
		cisaRansomware = nullString(cisaKEV.RansomwareUse())
		cisaNotes = nullString(cisaKEV.Notes())
	}

	_, err = r.db.ExecContext(ctx, query,
		vuln.ID().String(),
		vuln.CVEID(),
		pq.Array(vuln.Aliases()),
		vuln.Title(),
		nullString(vuln.Description()),
		vuln.Severity().String(),
		nullFloat64(vuln.CVSSScore()),
		nullString(vuln.CVSSVector()),
		nullFloat64(vuln.EPSSScore()),
		nullFloat64(vuln.EPSSPercentile()),
		cisaDateAdded,
		cisaDueDate,
		cisaRansomware,
		cisaNotes,
		vuln.ExploitAvailable(),
		vuln.ExploitMaturity().String(),
		refs,
		affectedVersions,
		pq.Array(vuln.FixedVersions()),
		nullString(vuln.Remediation()),
		nullTime(vuln.PublishedAt()),
		nullTime(vuln.ModifiedAt()),
		vuln.Status().String(),
		vuln.CreatedAt(),
		vuln.UpdatedAt(),
	)

	if err != nil {
		if isUniqueViolation(err) {
			return vulnerability.VulnerabilityAlreadyExistsError(vuln.CVEID())
		}
		return fmt.Errorf("failed to create vulnerability: %w", err)
	}

	return nil
}

// GetByID retrieves a vulnerability by ID.
func (r *VulnerabilityRepository) GetByID(ctx context.Context, id shared.ID) (*vulnerability.Vulnerability, error) {
	query := r.selectQuery() + " WHERE id = $1"
	row := r.db.QueryRowContext(ctx, query, id.String())
	return r.scanVulnerability(row, vulnerability.VulnerabilityNotFoundError(id))
}

// GetByCVE retrieves a vulnerability by CVE ID.
func (r *VulnerabilityRepository) GetByCVE(ctx context.Context, cveID string) (*vulnerability.Vulnerability, error) {
	query := r.selectQuery() + " WHERE cve_id = $1"
	row := r.db.QueryRowContext(ctx, query, cveID)
	return r.scanVulnerability(row, vulnerability.VulnerabilityNotFoundByCVEError(cveID))
}

// Update updates an existing vulnerability.
func (r *VulnerabilityRepository) Update(ctx context.Context, vuln *vulnerability.Vulnerability) error {
	refs, err := json.Marshal(r.referencesToJSON(vuln.References()))
	if err != nil {
		return fmt.Errorf("failed to marshal references: %w", err)
	}

	affectedVersions, err := json.Marshal(r.affectedVersionsToJSON(vuln.AffectedVersions()))
	if err != nil {
		return fmt.Errorf("failed to marshal affected versions: %w", err)
	}

	cisaKEV := vuln.CISAKEV()
	var cisaDateAdded, cisaDueDate sql.NullTime
	var cisaRansomware, cisaNotes sql.NullString

	if cisaKEV != nil && !cisaKEV.IsZero() {
		cisaDateAdded = sql.NullTime{Time: cisaKEV.DateAdded(), Valid: true}
		cisaDueDate = sql.NullTime{Time: cisaKEV.DueDate(), Valid: true}
		cisaRansomware = nullString(cisaKEV.RansomwareUse())
		cisaNotes = nullString(cisaKEV.Notes())
	}

	query := `
		UPDATE vulnerabilities SET
			aliases = $2, title = $3, description = $4, severity = $5, cvss_score = $6,
			cvss_vector = $7, epss_score = $8, epss_percentile = $9, cisa_kev_date_added = $10,
			cisa_kev_due_date = $11, cisa_kev_ransomware_use = $12, cisa_kev_notes = $13,
			exploit_available = $14, exploit_maturity = $15, reference_urls = $16,
			affected_versions = $17, fixed_versions = $18, remediation = $19,
			published_at = $20, modified_at = $21, status = $22, updated_at = $23
		WHERE id = $1
	`

	result, err := r.db.ExecContext(ctx, query,
		vuln.ID().String(),
		pq.Array(vuln.Aliases()),
		vuln.Title(),
		nullString(vuln.Description()),
		vuln.Severity().String(),
		nullFloat64(vuln.CVSSScore()),
		nullString(vuln.CVSSVector()),
		nullFloat64(vuln.EPSSScore()),
		nullFloat64(vuln.EPSSPercentile()),
		cisaDateAdded,
		cisaDueDate,
		cisaRansomware,
		cisaNotes,
		vuln.ExploitAvailable(),
		vuln.ExploitMaturity().String(),
		refs,
		affectedVersions,
		pq.Array(vuln.FixedVersions()),
		nullString(vuln.Remediation()),
		nullTime(vuln.PublishedAt()),
		nullTime(vuln.ModifiedAt()),
		vuln.Status().String(),
		vuln.UpdatedAt(),
	)

	if err != nil {
		return fmt.Errorf("failed to update vulnerability: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return vulnerability.VulnerabilityNotFoundError(vuln.ID())
	}

	return nil
}

// Delete removes a vulnerability by ID.
func (r *VulnerabilityRepository) Delete(ctx context.Context, id shared.ID) error {
	query := `DELETE FROM vulnerabilities WHERE id = $1`

	result, err := r.db.ExecContext(ctx, query, id.String())
	if err != nil {
		return fmt.Errorf("failed to delete vulnerability: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return vulnerability.VulnerabilityNotFoundError(id)
	}

	return nil
}

// List retrieves vulnerabilities matching the filter with pagination.
func (r *VulnerabilityRepository) List(ctx context.Context, filter vulnerability.VulnerabilityFilter, opts vulnerability.VulnerabilityListOptions, page pagination.Pagination) (pagination.Result[*vulnerability.Vulnerability], error) {
	baseQuery := r.selectQuery()
	countQuery := `SELECT COUNT(*) FROM vulnerabilities`

	whereClause, args := r.buildWhereClause(filter)

	if whereClause != "" {
		baseQuery += " WHERE " + whereClause
		countQuery += " WHERE " + whereClause
	}

	// Apply sorting (default to created_at DESC)
	orderBy := defaultSortOrder
	if opts.Sort != nil && !opts.Sort.IsEmpty() {
		orderBy = opts.Sort.SQLWithDefault(defaultSortOrder)
	}
	baseQuery += " ORDER BY " + orderBy
	baseQuery += fmt.Sprintf(" LIMIT %d OFFSET %d", page.Limit(), page.Offset())

	var total int64
	err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		return pagination.Result[*vulnerability.Vulnerability]{}, fmt.Errorf("failed to count vulnerabilities: %w", err)
	}

	rows, err := r.db.QueryContext(ctx, baseQuery, args...)
	if err != nil {
		return pagination.Result[*vulnerability.Vulnerability]{}, fmt.Errorf("failed to query vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulns []*vulnerability.Vulnerability
	for rows.Next() {
		vuln, err := r.scanVulnerabilityFromRows(rows)
		if err != nil {
			return pagination.Result[*vulnerability.Vulnerability]{}, err
		}
		vulns = append(vulns, vuln)
	}

	if err := rows.Err(); err != nil {
		return pagination.Result[*vulnerability.Vulnerability]{}, fmt.Errorf("failed to iterate vulnerabilities: %w", err)
	}

	return pagination.NewResult(vulns, total, page), nil
}

// Count returns the count of vulnerabilities matching the filter.
func (r *VulnerabilityRepository) Count(ctx context.Context, filter vulnerability.VulnerabilityFilter) (int64, error) {
	query := `SELECT COUNT(*) FROM vulnerabilities`

	whereClause, args := r.buildWhereClause(filter)
	if whereClause != "" {
		query += " WHERE " + whereClause
	}

	var count int64
	err := r.db.QueryRowContext(ctx, query, args...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to count vulnerabilities: %w", err)
	}

	return count, nil
}

// UpsertByCVE creates or updates a vulnerability by CVE ID.
func (r *VulnerabilityRepository) UpsertByCVE(ctx context.Context, vuln *vulnerability.Vulnerability) error {
	refs, err := json.Marshal(r.referencesToJSON(vuln.References()))
	if err != nil {
		return fmt.Errorf("failed to marshal references: %w", err)
	}

	affectedVersions, err := json.Marshal(r.affectedVersionsToJSON(vuln.AffectedVersions()))
	if err != nil {
		return fmt.Errorf("failed to marshal affected versions: %w", err)
	}

	cisaKEV := vuln.CISAKEV()
	var cisaDateAdded, cisaDueDate sql.NullTime
	var cisaRansomware, cisaNotes sql.NullString

	if cisaKEV != nil && !cisaKEV.IsZero() {
		cisaDateAdded = sql.NullTime{Time: cisaKEV.DateAdded(), Valid: true}
		cisaDueDate = sql.NullTime{Time: cisaKEV.DueDate(), Valid: true}
		cisaRansomware = nullString(cisaKEV.RansomwareUse())
		cisaNotes = nullString(cisaKEV.Notes())
	}

	query := `
		INSERT INTO vulnerabilities (
			id, cve_id, aliases, title, description, severity, cvss_score, cvss_vector,
			epss_score, epss_percentile, cisa_kev_date_added, cisa_kev_due_date,
			cisa_kev_ransomware_use, cisa_kev_notes, exploit_available, exploit_maturity,
			reference_urls, affected_versions, fixed_versions, remediation,
			published_at, modified_at, status, created_at, updated_at
		)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)
		ON CONFLICT (cve_id) DO UPDATE SET
			aliases = EXCLUDED.aliases,
			title = EXCLUDED.title,
			description = EXCLUDED.description,
			severity = EXCLUDED.severity,
			cvss_score = EXCLUDED.cvss_score,
			cvss_vector = EXCLUDED.cvss_vector,
			epss_score = EXCLUDED.epss_score,
			epss_percentile = EXCLUDED.epss_percentile,
			cisa_kev_date_added = EXCLUDED.cisa_kev_date_added,
			cisa_kev_due_date = EXCLUDED.cisa_kev_due_date,
			cisa_kev_ransomware_use = EXCLUDED.cisa_kev_ransomware_use,
			cisa_kev_notes = EXCLUDED.cisa_kev_notes,
			exploit_available = EXCLUDED.exploit_available,
			exploit_maturity = EXCLUDED.exploit_maturity,
			reference_urls = EXCLUDED.reference_urls,
			affected_versions = EXCLUDED.affected_versions,
			fixed_versions = EXCLUDED.fixed_versions,
			remediation = EXCLUDED.remediation,
			published_at = EXCLUDED.published_at,
			modified_at = EXCLUDED.modified_at,
			status = EXCLUDED.status,
			updated_at = EXCLUDED.updated_at
	`

	_, err = r.db.ExecContext(ctx, query,
		vuln.ID().String(),
		vuln.CVEID(),
		pq.Array(vuln.Aliases()),
		vuln.Title(),
		nullString(vuln.Description()),
		vuln.Severity().String(),
		nullFloat64(vuln.CVSSScore()),
		nullString(vuln.CVSSVector()),
		nullFloat64(vuln.EPSSScore()),
		nullFloat64(vuln.EPSSPercentile()),
		cisaDateAdded,
		cisaDueDate,
		cisaRansomware,
		cisaNotes,
		vuln.ExploitAvailable(),
		vuln.ExploitMaturity().String(),
		refs,
		affectedVersions,
		pq.Array(vuln.FixedVersions()),
		nullString(vuln.Remediation()),
		nullTime(vuln.PublishedAt()),
		nullTime(vuln.ModifiedAt()),
		vuln.Status().String(),
		vuln.CreatedAt(),
		vuln.UpdatedAt(),
	)

	if err != nil {
		return fmt.Errorf("failed to upsert vulnerability: %w", err)
	}

	return nil
}

// ExistsByCVE checks if a vulnerability with the given CVE ID exists.
func (r *VulnerabilityRepository) ExistsByCVE(ctx context.Context, cveID string) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM vulnerabilities WHERE cve_id = $1)`

	var exists bool
	err := r.db.QueryRowContext(ctx, query, cveID).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check vulnerability existence: %w", err)
	}

	return exists, nil
}

// Helper methods

func (r *VulnerabilityRepository) selectQuery() string {
	return `
		SELECT id, cve_id, aliases, title, description, severity, cvss_score, cvss_vector,
			epss_score, epss_percentile, cisa_kev_date_added, cisa_kev_due_date,
			cisa_kev_ransomware_use, cisa_kev_notes, exploit_available, exploit_maturity,
			reference_urls, affected_versions, fixed_versions, remediation,
			published_at, modified_at, status, created_at, updated_at
		FROM vulnerabilities
	`
}

func (r *VulnerabilityRepository) scanVulnerability(row *sql.Row, notFoundErr error) (*vulnerability.Vulnerability, error) {
	vuln, err := r.doScan(row.Scan)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, notFoundErr
		}
		return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
	}
	return vuln, nil
}

func (r *VulnerabilityRepository) scanVulnerabilityFromRows(rows *sql.Rows) (*vulnerability.Vulnerability, error) {
	return r.doScan(rows.Scan)
}

func (r *VulnerabilityRepository) doScan(scan func(dest ...any) error) (*vulnerability.Vulnerability, error) {
	var (
		idStr            string
		cveID            string
		aliases          pq.StringArray
		title            string
		description      sql.NullString
		severity         string
		cvssScore        sql.NullFloat64
		cvssVector       sql.NullString
		epssScore        sql.NullFloat64
		epssPercentile   sql.NullFloat64
		cisaDateAdded    sql.NullTime
		cisaDueDate      sql.NullTime
		cisaRansomware   sql.NullString
		cisaNotes        sql.NullString
		exploitAvailable bool
		exploitMaturity  string
		refsJSON         []byte
		affectedJSON     []byte
		fixedVersions    pq.StringArray
		remediation      sql.NullString
		publishedAt      sql.NullTime
		modifiedAt       sql.NullTime
		status           string
		createdAt        time.Time
		updatedAt        time.Time
	)

	err := scan(
		&idStr, &cveID, &aliases, &title, &description, &severity, &cvssScore, &cvssVector,
		&epssScore, &epssPercentile, &cisaDateAdded, &cisaDueDate,
		&cisaRansomware, &cisaNotes, &exploitAvailable, &exploitMaturity,
		&refsJSON, &affectedJSON, &fixedVersions, &remediation,
		&publishedAt, &modifiedAt, &status, &createdAt, &updatedAt,
	)
	if err != nil {
		return nil, err
	}

	return r.reconstruct(
		idStr, cveID, aliases, title, description, severity, cvssScore, cvssVector,
		epssScore, epssPercentile, cisaDateAdded, cisaDueDate,
		cisaRansomware, cisaNotes, exploitAvailable, exploitMaturity,
		refsJSON, affectedJSON, fixedVersions, remediation,
		publishedAt, modifiedAt, status, createdAt, updatedAt,
	)
}

func (r *VulnerabilityRepository) reconstruct(
	idStr, cveID string,
	aliases pq.StringArray,
	title string,
	description sql.NullString,
	severityStr string,
	cvssScore sql.NullFloat64,
	cvssVector sql.NullString,
	epssScore, epssPercentile sql.NullFloat64,
	cisaDateAdded, cisaDueDate sql.NullTime,
	cisaRansomware, cisaNotes sql.NullString,
	exploitAvailable bool,
	exploitMaturityStr string,
	refsJSON, affectedJSON []byte,
	fixedVersions pq.StringArray,
	remediation sql.NullString,
	publishedAt, modifiedAt sql.NullTime,
	statusStr string,
	createdAt, updatedAt time.Time,
) (*vulnerability.Vulnerability, error) {
	parsedID, err := shared.IDFromString(idStr)
	if err != nil {
		return nil, fmt.Errorf("failed to parse id: %w", err)
	}

	severity, _ := vulnerability.ParseSeverity(severityStr)
	exploitMat := vulnerability.ExploitMaturity(exploitMaturityStr)
	vulnStatus := vulnerability.VulnerabilityStatus(statusStr)

	var cvss *float64
	if cvssScore.Valid {
		cvss = &cvssScore.Float64
	}

	var epss *float64
	if epssScore.Valid {
		epss = &epssScore.Float64
	}

	var epssPct *float64
	if epssPercentile.Valid {
		epssPct = &epssPercentile.Float64
	}

	var cisaKEV *vulnerability.CISAKEV
	if cisaDateAdded.Valid {
		kev := vulnerability.NewCISAKEV(
			cisaDateAdded.Time,
			cisaDueDate.Time,
			nullStringValue(cisaRansomware),
			nullStringValue(cisaNotes),
		)
		cisaKEV = &kev
	}

	refs := r.parseReferencesJSON(refsJSON)
	affected := r.parseAffectedVersionsJSON(affectedJSON)

	var published *time.Time
	if publishedAt.Valid {
		published = &publishedAt.Time
	}

	var modified *time.Time
	if modifiedAt.Valid {
		modified = &modifiedAt.Time
	}

	return vulnerability.Reconstitute(
		parsedID,
		cveID,
		[]string(aliases),
		title,
		nullStringValue(description),
		severity,
		cvss,
		nullStringValue(cvssVector),
		epss,
		epssPct,
		cisaKEV,
		exploitAvailable,
		exploitMat,
		refs,
		affected,
		[]string(fixedVersions),
		nullStringValue(remediation),
		published,
		modified,
		vulnStatus,
		createdAt,
		updatedAt,
	), nil
}

func (r *VulnerabilityRepository) buildWhereClause(filter vulnerability.VulnerabilityFilter) (string, []any) {
	var conditions []string
	var args []any
	argIndex := 1

	if len(filter.CVEIDs) > 0 {
		placeholders := make([]string, len(filter.CVEIDs))
		for i, cve := range filter.CVEIDs {
			placeholders[i] = fmt.Sprintf("$%d", argIndex)
			args = append(args, cve)
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("cve_id IN (%s)", strings.Join(placeholders, ", ")))
	}

	if len(filter.Severities) > 0 {
		placeholders := make([]string, len(filter.Severities))
		for i, sev := range filter.Severities {
			placeholders[i] = fmt.Sprintf("$%d", argIndex)
			args = append(args, sev.String())
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("severity IN (%s)", strings.Join(placeholders, ", ")))
	}

	if filter.MinCVSS != nil {
		conditions = append(conditions, fmt.Sprintf("cvss_score >= $%d", argIndex))
		args = append(args, *filter.MinCVSS)
		argIndex++
	}

	if filter.MaxCVSS != nil {
		conditions = append(conditions, fmt.Sprintf("cvss_score <= $%d", argIndex))
		args = append(args, *filter.MaxCVSS)
		argIndex++
	}

	if filter.MinEPSS != nil {
		conditions = append(conditions, fmt.Sprintf("epss_score >= $%d", argIndex))
		args = append(args, *filter.MinEPSS)
		argIndex++
	}

	if filter.ExploitAvailable != nil {
		conditions = append(conditions, fmt.Sprintf("exploit_available = $%d", argIndex))
		args = append(args, *filter.ExploitAvailable)
		argIndex++
	}

	if filter.CISAKEVOnly != nil && *filter.CISAKEVOnly {
		conditions = append(conditions, "cisa_kev_date_added IS NOT NULL")
	}

	if len(filter.Statuses) > 0 {
		placeholders := make([]string, len(filter.Statuses))
		for i, st := range filter.Statuses {
			placeholders[i] = fmt.Sprintf("$%d", argIndex)
			args = append(args, st.String())
			argIndex++
		}
		conditions = append(conditions, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))
	}

	return strings.Join(conditions, " AND "), args
}

// JSON helper methods

func (r *VulnerabilityRepository) referencesToJSON(refs []vulnerability.Reference) []map[string]string {
	result := make([]map[string]string, len(refs))
	for i, ref := range refs {
		result[i] = map[string]string{
			"type": ref.Type(),
			"url":  ref.URL(),
		}
	}
	return result
}

func (r *VulnerabilityRepository) parseReferencesJSON(data []byte) []vulnerability.Reference {
	var jsonRefs []map[string]string
	if err := json.Unmarshal(data, &jsonRefs); err != nil {
		return nil
	}
	refs := make([]vulnerability.Reference, len(jsonRefs))
	for i, jr := range jsonRefs {
		refs[i] = vulnerability.NewReference(jr["type"], jr["url"])
	}
	return refs
}

func (r *VulnerabilityRepository) affectedVersionsToJSON(versions []vulnerability.AffectedVersion) []map[string]string {
	result := make([]map[string]string, len(versions))
	for i, av := range versions {
		result[i] = map[string]string{
			"ecosystem":  av.Ecosystem(),
			"package":    av.Package(),
			"introduced": av.Introduced(),
			"fixed":      av.Fixed(),
		}
	}
	return result
}

func (r *VulnerabilityRepository) parseAffectedVersionsJSON(data []byte) []vulnerability.AffectedVersion {
	var jsonVersions []map[string]string
	if err := json.Unmarshal(data, &jsonVersions); err != nil {
		return nil
	}
	versions := make([]vulnerability.AffectedVersion, len(jsonVersions))
	for i, jv := range jsonVersions {
		versions[i] = vulnerability.NewAffectedVersion(
			jv["ecosystem"],
			jv["package"],
			jv["introduced"],
			jv["fixed"],
		)
	}
	return versions
}

// nullFloat64 helper
func nullFloat64(f *float64) sql.NullFloat64 {
	if f == nil {
		return sql.NullFloat64{}
	}
	return sql.NullFloat64{Float64: *f, Valid: true}
}
