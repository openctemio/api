package vulnerability

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"regexp"
	"strings"
)

// FingerprintStrategy defines the interface for generating finding fingerprints.
// Different finding types may have different fingerprinting requirements.
type FingerprintStrategy interface {
	// Generate creates a fingerprint for the given finding.
	Generate(f *Finding) string
	// Name returns the strategy name (for storing in partial_fingerprints).
	Name() string
}

// GetFingerprintStrategy returns the appropriate fingerprint strategy based on finding type.
func GetFingerprintStrategy(findingType FindingType, source FindingSource) FingerprintStrategy {
	// First check by finding type
	switch findingType {
	case FindingTypeSecret:
		return &SecretFingerprintStrategy{}
	case FindingTypeCompliance:
		return &ComplianceFingerprintStrategy{}
	case FindingTypeMisconfiguration:
		return &MisconfigFingerprintStrategy{}
	case FindingTypeWeb3:
		return &Web3FingerprintStrategy{}
	}

	// Fallback to source-based detection
	switch source {
	case FindingSourceSecret:
		return &SecretFingerprintStrategy{}
	case FindingSourceIaC:
		return &MisconfigFingerprintStrategy{}
	case FindingSourceSCA:
		return &SCAFingerprintStrategy{}
	case FindingSourceDAST:
		return &DASTFingerprintStrategy{}
	default:
		return &SASTFingerprintStrategy{}
	}
}

// GenerateFingerprintWithStrategy generates a fingerprint using the appropriate strategy.
// It also populates partial_fingerprints for multi-algorithm support.
func GenerateFingerprintWithStrategy(f *Finding) string {
	strategy := GetFingerprintStrategy(f.findingType, f.source)
	fingerprint := strategy.Generate(f)

	// Store in partial_fingerprints for traceability
	if f.partialFingerprints == nil {
		f.partialFingerprints = make(map[string]string)
	}
	f.partialFingerprints[strategy.Name()] = fingerprint

	return fingerprint
}

// =============================================================================
// SAST Fingerprint Strategy
// =============================================================================

// SASTFingerprintStrategy generates fingerprints for SAST findings.
// Focuses on: asset, rule, file path, and normalized snippet (resilient to line shifts).
type SASTFingerprintStrategy struct{}

func (s *SASTFingerprintStrategy) Name() string {
	return "sast/v1"
}

func (s *SASTFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))
	h.Write([]byte(f.ruleID))
	h.Write([]byte(f.filePath))
	// Use normalized snippet instead of line number for resilience to code shifts
	h.Write([]byte(normalizeSnippet(f.snippet)))
	// Include function context if available
	if len(f.relatedLocations) > 0 && f.relatedLocations[0].LogicalLocation != nil {
		h.Write([]byte(f.relatedLocations[0].LogicalLocation.FullyQualifiedName))
	}
	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// SCA Fingerprint Strategy
// =============================================================================

// SCAFingerprintStrategy generates fingerprints for SCA (dependency) findings.
// Focuses on: asset, package (PURL), and CVE.
type SCAFingerprintStrategy struct{}

func (s *SCAFingerprintStrategy) Name() string {
	return "sca/v1"
}

func (s *SCAFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))

	// Use PURL from metadata if available (most stable identifier)
	if purl, ok := f.metadata["purl"].(string); ok && purl != "" {
		h.Write([]byte(purl))
	} else if pkg, ok := f.metadata["package"].(string); ok && pkg != "" {
		h.Write([]byte(pkg))
	}

	// Include CVE if available
	if f.cveID != "" {
		h.Write([]byte(f.cveID))
	} else {
		// Fallback to rule ID
		h.Write([]byte(f.ruleID))
	}

	// Include manifest file path for disambiguation
	h.Write([]byte(f.filePath))

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// DAST Fingerprint Strategy
// =============================================================================

// DASTFingerprintStrategy generates fingerprints for DAST findings.
// Focuses on: asset, rule, endpoint URL, and parameter name.
type DASTFingerprintStrategy struct{}

func (s *DASTFingerprintStrategy) Name() string {
	return "dast/v1"
}

func (s *DASTFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))
	h.Write([]byte(f.ruleID))

	// Use endpoint/URL from metadata
	if endpoint, ok := f.metadata["endpoint"].(string); ok {
		h.Write([]byte(normalizeURL(endpoint)))
	} else if url, ok := f.metadata["url"].(string); ok {
		h.Write([]byte(normalizeURL(url)))
	}

	// Include parameter name if available
	if param, ok := f.metadata["parameter"].(string); ok {
		h.Write([]byte(param))
	}

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Secret Fingerprint Strategy
// =============================================================================

// SecretFingerprintStrategy generates fingerprints for secret findings.
// Focuses on: asset, secret type, service, and masked value prefix.
type SecretFingerprintStrategy struct{}

func (s *SecretFingerprintStrategy) Name() string {
	return "secret/v1"
}

func (s *SecretFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))

	// Use dedicated fields first, fallback to metadata
	secretType := f.secretType
	if secretType == "" {
		if st, ok := f.metadata["secret_type"].(string); ok {
			secretType = st
		}
	}
	h.Write([]byte(secretType))

	service := f.secretService
	if service == "" {
		if svc, ok := f.metadata["service"].(string); ok {
			service = svc
		}
	}
	h.Write([]byte(service))

	// SECURITY: Only use pre-masked values from scanner output.
	// Never use raw snippet which may contain the full secret.
	// The masked_value should already be sanitized by the scanner (e.g., "ghp_****XXXX")
	if masked, ok := f.metadata["masked_value"].(string); ok && len(masked) >= 8 {
		// Use a hash of the masked value, not the masked value directly
		// This prevents any partial secret exposure while maintaining uniqueness
		maskedHash := sha256.Sum256([]byte(masked))
		h.Write(maskedHash[:8])
	} else {
		// Fallback: use rule_id + line number for uniqueness
		// This is less precise but avoids any secret exposure
		h.Write([]byte(f.ruleID))
		fmt.Fprintf(h, "%d", f.startLine)
	}

	// Include file path for location context
	h.Write([]byte(f.filePath))

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Compliance Fingerprint Strategy
// =============================================================================

// ComplianceFingerprintStrategy generates fingerprints for compliance findings.
// Focuses on: asset, framework, control ID, and resource path.
type ComplianceFingerprintStrategy struct{}

func (s *ComplianceFingerprintStrategy) Name() string {
	return "compliance/v1"
}

func (s *ComplianceFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))

	// Use dedicated fields first
	framework := f.complianceFramework
	if framework == "" {
		if fw, ok := f.metadata["framework"].(string); ok {
			framework = fw
		}
	}
	h.Write([]byte(framework))

	controlID := f.complianceControlID
	if controlID == "" {
		if cid, ok := f.metadata["control_id"].(string); ok {
			controlID = cid
		}
	}
	h.Write([]byte(controlID))

	// Include resource path or file path
	h.Write([]byte(f.filePath))

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Misconfiguration Fingerprint Strategy
// =============================================================================

// MisconfigFingerprintStrategy generates fingerprints for IaC/misconfiguration findings.
// Focuses on: asset, policy ID, resource type, and resource path.
type MisconfigFingerprintStrategy struct{}

func (s *MisconfigFingerprintStrategy) Name() string {
	return "misconfig/v1"
}

func (s *MisconfigFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))

	// Use dedicated fields first
	policyID := f.misconfigPolicyID
	if policyID == "" {
		if pid, ok := f.metadata["policy_id"].(string); ok {
			policyID = pid
		} else {
			policyID = f.ruleID
		}
	}
	h.Write([]byte(policyID))

	resourceType := f.misconfigResourceType
	if resourceType == "" {
		if rt, ok := f.metadata["resource_type"].(string); ok {
			resourceType = rt
		}
	}
	h.Write([]byte(resourceType))

	resourcePath := f.misconfigResourcePath
	if resourcePath == "" {
		if rp, ok := f.metadata["resource_path"].(string); ok {
			resourcePath = rp
		} else {
			resourcePath = f.filePath
		}
	}
	h.Write([]byte(resourcePath))

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Web3 Fingerprint Strategy
// =============================================================================

// Web3FingerprintStrategy generates fingerprints for blockchain/smart contract findings.
// Focuses on: chain, contract address, SWC ID, and function selector.
type Web3FingerprintStrategy struct{}

func (s *Web3FingerprintStrategy) Name() string {
	return "web3/v1"
}

func (s *Web3FingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()

	// For Web3, chain + contract is the primary identifier (not asset)
	chain := f.web3Chain
	if chain == "" {
		if c, ok := f.metadata["chain"].(string); ok {
			chain = c
		}
	}
	h.Write([]byte(chain))

	chainID := f.web3ChainID
	if chainID == 0 {
		if cid, ok := f.metadata["chain_id"].(float64); ok {
			chainID = int64(cid)
		}
	}
	fmt.Fprintf(h, "%d", chainID)

	contractAddr := f.web3ContractAddress
	if contractAddr == "" {
		if ca, ok := f.metadata["contract_address"].(string); ok {
			contractAddr = ca
		}
	}
	h.Write([]byte(strings.ToLower(contractAddr)))

	swcID := f.web3SWCID
	if swcID == "" {
		if swc, ok := f.metadata["swc_id"].(string); ok {
			swcID = swc
		} else {
			swcID = f.ruleID
		}
	}
	h.Write([]byte(swcID))

	// Include function signature if available
	funcSig := f.web3FunctionSignature
	if funcSig == "" {
		if fs, ok := f.metadata["function_signature"].(string); ok {
			funcSig = fs
		}
	}
	h.Write([]byte(funcSig))

	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Legacy/Default Fingerprint Strategy
// =============================================================================

// DefaultFingerprintStrategy is the legacy fingerprint algorithm for backward compatibility.
type DefaultFingerprintStrategy struct{}

func (s *DefaultFingerprintStrategy) Name() string {
	return "default/v1"
}

func (s *DefaultFingerprintStrategy) Generate(f *Finding) string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))
	h.Write([]byte(f.ruleID))
	h.Write([]byte(f.filePath))
	fmt.Fprintf(h, "%d", f.startLine)
	h.Write([]byte(f.message))
	return hex.EncodeToString(h.Sum(nil))[:32]
}

// =============================================================================
// Helper Functions
// =============================================================================

// normalizeSnippet normalizes a code snippet for fingerprinting.
// Removes whitespace variations while preserving semantic content.
func normalizeSnippet(snippet string) string {
	if snippet == "" {
		return ""
	}

	// Remove leading/trailing whitespace from each line
	lines := strings.Split(snippet, "\n")
	normalized := make([]string, 0, len(lines))
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed != "" {
			normalized = append(normalized, trimmed)
		}
	}

	// Join and normalize multiple spaces to single space
	result := strings.Join(normalized, " ")
	spaceRegex := regexp.MustCompile(`\s+`)
	result = spaceRegex.ReplaceAllString(result, " ")

	return result
}

// normalizeURL normalizes a URL for fingerprinting.
// Removes query parameters and fragments that may vary.
func normalizeURL(url string) string {
	if url == "" {
		return ""
	}

	// Remove query string and fragment
	if idx := strings.Index(url, "?"); idx != -1 {
		url = url[:idx]
	}
	if idx := strings.Index(url, "#"); idx != -1 {
		url = url[:idx]
	}

	// Normalize path (remove trailing slashes)
	url = strings.TrimSuffix(url, "/")

	return strings.ToLower(url)
}
