package vulnerability

import (
	"fmt"
	"regexp"
	"time"

	"github.com/openctemio/api/pkg/domain/shared"
)

var cvePattern = regexp.MustCompile(`^CVE-\d{4}-\d{4,}$`)

// Vulnerability represents a global vulnerability (CVE).
type Vulnerability struct {
	id               shared.ID
	cveID            string
	aliases          []string // GHSA-xxxx, etc.
	title            string
	description      string
	severity         Severity
	cvssScore        *float64
	cvssVector       string
	epssScore        *float64
	epssPercentile   *float64
	cisaKEV          *CISAKEV
	exploitAvailable bool
	exploitMaturity  ExploitMaturity
	references       []Reference
	affectedVersions []AffectedVersion
	fixedVersions    []string
	remediation      string
	publishedAt      *time.Time
	modifiedAt       *time.Time
	status           VulnerabilityStatus
	createdAt        time.Time
	updatedAt        time.Time
}

// NewVulnerability creates a new Vulnerability.
func NewVulnerability(
	cveID string,
	title string,
	severity Severity,
) (*Vulnerability, error) {
	if !IsValidCVE(cveID) {
		return nil, fmt.Errorf("%w: invalid CVE ID format", shared.ErrValidation)
	}
	if title == "" {
		return nil, fmt.Errorf("%w: title is required", shared.ErrValidation)
	}
	if !severity.IsValid() {
		return nil, fmt.Errorf("%w: invalid severity", shared.ErrValidation)
	}

	now := time.Now().UTC()
	return &Vulnerability{
		id:               shared.NewID(),
		cveID:            cveID,
		title:            title,
		severity:         severity,
		aliases:          make([]string, 0),
		exploitMaturity:  ExploitMaturityNone,
		references:       make([]Reference, 0),
		affectedVersions: make([]AffectedVersion, 0),
		fixedVersions:    make([]string, 0),
		status:           VulnerabilityStatusOpen,
		createdAt:        now,
		updatedAt:        now,
	}, nil
}

// IsValidCVE checks if the CVE ID format is valid.
func IsValidCVE(cveID string) bool {
	return cvePattern.MatchString(cveID)
}

// Reconstitute recreates a Vulnerability from persistence.
func Reconstitute(
	id shared.ID,
	cveID string,
	aliases []string,
	title string,
	description string,
	severity Severity,
	cvssScore *float64,
	cvssVector string,
	epssScore *float64,
	epssPercentile *float64,
	cisaKEV *CISAKEV,
	exploitAvailable bool,
	exploitMaturity ExploitMaturity,
	references []Reference,
	affectedVersions []AffectedVersion,
	fixedVersions []string,
	remediation string,
	publishedAt *time.Time,
	modifiedAt *time.Time,
	status VulnerabilityStatus,
	createdAt time.Time,
	updatedAt time.Time,
) *Vulnerability {
	if aliases == nil {
		aliases = make([]string, 0)
	}
	if references == nil {
		references = make([]Reference, 0)
	}
	if affectedVersions == nil {
		affectedVersions = make([]AffectedVersion, 0)
	}
	if fixedVersions == nil {
		fixedVersions = make([]string, 0)
	}
	return &Vulnerability{
		id:               id,
		cveID:            cveID,
		aliases:          aliases,
		title:            title,
		description:      description,
		severity:         severity,
		cvssScore:        cvssScore,
		cvssVector:       cvssVector,
		epssScore:        epssScore,
		epssPercentile:   epssPercentile,
		cisaKEV:          cisaKEV,
		exploitAvailable: exploitAvailable,
		exploitMaturity:  exploitMaturity,
		references:       references,
		affectedVersions: affectedVersions,
		fixedVersions:    fixedVersions,
		remediation:      remediation,
		publishedAt:      publishedAt,
		modifiedAt:       modifiedAt,
		status:           status,
		createdAt:        createdAt,
		updatedAt:        updatedAt,
	}
}

// Getters

// ID returns the vulnerability ID.
func (v *Vulnerability) ID() shared.ID {
	return v.id
}

// CVEID returns the CVE ID.
func (v *Vulnerability) CVEID() string {
	return v.cveID
}

// Aliases returns a copy of the aliases.
func (v *Vulnerability) Aliases() []string {
	aliases := make([]string, len(v.aliases))
	copy(aliases, v.aliases)
	return aliases
}

// Title returns the title.
func (v *Vulnerability) Title() string {
	return v.title
}

// Description returns the description.
func (v *Vulnerability) Description() string {
	return v.description
}

// Severity returns the severity.
func (v *Vulnerability) Severity() Severity {
	return v.severity
}

// CVSSScore returns the CVSS score.
func (v *Vulnerability) CVSSScore() *float64 {
	return v.cvssScore
}

// CVSSVector returns the CVSS vector.
func (v *Vulnerability) CVSSVector() string {
	return v.cvssVector
}

// EPSSScore returns the EPSS score.
func (v *Vulnerability) EPSSScore() *float64 {
	return v.epssScore
}

// EPSSPercentile returns the EPSS percentile.
func (v *Vulnerability) EPSSPercentile() *float64 {
	return v.epssPercentile
}

// CISAKEV returns the CISA KEV data.
func (v *Vulnerability) CISAKEV() *CISAKEV {
	return v.cisaKEV
}

// ExploitAvailable returns whether an exploit is available.
func (v *Vulnerability) ExploitAvailable() bool {
	return v.exploitAvailable
}

// ExploitMaturity returns the exploit maturity.
func (v *Vulnerability) ExploitMaturity() ExploitMaturity {
	return v.exploitMaturity
}

// References returns a copy of the references.
func (v *Vulnerability) References() []Reference {
	refs := make([]Reference, len(v.references))
	copy(refs, v.references)
	return refs
}

// AffectedVersions returns a copy of the affected versions.
func (v *Vulnerability) AffectedVersions() []AffectedVersion {
	versions := make([]AffectedVersion, len(v.affectedVersions))
	copy(versions, v.affectedVersions)
	return versions
}

// FixedVersions returns a copy of the fixed versions.
func (v *Vulnerability) FixedVersions() []string {
	versions := make([]string, len(v.fixedVersions))
	copy(versions, v.fixedVersions)
	return versions
}

// Remediation returns the remediation guidance.
func (v *Vulnerability) Remediation() string {
	return v.remediation
}

// PublishedAt returns the published date.
func (v *Vulnerability) PublishedAt() *time.Time {
	return v.publishedAt
}

// ModifiedAt returns the modified date.
func (v *Vulnerability) ModifiedAt() *time.Time {
	return v.modifiedAt
}

// Status returns the status.
func (v *Vulnerability) Status() VulnerabilityStatus {
	return v.status
}

// CreatedAt returns the creation time.
func (v *Vulnerability) CreatedAt() time.Time {
	return v.createdAt
}

// UpdatedAt returns the last update time.
func (v *Vulnerability) UpdatedAt() time.Time {
	return v.updatedAt
}

// Mutators

// UpdateTitle updates the title.
func (v *Vulnerability) UpdateTitle(title string) error {
	if title == "" {
		return fmt.Errorf("%w: title is required", shared.ErrValidation)
	}
	v.title = title
	v.updatedAt = time.Now().UTC()
	return nil
}

// UpdateDescription updates the description.
func (v *Vulnerability) UpdateDescription(description string) {
	v.description = description
	v.updatedAt = time.Now().UTC()
}

// UpdateSeverity updates the severity.
func (v *Vulnerability) UpdateSeverity(severity Severity) error {
	if !severity.IsValid() {
		return fmt.Errorf("%w: invalid severity", shared.ErrValidation)
	}
	v.severity = severity
	v.updatedAt = time.Now().UTC()
	return nil
}

// UpdateCVSS updates the CVSS score and vector.
func (v *Vulnerability) UpdateCVSS(score float64, vector string) {
	v.cvssScore = &score
	v.cvssVector = vector
	v.updatedAt = time.Now().UTC()
}

// UpdateEPSS updates the EPSS score and percentile.
func (v *Vulnerability) UpdateEPSS(score, percentile float64) {
	v.epssScore = &score
	v.epssPercentile = &percentile
	v.updatedAt = time.Now().UTC()
}

// SetCISAKEV sets the CISA KEV data.
func (v *Vulnerability) SetCISAKEV(kev *CISAKEV) {
	v.cisaKEV = kev
	v.updatedAt = time.Now().UTC()
}

// SetExploitAvailable sets whether an exploit is available.
func (v *Vulnerability) SetExploitAvailable(available bool) {
	v.exploitAvailable = available
	v.updatedAt = time.Now().UTC()
}

// SetExploitMaturity sets the exploit maturity.
func (v *Vulnerability) SetExploitMaturity(maturity ExploitMaturity) {
	v.exploitMaturity = maturity
	v.updatedAt = time.Now().UTC()
}

// AddAlias adds an alias.
func (v *Vulnerability) AddAlias(alias string) {
	for _, a := range v.aliases {
		if a == alias {
			return
		}
	}
	v.aliases = append(v.aliases, alias)
	v.updatedAt = time.Now().UTC()
}

// SetAliases replaces all aliases.
func (v *Vulnerability) SetAliases(aliases []string) {
	v.aliases = make([]string, len(aliases))
	copy(v.aliases, aliases)
	v.updatedAt = time.Now().UTC()
}

// AddReference adds a reference.
func (v *Vulnerability) AddReference(ref Reference) {
	v.references = append(v.references, ref)
	v.updatedAt = time.Now().UTC()
}

// SetReferences replaces all references.
func (v *Vulnerability) SetReferences(refs []Reference) {
	v.references = make([]Reference, len(refs))
	copy(v.references, refs)
	v.updatedAt = time.Now().UTC()
}

// AddAffectedVersion adds an affected version.
func (v *Vulnerability) AddAffectedVersion(av AffectedVersion) {
	v.affectedVersions = append(v.affectedVersions, av)
	v.updatedAt = time.Now().UTC()
}

// SetAffectedVersions replaces all affected versions.
func (v *Vulnerability) SetAffectedVersions(versions []AffectedVersion) {
	v.affectedVersions = make([]AffectedVersion, len(versions))
	copy(v.affectedVersions, versions)
	v.updatedAt = time.Now().UTC()
}

// SetFixedVersions sets the fixed versions.
func (v *Vulnerability) SetFixedVersions(versions []string) {
	v.fixedVersions = make([]string, len(versions))
	copy(v.fixedVersions, versions)
	v.updatedAt = time.Now().UTC()
}

// UpdateRemediation updates the remediation guidance.
func (v *Vulnerability) UpdateRemediation(remediation string) {
	v.remediation = remediation
	v.updatedAt = time.Now().UTC()
}

// SetPublishedAt sets the published date.
func (v *Vulnerability) SetPublishedAt(t time.Time) {
	v.publishedAt = &t
	v.updatedAt = time.Now().UTC()
}

// SetModifiedAt sets the modified date.
func (v *Vulnerability) SetModifiedAt(t time.Time) {
	v.modifiedAt = &t
	v.updatedAt = time.Now().UTC()
}

// UpdateStatus updates the status.
func (v *Vulnerability) UpdateStatus(status VulnerabilityStatus) error {
	if !status.IsValid() {
		return fmt.Errorf("%w: invalid status", shared.ErrValidation)
	}
	v.status = status
	v.updatedAt = time.Now().UTC()
	return nil
}

// Helper methods

// IsCritical checks if the vulnerability is critical.
func (v *Vulnerability) IsCritical() bool {
	return v.severity == SeverityCritical
}

// IsHighOrCritical checks if the vulnerability is high or critical.
func (v *Vulnerability) IsHighOrCritical() bool {
	return v.severity == SeverityCritical || v.severity == SeverityHigh
}

// IsInCISAKEV checks if the vulnerability is in CISA KEV.
func (v *Vulnerability) IsInCISAKEV() bool {
	return v.cisaKEV != nil && !v.cisaKEV.IsZero()
}

// IsKEVPastDue checks if the CISA KEV due date has passed.
func (v *Vulnerability) IsKEVPastDue() bool {
	return v.cisaKEV != nil && v.cisaKEV.IsPastDue()
}

// HasExploit checks if an exploit exists.
func (v *Vulnerability) HasExploit() bool {
	return v.exploitAvailable || v.exploitMaturity != ExploitMaturityNone
}

// RiskScore calculates a risk score based on various factors.
func (v *Vulnerability) RiskScore() float64 {
	score := v.severity.Score()

	// Increase score for CVSS
	if v.cvssScore != nil {
		score = *v.cvssScore
	}

	// Increase for EPSS
	if v.epssScore != nil && *v.epssScore > 0.5 {
		score += 1.0
	}

	// Increase for KEV
	if v.IsInCISAKEV() {
		score += 2.0
	}

	// Increase for exploit availability
	if v.exploitAvailable {
		score += 1.5
	}

	// Cap at 10
	if score > 10 {
		score = 10
	}

	return score
}
