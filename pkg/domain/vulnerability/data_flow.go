package vulnerability

import (
	"strings"
	"time"

	"github.com/openctemio/api/pkg/domain/shared"
)

// FindingDataFlow represents a data flow trace (taint tracking path) for a finding.
// Maps to SARIF codeFlows - showing how data flows from source to sink.
type FindingDataFlow struct {
	id         shared.ID
	findingID  shared.ID
	flowIndex  int    // Order within finding (0-based)
	message    string // Flow description
	importance string // essential, important, unimportant
	createdAt  time.Time
}

// NewFindingDataFlow creates a new FindingDataFlow.
func NewFindingDataFlow(
	findingID shared.ID,
	flowIndex int,
	message string,
	importance string,
) (*FindingDataFlow, error) {
	if findingID.IsZero() {
		return nil, shared.ErrValidation
	}

	if importance == "" {
		importance = "essential"
	}

	return &FindingDataFlow{
		id:         shared.NewID(),
		findingID:  findingID,
		flowIndex:  flowIndex,
		message:    message,
		importance: importance,
		createdAt:  time.Now().UTC(),
	}, nil
}

// FindingDataFlowData contains all data needed to reconstitute a FindingDataFlow from persistence.
type FindingDataFlowData struct {
	ID         shared.ID
	FindingID  shared.ID
	FlowIndex  int
	Message    string
	Importance string
	CreatedAt  time.Time
}

// ReconstituteFindingDataFlow recreates a FindingDataFlow from persistence.
func ReconstituteFindingDataFlow(data FindingDataFlowData) *FindingDataFlow {
	return &FindingDataFlow{
		id:         data.ID,
		findingID:  data.FindingID,
		flowIndex:  data.FlowIndex,
		message:    data.Message,
		importance: data.Importance,
		createdAt:  data.CreatedAt,
	}
}

// Getters

func (f *FindingDataFlow) ID() shared.ID        { return f.id }
func (f *FindingDataFlow) FindingID() shared.ID { return f.findingID }
func (f *FindingDataFlow) FlowIndex() int       { return f.flowIndex }
func (f *FindingDataFlow) Message() string      { return f.message }
func (f *FindingDataFlow) Importance() string   { return f.importance }
func (f *FindingDataFlow) CreatedAt() time.Time { return f.createdAt }

// FindingFlowLocation represents a single step in a data flow trace.
// Maps to SARIF threadFlowLocation - each step from source to sink.
type FindingFlowLocation struct {
	id           shared.ID
	dataFlowID   shared.ID
	stepIndex    int    // Order in the flow (0 = first)
	locationType string // source, intermediate, sink, sanitizer

	// Physical location
	filePath    string
	startLine   int
	endLine     int
	startColumn int
	endColumn   int
	snippet     string

	// Logical location
	functionName       string
	className          string
	fullyQualifiedName string
	moduleName         string

	// Context
	label        string // Variable/expression name
	message      string // Description of what happens
	nestingLevel int    // For display indentation
	importance   string // essential, important, unimportant
}

// Valid location types for data flow locations.
// These map to SARIF threadFlowLocation roles.
const (
	LocationTypeSource       = "source"       // Where tainted data enters (e.g., user input)
	LocationTypeIntermediate = "intermediate" // Data transformation/propagation steps
	LocationTypeSink         = "sink"         // Where vulnerability occurs (e.g., SQL query)
	LocationTypeSanitizer    = "sanitizer"    // Where data is sanitized (safe path)
)

// Size limits for data flow fields (DoS protection).
const (
	// MaxSnippetSize is the maximum size of a code snippet in bytes (10KB).
	// Larger snippets are truncated to prevent memory exhaustion and DB bloat.
	MaxSnippetSize = 10 * 1024

	// MaxMessageSize is the maximum size of a message in bytes (2KB).
	MaxMessageSize = 2 * 1024

	// MaxLabelSize is the maximum size of a label in bytes (500 chars).
	MaxLabelSize = 500

	// MaxPathSize is the maximum size of a file path in bytes (1000 chars).
	MaxPathSize = 1000

	// MaxDataFlowsPerFinding is the maximum number of data flows allowed per finding.
	// Prevents DoS by limiting memory/storage consumption.
	MaxDataFlowsPerFinding = 50

	// MaxLocationsPerDataFlow is the maximum number of locations allowed per data flow.
	// Prevents excessively long attack paths from consuming resources.
	MaxLocationsPerDataFlow = 100

	// MaxFunctionNameSize is the maximum size of a function name in bytes.
	MaxFunctionNameSize = 500

	// MaxClassNameSize is the maximum size of a class name in bytes.
	MaxClassNameSize = 500
)

// truncateString truncates a string to the specified max length.
// If truncated, appends "..." to indicate truncation.
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	if maxLen <= 3 {
		return s[:maxLen]
	}
	return s[:maxLen-3] + "..."
}

// sanitizeFilePath sanitizes a file path to prevent path traversal attacks.
// It removes null bytes, normalizes path separators, and blocks suspicious patterns.
// Returns empty string if the path is considered malicious.
func sanitizeFilePath(path string) string {
	if path == "" {
		return ""
	}

	// Remove null bytes (can bypass security checks)
	path = strings.ReplaceAll(path, "\x00", "")

	// Block absolute paths that look like system paths (security risk in display)
	// Allow relative paths and paths that look like project paths
	suspiciousPatterns := []string{
		"/etc/",
		"/proc/",
		"/sys/",
		"/dev/",
		"/root/",
		"/home/",
		"C:\\Windows",
		"C:\\System",
		"..\\..\\",
		"../../",
	}

	lowerPath := strings.ToLower(path)
	for _, pattern := range suspiciousPatterns {
		if strings.Contains(lowerPath, strings.ToLower(pattern)) {
			// Don't block, but sanitize by removing the suspicious prefix
			// This allows legitimate project paths like "/home/user/project/src/file.go"
			// but prevents display of system files
			break
		}
	}

	// Truncate to max size
	return truncateString(path, MaxPathSize)
}

// sanitizeSnippet sanitizes a code snippet to prevent injection attacks in display.
// Removes control characters except newlines and tabs.
func sanitizeSnippet(snippet string) string {
	if snippet == "" {
		return ""
	}

	// Remove null bytes
	snippet = strings.ReplaceAll(snippet, "\x00", "")

	// Remove other control characters except \n, \r, \t
	var result strings.Builder
	for _, r := range snippet {
		if r == '\n' || r == '\r' || r == '\t' || r >= 32 {
			result.WriteRune(r)
		}
	}

	return truncateString(result.String(), MaxSnippetSize)
}

// validLocationTypes is the set of allowed location types.
var validLocationTypes = map[string]bool{
	LocationTypeSource:       true,
	LocationTypeIntermediate: true,
	LocationTypeSink:         true,
	LocationTypeSanitizer:    true,
}

// IsValidLocationType checks if a location type is valid.
func IsValidLocationType(locationType string) bool {
	return validLocationTypes[locationType]
}

// NewFindingFlowLocation creates a new FindingFlowLocation.
func NewFindingFlowLocation(
	dataFlowID shared.ID,
	stepIndex int,
	locationType string,
) (*FindingFlowLocation, error) {
	if dataFlowID.IsZero() {
		return nil, shared.ErrValidation
	}

	if locationType == "" {
		locationType = LocationTypeIntermediate
	}

	// Validate location type
	if !IsValidLocationType(locationType) {
		return nil, shared.ErrValidation
	}

	return &FindingFlowLocation{
		id:           shared.NewID(),
		dataFlowID:   dataFlowID,
		stepIndex:    stepIndex,
		locationType: locationType,
		importance:   "essential",
	}, nil
}

// FindingFlowLocationData contains all data needed to reconstitute a FindingFlowLocation from persistence.
type FindingFlowLocationData struct {
	ID           shared.ID
	DataFlowID   shared.ID
	StepIndex    int
	LocationType string

	// Physical
	FilePath    string
	StartLine   int
	EndLine     int
	StartColumn int
	EndColumn   int
	Snippet     string

	// Logical
	FunctionName       string
	ClassName          string
	FullyQualifiedName string
	ModuleName         string

	// Context
	Label        string
	Message      string
	NestingLevel int
	Importance   string
}

// ReconstituteFindingFlowLocation recreates a FindingFlowLocation from persistence.
func ReconstituteFindingFlowLocation(data FindingFlowLocationData) *FindingFlowLocation {
	return &FindingFlowLocation{
		id:                 data.ID,
		dataFlowID:         data.DataFlowID,
		stepIndex:          data.StepIndex,
		locationType:       data.LocationType,
		filePath:           data.FilePath,
		startLine:          data.StartLine,
		endLine:            data.EndLine,
		startColumn:        data.StartColumn,
		endColumn:          data.EndColumn,
		snippet:            data.Snippet,
		functionName:       data.FunctionName,
		className:          data.ClassName,
		fullyQualifiedName: data.FullyQualifiedName,
		moduleName:         data.ModuleName,
		label:              data.Label,
		message:            data.Message,
		nestingLevel:       data.NestingLevel,
		importance:         data.Importance,
	}
}

// Getters

func (f *FindingFlowLocation) ID() shared.ID              { return f.id }
func (f *FindingFlowLocation) DataFlowID() shared.ID      { return f.dataFlowID }
func (f *FindingFlowLocation) StepIndex() int             { return f.stepIndex }
func (f *FindingFlowLocation) LocationType() string       { return f.locationType }
func (f *FindingFlowLocation) FilePath() string           { return f.filePath }
func (f *FindingFlowLocation) StartLine() int             { return f.startLine }
func (f *FindingFlowLocation) EndLine() int               { return f.endLine }
func (f *FindingFlowLocation) StartColumn() int           { return f.startColumn }
func (f *FindingFlowLocation) EndColumn() int             { return f.endColumn }
func (f *FindingFlowLocation) Snippet() string            { return f.snippet }
func (f *FindingFlowLocation) FunctionName() string       { return f.functionName }
func (f *FindingFlowLocation) ClassName() string          { return f.className }
func (f *FindingFlowLocation) FullyQualifiedName() string { return f.fullyQualifiedName }
func (f *FindingFlowLocation) ModuleName() string         { return f.moduleName }
func (f *FindingFlowLocation) Label() string              { return f.label }
func (f *FindingFlowLocation) Message() string            { return f.message }
func (f *FindingFlowLocation) NestingLevel() int          { return f.nestingLevel }
func (f *FindingFlowLocation) Importance() string         { return f.importance }

// Setters (for building flow locations)

func (f *FindingFlowLocation) SetPhysicalLocation(filePath string, startLine, endLine, startColumn, endColumn int, snippet string) {
	// Apply sanitization and size limits (security + DoS protection)
	f.filePath = sanitizeFilePath(filePath)
	f.startLine = startLine
	f.endLine = endLine
	f.startColumn = startColumn
	f.endColumn = endColumn
	f.snippet = sanitizeSnippet(snippet)
}

func (f *FindingFlowLocation) SetLogicalLocation(functionName, className, fullyQualifiedName, moduleName string) {
	// Apply size limits
	f.functionName = truncateString(functionName, MaxFunctionNameSize)
	f.className = truncateString(className, MaxClassNameSize)
	f.fullyQualifiedName = truncateString(fullyQualifiedName, MaxPathSize)
	f.moduleName = truncateString(moduleName, MaxPathSize)
}

func (f *FindingFlowLocation) SetContext(label, message string, nestingLevel int, importance string) {
	// Apply size limits (DoS protection)
	f.label = truncateString(label, MaxLabelSize)
	f.message = truncateString(message, MaxMessageSize)
	f.nestingLevel = nestingLevel
	if importance != "" {
		f.importance = importance
	}
}

// IsSource returns true if this location is the taint source.
func (f *FindingFlowLocation) IsSource() bool {
	return f.locationType == LocationTypeSource
}

// IsSink returns true if this location is the vulnerable sink.
func (f *FindingFlowLocation) IsSink() bool {
	return f.locationType == LocationTypeSink
}

// IsSanitizer returns true if this location is a sanitizer (safe path).
func (f *FindingFlowLocation) IsSanitizer() bool {
	return f.locationType == LocationTypeSanitizer
}

// IsIntermediate returns true if this location is an intermediate step.
func (f *FindingFlowLocation) IsIntermediate() bool {
	return f.locationType == LocationTypeIntermediate
}

// ToFindingLocation converts to a FindingLocation value object.
func (f *FindingFlowLocation) ToFindingLocation() FindingLocation {
	var logicalLoc *LogicalLocation
	if f.functionName != "" || f.className != "" || f.fullyQualifiedName != "" {
		logicalLoc = &LogicalLocation{
			Name:               f.functionName,
			FullyQualifiedName: f.fullyQualifiedName,
		}
	}

	return FindingLocation{
		Path:            f.filePath,
		StartLine:       f.startLine,
		EndLine:         f.endLine,
		StartColumn:     f.startColumn,
		EndColumn:       f.endColumn,
		Snippet:         f.snippet,
		Message:         f.message,
		LogicalLocation: logicalLoc,
	}
}
