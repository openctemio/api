package vulnerability

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/openctemio/api/pkg/domain/shared"
)

// ActivityType represents the type of finding activity.
type ActivityType string

const (
	// Lifecycle activities
	ActivityCreated         ActivityType = "created"
	ActivityStatusChanged   ActivityType = "status_changed"
	ActivitySeverityChanged ActivityType = "severity_changed"
	ActivityResolved        ActivityType = "resolved"
	ActivityReopened        ActivityType = "reopened"

	// Assignment activities
	ActivityAssigned   ActivityType = "assigned"
	ActivityUnassigned ActivityType = "unassigned"

	// Triage activities
	ActivityTriageUpdated       ActivityType = "triage_updated"
	ActivityFalsePositiveMarked ActivityType = "false_positive_marked"
	ActivityDuplicateMarked     ActivityType = "duplicate_marked"

	// Comment activities
	ActivityCommentAdded   ActivityType = "comment_added"
	ActivityCommentUpdated ActivityType = "comment_updated"
	ActivityCommentDeleted ActivityType = "comment_deleted"

	// Scanning activities
	ActivityScanDetected ActivityType = "scan_detected"
	ActivityAutoResolved ActivityType = "auto_resolved"
	ActivityAutoReopened ActivityType = "auto_reopened"

	// Integration activities
	ActivityLinked   ActivityType = "linked"
	ActivityUnlinked ActivityType = "unlinked"

	// SLA activities
	ActivitySLAWarning ActivityType = "sla_warning"
	ActivitySLABreach  ActivityType = "sla_breach"

	// AI activities
	ActivityAITriageRequested ActivityType = "ai_triage_requested" // User requested AI triage
	ActivityAITriage          ActivityType = "ai_triage"           // AI triage completed successfully
	ActivityAITriageFailed    ActivityType = "ai_triage_failed"    // AI triage failed
)

// ActorType represents who/what performed the activity.
type ActorType string

const (
	ActorTypeUser        ActorType = "user"
	ActorTypeSystem      ActorType = "system"
	ActorTypeScanner     ActorType = "scanner"
	ActorTypeIntegration ActorType = "integration"
	ActorTypeAI          ActorType = "ai"
)

// ActivitySource represents where the activity originated.
type ActivitySource string

const (
	SourceAPI       ActivitySource = "api"
	SourceUI        ActivitySource = "ui"
	SourceCI        ActivitySource = "ci"
	SourceWebhook   ActivitySource = "webhook"
	SourceScheduled ActivitySource = "scheduled"
	SourceAuto      ActivitySource = "auto"
	SourceImport    ActivitySource = "import"
)

// FindingActivity represents an immutable audit trail entry for a finding.
// This entity is APPEND-ONLY - once created, it should never be modified or deleted.
type FindingActivity struct {
	id             shared.ID
	tenantID       shared.ID
	findingID      shared.ID
	activityType   ActivityType
	actorID        *shared.ID // nullable for system actions
	actorType      ActorType
	actorName      string // Enriched from users table
	actorEmail     string // Enriched from users table
	changes        map[string]interface{}
	source         ActivitySource
	sourceMetadata map[string]interface{}
	createdAt      time.Time
	// NO updatedAt - immutable
}

// ActivityChanges provides typed access to common change patterns.
type ActivityChanges struct {
	// Status changes
	OldStatus string `json:"old_status,omitempty"`
	NewStatus string `json:"new_status,omitempty"`
	Reason    string `json:"reason,omitempty"`

	// Severity changes
	OldSeverity string `json:"old_severity,omitempty"`
	NewSeverity string `json:"new_severity,omitempty"`

	// Assignment
	AssigneeID    string `json:"assignee_id,omitempty"`
	AssigneeName  string `json:"assignee_name,omitempty"`
	AssigneeEmail string `json:"assignee_email,omitempty"`

	// Comments
	CommentID string `json:"comment_id,omitempty"`
	Preview   string `json:"preview,omitempty"` // First 100 chars of comment

	// Scanning
	ScanID   string `json:"scan_id,omitempty"`
	Scanner  string `json:"scanner,omitempty"`
	ScanType string `json:"scan_type,omitempty"`

	// Linking
	LinkedType string `json:"linked_type,omitempty"` // jira, github, etc.
	LinkedID   string `json:"linked_id,omitempty"`
	LinkedURL  string `json:"linked_url,omitempty"`

	// Triage
	TriageStatus string `json:"triage_status,omitempty"`
	TriageReason string `json:"triage_reason,omitempty"`

	// AI Triage
	AIRiskLevel      string `json:"ai_risk_level,omitempty"`
	AIConfidence     string `json:"ai_confidence,omitempty"`
	AIRecommendation string `json:"ai_recommendation,omitempty"`
}

// NewFindingActivity creates a new finding activity.
func NewFindingActivity(
	tenantID shared.ID,
	findingID shared.ID,
	activityType ActivityType,
	actorID *shared.ID,
	actorType ActorType,
	changes map[string]interface{},
	source ActivitySource,
	sourceMetadata map[string]interface{},
) (*FindingActivity, error) {
	if tenantID.IsZero() {
		return nil, fmt.Errorf("%w: tenant id is required", shared.ErrValidation)
	}
	if findingID.IsZero() {
		return nil, fmt.Errorf("%w: finding id is required", shared.ErrValidation)
	}
	if activityType == "" {
		return nil, fmt.Errorf("%w: activity type is required", shared.ErrValidation)
	}
	if actorType == "" {
		actorType = ActorTypeSystem
	}
	if changes == nil {
		changes = make(map[string]interface{})
	}
	if sourceMetadata == nil {
		sourceMetadata = make(map[string]interface{})
	}

	return &FindingActivity{
		id:             shared.NewID(),
		tenantID:       tenantID,
		findingID:      findingID,
		activityType:   activityType,
		actorID:        actorID,
		actorType:      actorType,
		changes:        changes,
		source:         source,
		sourceMetadata: sourceMetadata,
		createdAt:      time.Now().UTC(),
	}, nil
}

// ReconstituteFindingActivity recreates a FindingActivity from persistence.
func ReconstituteFindingActivity(
	id shared.ID,
	tenantID shared.ID,
	findingID shared.ID,
	activityType ActivityType,
	actorID *shared.ID,
	actorType ActorType,
	actorName string,
	actorEmail string,
	changes map[string]interface{},
	source ActivitySource,
	sourceMetadata map[string]interface{},
	createdAt time.Time,
) *FindingActivity {
	if changes == nil {
		changes = make(map[string]interface{})
	}
	if sourceMetadata == nil {
		sourceMetadata = make(map[string]interface{})
	}
	return &FindingActivity{
		id:             id,
		tenantID:       tenantID,
		findingID:      findingID,
		activityType:   activityType,
		actorID:        actorID,
		actorType:      actorType,
		actorName:      actorName,
		actorEmail:     actorEmail,
		changes:        changes,
		source:         source,
		sourceMetadata: sourceMetadata,
		createdAt:      createdAt,
	}
}

// Getters

func (a *FindingActivity) ID() shared.ID                          { return a.id }
func (a *FindingActivity) TenantID() shared.ID                    { return a.tenantID }
func (a *FindingActivity) FindingID() shared.ID                   { return a.findingID }
func (a *FindingActivity) ActivityType() ActivityType             { return a.activityType }
func (a *FindingActivity) ActorID() *shared.ID                    { return a.actorID }
func (a *FindingActivity) ActorType() ActorType                   { return a.actorType }
func (a *FindingActivity) ActorName() string                      { return a.actorName }
func (a *FindingActivity) ActorEmail() string                     { return a.actorEmail }
func (a *FindingActivity) Changes() map[string]interface{}        { return a.changes }
func (a *FindingActivity) Source() ActivitySource                 { return a.source }
func (a *FindingActivity) SourceMetadata() map[string]interface{} { return a.sourceMetadata }
func (a *FindingActivity) CreatedAt() time.Time                   { return a.createdAt }

// ChangesJSON returns the changes as JSON bytes.
func (a *FindingActivity) ChangesJSON() ([]byte, error) {
	return json.Marshal(a.changes)
}

// SourceMetadataJSON returns the source metadata as JSON bytes.
func (a *FindingActivity) SourceMetadataJSON() ([]byte, error) {
	return json.Marshal(a.sourceMetadata)
}

// ParsedChanges returns the changes parsed into a typed struct.
func (a *FindingActivity) ParsedChanges() (*ActivityChanges, error) {
	data, err := json.Marshal(a.changes)
	if err != nil {
		return nil, err
	}
	var changes ActivityChanges
	if err := json.Unmarshal(data, &changes); err != nil {
		return nil, err
	}
	return &changes, nil
}

// Helper constructors for common activity types

// NewStatusChangeActivity creates an activity for status changes.
func NewStatusChangeActivity(
	tenantID, findingID shared.ID,
	actorID *shared.ID,
	oldStatus, newStatus string,
	reason string,
	source ActivitySource,
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"old_status": oldStatus,
		"new_status": newStatus,
	}
	if reason != "" {
		changes["reason"] = reason
	}
	return NewFindingActivity(tenantID, findingID, ActivityStatusChanged, actorID, ActorTypeUser, changes, source, nil)
}

// NewSeverityChangeActivity creates an activity for severity changes.
func NewSeverityChangeActivity(
	tenantID, findingID shared.ID,
	actorID *shared.ID,
	oldSeverity, newSeverity string,
	source ActivitySource,
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"old_severity": oldSeverity,
		"new_severity": newSeverity,
	}
	return NewFindingActivity(tenantID, findingID, ActivitySeverityChanged, actorID, ActorTypeUser, changes, source, nil)
}

// NewAssignmentActivity creates an activity for assignment changes.
func NewAssignmentActivity(
	tenantID, findingID shared.ID,
	actorID *shared.ID,
	assigneeID, assigneeName, assigneeEmail string,
	source ActivitySource,
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"assignee_id":    assigneeID,
		"assignee_name":  assigneeName,
		"assignee_email": assigneeEmail,
	}
	return NewFindingActivity(tenantID, findingID, ActivityAssigned, actorID, ActorTypeUser, changes, source, nil)
}

// NewCommentActivity creates an activity for comment events.
// content is the full comment text, stored in changes for display.
func NewCommentActivity(
	tenantID, findingID shared.ID,
	actorID *shared.ID,
	activityType ActivityType, // comment_added, comment_updated, comment_deleted
	commentID string,
	content string,
	source ActivitySource,
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"comment_id": commentID,
	}
	if content != "" {
		// Store full content for display in activity feed
		changes["content"] = content
		// Also store preview for list views (truncated to 100 chars)
		preview := content
		if len(preview) > 100 {
			preview = preview[:100] + "..."
		}
		changes["preview"] = preview
	}
	return NewFindingActivity(tenantID, findingID, activityType, actorID, ActorTypeUser, changes, source, nil)
}

// NewScanDetectedActivity creates an activity for scan detections.
func NewScanDetectedActivity(
	tenantID, findingID shared.ID,
	scanID, scanner, scanType string,
	sourceMetadata map[string]interface{},
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"scan_id":   scanID,
		"scanner":   scanner,
		"scan_type": scanType,
	}
	return NewFindingActivity(tenantID, findingID, ActivityScanDetected, nil, ActorTypeScanner, changes, SourceCI, sourceMetadata)
}

// NewAITriageActivity creates an activity for AI triage events.
func NewAITriageActivity(
	tenantID, findingID shared.ID,
	triageResultID string,
	severityAssessment string,
	riskScore float64,
	priorityRank int,
	falsePositiveLikelihood float64,
	summary string,
	sourceMetadata map[string]interface{},
) (*FindingActivity, error) {
	// Determine risk level from risk score
	var riskLevel string
	switch {
	case riskScore >= 70:
		riskLevel = "critical"
	case riskScore >= 50:
		riskLevel = "high"
	case riskScore >= 30:
		riskLevel = "medium"
	default:
		riskLevel = "low"
	}

	// Confidence based on false positive likelihood (inverse)
	var confidence string
	switch {
	case falsePositiveLikelihood > 0.5:
		confidence = "low"
	case falsePositiveLikelihood > 0.2:
		confidence = "medium"
	default:
		confidence = "high"
	}

	changes := map[string]interface{}{
		"triage_result_id":  triageResultID,
		"severity":          severityAssessment,
		"risk_score":        riskScore,
		"priority_rank":     priorityRank,
		"ai_risk_level":     riskLevel,
		"ai_confidence":     confidence,
		"ai_recommendation": summary,
	}

	return NewFindingActivity(tenantID, findingID, ActivityAITriage, nil, ActorTypeAI, changes, SourceAuto, sourceMetadata)
}

// NewAITriageFailedActivity creates an activity for failed AI triage events.
func NewAITriageFailedActivity(
	tenantID, findingID shared.ID,
	triageResultID string,
	errorMessage string,
	sourceMetadata map[string]interface{},
) (*FindingActivity, error) {
	changes := map[string]interface{}{
		"triage_result_id": triageResultID,
		"status":           "failed",
		"error_message":    errorMessage,
	}

	return NewFindingActivity(tenantID, findingID, ActivityAITriageFailed, nil, ActorTypeSystem, changes, SourceAuto, sourceMetadata)
}
