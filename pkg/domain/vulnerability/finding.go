package vulnerability

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/openctemio/api/pkg/domain/shared"
)

// Finding represents a specific instance of a vulnerability in an asset.
//
//nolint:dupl // FindingData mirrors Finding fields for persistence - intentional DDD pattern
type Finding struct {
	id              shared.ID
	tenantID        shared.ID
	vulnerabilityID *shared.ID // Optional: may be linked to global CVE
	assetID         shared.ID  // Reference to parent asset (repository, host, etc.)
	branchID        *shared.ID // Optional: for repository assets, specific branch
	componentID     *shared.ID // Optional: vulnerability may be in a component

	// Tool information
	source      FindingSource
	toolName    string
	toolVersion string
	ruleID      string
	ruleName    string
	agentID     *shared.ID // ID of the agent that submitted this finding

	// Finding type discriminator (for polymorphic behavior)
	findingType FindingType // vulnerability, secret, misconfiguration, compliance, web3

	// Specialized finding details (extracted from metadata for queryability)
	// Secret details
	secretType          string
	secretService       string
	secretValid         *bool
	secretRevoked       *bool
	secretEntropy       *float64
	secretExpiresAt     *time.Time
	secretVerifiedAt    *time.Time
	secretRotationDueAt *time.Time
	secretAgeInDays     int
	secretScopes        []string
	secretMaskedValue   string
	secretInHistoryOnly bool
	secretCommitCount   int

	// Compliance details
	complianceFramework          string
	complianceControlID          string
	complianceControlName        string
	complianceResult             string
	complianceSection            string
	complianceFrameworkVersion   string
	complianceControlDescription string

	// Web3 details
	web3Chain             string
	web3ChainID           int64
	web3ContractAddress   string
	web3SWCID             string
	web3FunctionSignature string
	web3TxHash            string
	web3FunctionSelector  string
	web3BytecodeOffset    int

	// Misconfiguration details
	misconfigPolicyID     string
	misconfigPolicyName   string
	misconfigResourceType string
	misconfigResourceName string
	misconfigResourcePath string
	misconfigExpected     string
	misconfigActual       string
	misconfigCause        string

	// Data flows (normalized from stacks JSONB)
	dataFlows   []DataFlow
	hasDataFlow bool // Lightweight flag for list views (avoids loading full data flows)

	// Location information
	filePath         string
	startLine        int
	endLine          int
	startColumn      int
	endColumn        int
	snippet          string
	contextSnippet   string // Surrounding code for better understanding (Â±3 lines)
	contextStartLine int    // Line number where context begins

	// Content
	title       string
	description string
	message     string

	// Remediation (JSONB in database)
	remediation *FindingRemediation

	// Legacy field - kept for backward compatibility, prefer using remediation.Recommendation
	recommendation string

	// Classification
	severity   Severity
	cvssScore  *float64
	cvssVector string
	cveID      string
	cweIDs     []string
	owaspIDs   []string
	tags       []string

	// Workflow status
	// Note: Reasons for status changes are tracked in finding_activities.changes JSONB
	status     FindingStatus
	resolution string
	resolvedAt *time.Time
	resolvedBy *shared.ID // User who resolved (FK to users.id)

	// Assignment
	assignedTo *shared.ID
	assignedAt *time.Time
	assignedBy *shared.ID

	// Verification
	verifiedAt *time.Time
	verifiedBy *shared.ID

	// SLA
	slaDeadline *time.Time
	slaStatus   SLAStatus

	// Detection tracking
	firstDetectedAt     time.Time
	lastSeenAt          time.Time
	firstDetectedBranch string
	firstDetectedCommit string
	lastSeenBranch      string
	lastSeenCommit      string

	// Integration
	relatedIssueURL string
	relatedPRURL    string

	// Deduplication
	duplicateOf    *shared.ID
	duplicateCount int
	commentsCount  int

	// Closing (for verified/closed status)
	closedAt *time.Time
	closedBy *shared.ID

	// Risk acceptance expiration
	acceptanceExpiresAt *time.Time

	// Identification
	scanID      string
	fingerprint string

	// Metadata
	metadata  map[string]any
	createdAt time.Time
	updatedAt time.Time

	// CTEM: Exposure Vector
	exposureVector       ExposureVector // network, local, physical, adjacent_net
	isNetworkAccessible  bool           // Can be reached from network
	isInternetAccessible bool           // Directly internet-facing
	attackPrerequisites  string         // Auth required? MFA? etc.

	// CTEM: Remediation Context
	remediationType  RemediationType // patch, upgrade, workaround, config_change
	estimatedFixTime *int            // Minutes to fix (estimate)
	fixComplexity    FixComplexity   // simple, moderate, complex
	remedyAvailable  bool            // Is patch/fix available?
	fixCode          string          // Auto-fix code snippet (from SAST tools like Semgrep)
	fixRegex         *FixRegex       // Regex-based fix pattern

	// ASVS (Application Security Verification Standard) compliance
	asvsSection    string // ASVS section (e.g., "V2: Authentication")
	asvsControlID  string // Control ID (e.g., "2.1.1")
	asvsControlURL string // Link to ASVS documentation
	asvsLevel      *int   // ASVS level: 1, 2, or 3

	// CTEM: Business Impact
	dataExposureRisk   DataExposureRisk // none, low, medium, high, critical
	reputationalImpact bool
	complianceImpact   []string // Which compliance frameworks affected

	// SARIF 2.1.0 Fields
	confidence          *int              // 0-100 confidence score
	impact              string            // critical, high, medium, low
	likelihood          string            // high, medium, low
	vulnerabilityClass  []string          // SQL Injection, XSS, etc.
	subcategory         []string          // audit, vuln, secure default
	baselineState       string            // new, unchanged, updated, absent
	kind                string            // not_applicable, pass, fail, review, open, informational
	rank                *float64          // 0-100 priority score
	occurrenceCount     int               // Number of times observed
	correlationID       string            // Groups logically identical results
	partialFingerprints map[string]string // Contributing identity components
	relatedLocations    []FindingLocation // Additional related locations
	stacks              []StackTrace      // Call stacks
	attachments         []Attachment      // Artifacts or evidence
	workItemURIs        []string          // Associated issues/tickets
	hostedViewerURI     string            // URI to view in hosted viewer
}

// NewFinding creates a new Finding.
func NewFinding(
	tenantID shared.ID,
	assetID shared.ID,
	source FindingSource,
	toolName string,
	severity Severity,
	message string,
) (*Finding, error) {
	if tenantID.IsZero() {
		return nil, fmt.Errorf("%w: tenant id is required", shared.ErrValidation)
	}
	if assetID.IsZero() {
		return nil, fmt.Errorf("%w: asset id is required", shared.ErrValidation)
	}
	if !source.IsValid() {
		return nil, fmt.Errorf("%w: invalid source", shared.ErrValidation)
	}
	if toolName == "" {
		return nil, fmt.Errorf("%w: tool name is required", shared.ErrValidation)
	}
	if !severity.IsValid() {
		return nil, fmt.Errorf("%w: invalid severity", shared.ErrValidation)
	}

	now := time.Now().UTC()
	f := &Finding{
		id:              shared.NewID(),
		tenantID:        tenantID,
		assetID:         assetID,
		source:          source,
		toolName:        toolName,
		severity:        severity,
		message:         message,
		status:          FindingStatusNew, // Use new unified status
		slaStatus:       SLAStatusNotApplicable,
		cweIDs:          []string{},
		owaspIDs:        []string{},
		tags:            []string{},
		firstDetectedAt: now,
		lastSeenAt:      now,
		metadata:        make(map[string]any),
		createdAt:       now,
		updatedAt:       now,
		// CTEM defaults
		exposureVector:   ExposureVectorUnknown,
		remedyAvailable:  true,
		dataExposureRisk: DataExposureRiskNone,
		complianceImpact: []string{},
	}

	return f, nil
}

// FindingData contains all data needed to reconstitute a Finding from persistence.
//
//nolint:dupl // FindingData mirrors Finding fields for persistence - intentional DDD pattern
type FindingData struct {
	ID              shared.ID
	TenantID        shared.ID
	VulnerabilityID *shared.ID
	AssetID         shared.ID
	BranchID        *shared.ID
	ComponentID     *shared.ID

	// Tool
	Source      FindingSource
	ToolName    string
	ToolVersion string
	RuleID      string
	RuleName    string
	AgentID     *shared.ID

	// Finding type discriminator
	FindingType FindingType

	// Specialized finding details (extracted from metadata)
	// Secret details
	SecretType          string
	SecretService       string
	SecretValid         *bool
	SecretRevoked       *bool
	SecretEntropy       *float64
	SecretExpiresAt     *time.Time
	SecretVerifiedAt    *time.Time
	SecretRotationDueAt *time.Time
	SecretAgeInDays     int
	SecretScopes        []string
	SecretMaskedValue   string
	SecretInHistoryOnly bool
	SecretCommitCount   int

	// Compliance details
	ComplianceFramework          string
	ComplianceControlID          string
	ComplianceControlName        string
	ComplianceResult             string
	ComplianceSection            string
	ComplianceFrameworkVersion   string
	ComplianceControlDescription string

	// Web3 details
	Web3Chain             string
	Web3ChainID           int64
	Web3ContractAddress   string
	Web3SWCID             string
	Web3FunctionSignature string
	Web3TxHash            string
	Web3FunctionSelector  string
	Web3BytecodeOffset    int

	// Misconfiguration details
	MisconfigPolicyID     string
	MisconfigPolicyName   string
	MisconfigResourceType string
	MisconfigResourceName string
	MisconfigResourcePath string
	MisconfigExpected     string
	MisconfigActual       string
	MisconfigCause        string

	// Data flows
	DataFlows   []DataFlow
	HasDataFlow bool // Lightweight flag for list views

	// Location
	FilePath         string
	StartLine        int
	EndLine          int
	StartColumn      int
	EndColumn        int
	Snippet          string
	ContextSnippet   string
	ContextStartLine int

	// Content
	Title          string
	Description    string
	Message        string
	Recommendation string

	// Remediation (JSONB in database)
	Remediation *FindingRemediation

	// Classification
	Severity   Severity
	CVSSScore  *float64
	CVSSVector string
	CVEID      string
	CWEIDs     []string
	OWASPIDs   []string
	Tags       []string

	// Status
	// Note: Reasons for status changes are tracked in finding_activities.changes JSONB
	Status     FindingStatus
	Resolution string
	ResolvedAt *time.Time
	ResolvedBy *shared.ID // User who resolved (FK to users.id)

	// Assignment
	AssignedTo *shared.ID
	AssignedAt *time.Time
	AssignedBy *shared.ID

	// Verification
	VerifiedAt *time.Time
	VerifiedBy *shared.ID

	// SLA
	SLADeadline *time.Time
	SLAStatus   SLAStatus

	// Detection
	FirstDetectedAt     time.Time
	LastSeenAt          time.Time
	FirstDetectedBranch string
	FirstDetectedCommit string
	LastSeenBranch      string
	LastSeenCommit      string

	// Integration
	RelatedIssueURL string
	RelatedPRURL    string

	// Dedup
	DuplicateOf    *shared.ID
	DuplicateCount int
	CommentsCount  int

	// Closing (for verified/closed status)
	ClosedAt *time.Time
	ClosedBy *shared.ID

	// Risk acceptance expiration
	AcceptanceExpiresAt *time.Time

	// Identification
	ScanID      string
	Fingerprint string

	// Meta
	Metadata  map[string]any
	CreatedAt time.Time
	UpdatedAt time.Time

	// CTEM: Exposure Vector
	ExposureVector       ExposureVector
	IsNetworkAccessible  bool
	IsInternetAccessible bool
	AttackPrerequisites  string

	// CTEM: Remediation Context
	RemediationType  RemediationType
	EstimatedFixTime *int
	FixComplexity    FixComplexity
	RemedyAvailable  bool
	FixCode          string    // Auto-fix code snippet
	FixRegex         *FixRegex // Regex-based fix pattern

	// ASVS (Application Security Verification Standard) compliance
	ASVSSection    string
	ASVSControlID  string
	ASVSControlURL string
	ASVSLevel      *int

	// CTEM: Business Impact
	DataExposureRisk   DataExposureRisk
	ReputationalImpact bool
	ComplianceImpact   []string

	// SARIF 2.1.0 Fields
	Confidence          *int
	Impact              string
	Likelihood          string
	VulnerabilityClass  []string
	Subcategory         []string
	BaselineState       string
	Kind                string
	Rank                *float64
	OccurrenceCount     int
	CorrelationID       string
	PartialFingerprints map[string]string
	RelatedLocations    []FindingLocation
	Stacks              []StackTrace
	Attachments         []Attachment
	WorkItemURIs        []string
	HostedViewerURI     string
}

// ReconstituteFinding recreates a Finding from persistence.
func ReconstituteFinding(data FindingData) *Finding {
	if data.Metadata == nil {
		data.Metadata = make(map[string]any)
	}
	if data.CWEIDs == nil {
		data.CWEIDs = []string{}
	}
	if data.OWASPIDs == nil {
		data.OWASPIDs = []string{}
	}
	if data.Tags == nil {
		data.Tags = []string{}
	}
	if data.ComplianceImpact == nil {
		data.ComplianceImpact = []string{}
	}
	// Set CTEM defaults if not provided
	if data.ExposureVector == "" {
		data.ExposureVector = ExposureVectorUnknown
	}
	if data.DataExposureRisk == "" {
		data.DataExposureRisk = DataExposureRiskNone
	}
	// Initialize SARIF slice fields
	if data.VulnerabilityClass == nil {
		data.VulnerabilityClass = []string{}
	}
	if data.Subcategory == nil {
		data.Subcategory = []string{}
	}
	if data.PartialFingerprints == nil {
		data.PartialFingerprints = make(map[string]string)
	}
	if data.RelatedLocations == nil {
		data.RelatedLocations = []FindingLocation{}
	}
	if data.Stacks == nil {
		data.Stacks = []StackTrace{}
	}
	if data.Attachments == nil {
		data.Attachments = []Attachment{}
	}
	if data.WorkItemURIs == nil {
		data.WorkItemURIs = []string{}
	}
	if data.OccurrenceCount == 0 {
		data.OccurrenceCount = 1
	}

	return &Finding{
		id:                  data.ID,
		tenantID:            data.TenantID,
		vulnerabilityID:     data.VulnerabilityID,
		assetID:             data.AssetID,
		branchID:            data.BranchID,
		componentID:         data.ComponentID,
		source:              data.Source,
		toolName:            data.ToolName,
		toolVersion:         data.ToolVersion,
		ruleID:              data.RuleID,
		ruleName:            data.RuleName,
		agentID:             data.AgentID,
		filePath:            data.FilePath,
		startLine:           data.StartLine,
		endLine:             data.EndLine,
		startColumn:         data.StartColumn,
		endColumn:           data.EndColumn,
		snippet:             data.Snippet,
		contextSnippet:      data.ContextSnippet,
		contextStartLine:    data.ContextStartLine,
		title:               data.Title,
		description:         data.Description,
		message:             data.Message,
		recommendation:      data.Recommendation,
		remediation:         data.Remediation,
		severity:            data.Severity,
		cvssScore:           data.CVSSScore,
		cvssVector:          data.CVSSVector,
		cveID:               data.CVEID,
		cweIDs:              data.CWEIDs,
		owaspIDs:            data.OWASPIDs,
		tags:                data.Tags,
		status:              data.Status,
		resolution:          data.Resolution,
		resolvedAt:          data.ResolvedAt,
		resolvedBy:          data.ResolvedBy,
		assignedTo:          data.AssignedTo,
		assignedAt:          data.AssignedAt,
		assignedBy:          data.AssignedBy,
		verifiedAt:          data.VerifiedAt,
		verifiedBy:          data.VerifiedBy,
		slaDeadline:         data.SLADeadline,
		slaStatus:           data.SLAStatus,
		firstDetectedAt:     data.FirstDetectedAt,
		lastSeenAt:          data.LastSeenAt,
		firstDetectedBranch: data.FirstDetectedBranch,
		firstDetectedCommit: data.FirstDetectedCommit,
		lastSeenBranch:      data.LastSeenBranch,
		lastSeenCommit:      data.LastSeenCommit,
		relatedIssueURL:     data.RelatedIssueURL,
		relatedPRURL:        data.RelatedPRURL,
		duplicateOf:         data.DuplicateOf,
		duplicateCount:      data.DuplicateCount,
		commentsCount:       data.CommentsCount,
		closedAt:            data.ClosedAt,
		closedBy:            data.ClosedBy,
		acceptanceExpiresAt: data.AcceptanceExpiresAt,
		scanID:              data.ScanID,
		fingerprint:         data.Fingerprint,
		metadata:            data.Metadata,
		createdAt:           data.CreatedAt,
		updatedAt:           data.UpdatedAt,
		// CTEM fields
		exposureVector:       data.ExposureVector,
		isNetworkAccessible:  data.IsNetworkAccessible,
		isInternetAccessible: data.IsInternetAccessible,
		attackPrerequisites:  data.AttackPrerequisites,
		remediationType:      data.RemediationType,
		estimatedFixTime:     data.EstimatedFixTime,
		fixComplexity:        data.FixComplexity,
		remedyAvailable:      data.RemedyAvailable,
		fixCode:              data.FixCode,
		fixRegex:             data.FixRegex,
		asvsSection:          data.ASVSSection,
		asvsControlID:        data.ASVSControlID,
		asvsControlURL:       data.ASVSControlURL,
		asvsLevel:            data.ASVSLevel,
		dataExposureRisk:     data.DataExposureRisk,
		reputationalImpact:   data.ReputationalImpact,
		complianceImpact:     data.ComplianceImpact,
		// SARIF 2.1.0 fields
		confidence:          data.Confidence,
		impact:              data.Impact,
		likelihood:          data.Likelihood,
		vulnerabilityClass:  data.VulnerabilityClass,
		subcategory:         data.Subcategory,
		baselineState:       data.BaselineState,
		kind:                data.Kind,
		rank:                data.Rank,
		occurrenceCount:     data.OccurrenceCount,
		correlationID:       data.CorrelationID,
		partialFingerprints: data.PartialFingerprints,
		relatedLocations:    data.RelatedLocations,
		stacks:              data.Stacks,
		attachments:         data.Attachments,
		workItemURIs:        data.WorkItemURIs,
		hostedViewerURI:     data.HostedViewerURI,
		// Finding type discriminator
		findingType: data.FindingType,
		// Specialized finding details - Secret
		secretType:          data.SecretType,
		secretService:       data.SecretService,
		secretValid:         data.SecretValid,
		secretRevoked:       data.SecretRevoked,
		secretEntropy:       data.SecretEntropy,
		secretExpiresAt:     data.SecretExpiresAt,
		secretVerifiedAt:    data.SecretVerifiedAt,
		secretRotationDueAt: data.SecretRotationDueAt,
		secretAgeInDays:     data.SecretAgeInDays,
		secretScopes:        data.SecretScopes,
		secretMaskedValue:   data.SecretMaskedValue,
		secretInHistoryOnly: data.SecretInHistoryOnly,
		secretCommitCount:   data.SecretCommitCount,
		// Specialized finding details - Compliance
		complianceFramework:          data.ComplianceFramework,
		complianceControlID:          data.ComplianceControlID,
		complianceControlName:        data.ComplianceControlName,
		complianceResult:             data.ComplianceResult,
		complianceSection:            data.ComplianceSection,
		complianceFrameworkVersion:   data.ComplianceFrameworkVersion,
		complianceControlDescription: data.ComplianceControlDescription,
		// Specialized finding details - Web3
		web3Chain:             data.Web3Chain,
		web3ChainID:           data.Web3ChainID,
		web3ContractAddress:   data.Web3ContractAddress,
		web3SWCID:             data.Web3SWCID,
		web3FunctionSignature: data.Web3FunctionSignature,
		web3TxHash:            data.Web3TxHash,
		web3FunctionSelector:  data.Web3FunctionSelector,
		web3BytecodeOffset:    data.Web3BytecodeOffset,
		// Specialized finding details - Misconfiguration
		misconfigPolicyID:     data.MisconfigPolicyID,
		misconfigPolicyName:   data.MisconfigPolicyName,
		misconfigResourceType: data.MisconfigResourceType,
		misconfigResourceName: data.MisconfigResourceName,
		misconfigResourcePath: data.MisconfigResourcePath,
		misconfigExpected:     data.MisconfigExpected,
		misconfigActual:       data.MisconfigActual,
		misconfigCause:        data.MisconfigCause,
		// Data flows
		dataFlows:   data.DataFlows,
		hasDataFlow: data.HasDataFlow || len(data.DataFlows) > 0,
	}
}

// Getters

// ID returns the finding ID.
func (f *Finding) ID() shared.ID {
	return f.id
}

// TenantID returns the tenant ID.
func (f *Finding) TenantID() shared.ID {
	return f.tenantID
}

// VulnerabilityID returns the vulnerability ID.
func (f *Finding) VulnerabilityID() *shared.ID {
	return f.vulnerabilityID
}

// AssetID returns the asset ID.
func (f *Finding) AssetID() shared.ID {
	return f.assetID
}

// BranchID returns the branch ID.
func (f *Finding) BranchID() *shared.ID {
	return f.branchID
}

// ComponentID returns the component ID.
func (f *Finding) ComponentID() *shared.ID {
	return f.componentID
}

// Source returns the finding source.
func (f *Finding) Source() FindingSource {
	return f.source
}

// ToolName returns the tool name.
func (f *Finding) ToolName() string {
	return f.toolName
}

// ToolVersion returns the tool version.
func (f *Finding) ToolVersion() string {
	return f.toolVersion
}

// RuleID returns the rule ID.
func (f *Finding) RuleID() string {
	return f.ruleID
}

// RuleName returns the rule name.
func (f *Finding) RuleName() string {
	return f.ruleName
}

// AgentID returns the agent ID that submitted this finding.
func (f *Finding) AgentID() *shared.ID {
	return f.agentID
}

// FindingType returns the finding type discriminator.
func (f *Finding) FindingType() FindingType {
	return f.findingType
}

// SecretType returns the secret type (for secret findings).
func (f *Finding) SecretType() string {
	return f.secretType
}

// SecretService returns the secret service (for secret findings).
func (f *Finding) SecretService() string {
	return f.secretService
}

// SecretValid returns whether the secret is valid (for secret findings).
func (f *Finding) SecretValid() *bool {
	return f.secretValid
}

// SecretRevoked returns whether the secret has been revoked (for secret findings).
func (f *Finding) SecretRevoked() *bool {
	return f.secretRevoked
}

// SecretEntropy returns the secret entropy (for secret findings).
func (f *Finding) SecretEntropy() *float64 {
	return f.secretEntropy
}

// SecretExpiresAt returns the secret expiration time (for secret findings).
func (f *Finding) SecretExpiresAt() *time.Time {
	return f.secretExpiresAt
}

// SecretVerifiedAt returns when the secret was verified (for secret findings).
func (f *Finding) SecretVerifiedAt() *time.Time {
	return f.secretVerifiedAt
}

// SecretRotationDueAt returns when the secret rotation is due (for secret findings).
func (f *Finding) SecretRotationDueAt() *time.Time {
	return f.secretRotationDueAt
}

// SecretAgeInDays returns the age of the secret in days (for secret findings).
func (f *Finding) SecretAgeInDays() int {
	return f.secretAgeInDays
}

// SecretScopes returns the secret scopes/permissions (for secret findings).
func (f *Finding) SecretScopes() []string {
	if f.secretScopes == nil {
		return nil
	}
	result := make([]string, len(f.secretScopes))
	copy(result, f.secretScopes)
	return result
}

// SecretMaskedValue returns the masked value of the secret (for secret findings).
func (f *Finding) SecretMaskedValue() string {
	return f.secretMaskedValue
}

// SecretInHistoryOnly returns whether the secret is only in git history (for secret findings).
func (f *Finding) SecretInHistoryOnly() bool {
	return f.secretInHistoryOnly
}

// SecretCommitCount returns the number of commits containing this secret (for secret findings).
func (f *Finding) SecretCommitCount() int {
	return f.secretCommitCount
}

// ComplianceFramework returns the compliance framework (for compliance findings).
func (f *Finding) ComplianceFramework() string {
	return f.complianceFramework
}

// ComplianceControlID returns the compliance control ID (for compliance findings).
func (f *Finding) ComplianceControlID() string {
	return f.complianceControlID
}

// ComplianceControlName returns the compliance control name (for compliance findings).
func (f *Finding) ComplianceControlName() string {
	return f.complianceControlName
}

// ComplianceResult returns the compliance result (for compliance findings).
func (f *Finding) ComplianceResult() string {
	return f.complianceResult
}

// ComplianceSection returns the compliance section (for compliance findings).
func (f *Finding) ComplianceSection() string {
	return f.complianceSection
}

// ComplianceFrameworkVersion returns the compliance framework version (for compliance findings).
func (f *Finding) ComplianceFrameworkVersion() string {
	return f.complianceFrameworkVersion
}

// ComplianceControlDescription returns the compliance control description (for compliance findings).
func (f *Finding) ComplianceControlDescription() string {
	return f.complianceControlDescription
}

// Web3Chain returns the blockchain chain (for web3 findings).
func (f *Finding) Web3Chain() string {
	return f.web3Chain
}

// Web3ChainID returns the blockchain chain ID (for web3 findings).
func (f *Finding) Web3ChainID() int64 {
	return f.web3ChainID
}

// Web3ContractAddress returns the smart contract address (for web3 findings).
func (f *Finding) Web3ContractAddress() string {
	return f.web3ContractAddress
}

// Web3SWCID returns the SWC ID (for web3 findings).
func (f *Finding) Web3SWCID() string {
	return f.web3SWCID
}

// Web3FunctionSignature returns the function signature (for web3 findings).
func (f *Finding) Web3FunctionSignature() string {
	return f.web3FunctionSignature
}

// Web3TxHash returns the transaction hash (for web3 findings).
func (f *Finding) Web3TxHash() string {
	return f.web3TxHash
}

// Web3FunctionSelector returns the function selector (for web3 findings).
func (f *Finding) Web3FunctionSelector() string {
	return f.web3FunctionSelector
}

// Web3BytecodeOffset returns the bytecode offset (for web3 findings).
func (f *Finding) Web3BytecodeOffset() int {
	return f.web3BytecodeOffset
}

// MisconfigPolicyID returns the misconfiguration policy ID.
func (f *Finding) MisconfigPolicyID() string {
	return f.misconfigPolicyID
}

// MisconfigResourceType returns the misconfiguration resource type.
func (f *Finding) MisconfigResourceType() string {
	return f.misconfigResourceType
}

// MisconfigResourceName returns the misconfiguration resource name.
func (f *Finding) MisconfigResourceName() string {
	return f.misconfigResourceName
}

// MisconfigResourcePath returns the misconfiguration resource path.
func (f *Finding) MisconfigResourcePath() string {
	return f.misconfigResourcePath
}

// MisconfigExpected returns the expected configuration value.
func (f *Finding) MisconfigExpected() string {
	return f.misconfigExpected
}

// MisconfigActual returns the actual configuration value.
func (f *Finding) MisconfigActual() string {
	return f.misconfigActual
}

// MisconfigPolicyName returns the misconfiguration policy name.
func (f *Finding) MisconfigPolicyName() string {
	return f.misconfigPolicyName
}

// MisconfigCause returns the misconfiguration cause/reason.
func (f *Finding) MisconfigCause() string {
	return f.misconfigCause
}

// DataFlows returns the data flows (for SAST taint tracking).
func (f *Finding) DataFlows() []DataFlow {
	if f.dataFlows == nil {
		return nil
	}
	flows := make([]DataFlow, len(f.dataFlows))
	copy(flows, f.dataFlows)
	return flows
}

// HasDataFlow returns true if this finding has data flow traces.
// This is a lightweight flag populated from database for list views.
func (f *Finding) HasDataFlow() bool {
	// If dataFlows is populated, use that
	if len(f.dataFlows) > 0 {
		return true
	}
	// Otherwise use the flag (populated by repository)
	return f.hasDataFlow
}

// SetHasDataFlow sets the hasDataFlow flag (used by repository for list views).
func (f *Finding) SetHasDataFlow(has bool) {
	f.hasDataFlow = has
}

// FilePath returns the file path.
func (f *Finding) FilePath() string {
	return f.filePath
}

// StartLine returns the start line.
func (f *Finding) StartLine() int {
	return f.startLine
}

// EndLine returns the end line.
func (f *Finding) EndLine() int {
	return f.endLine
}

// StartColumn returns the start column.
func (f *Finding) StartColumn() int {
	return f.startColumn
}

// EndColumn returns the end column.
func (f *Finding) EndColumn() int {
	return f.endColumn
}

// Snippet returns the code snippet.
func (f *Finding) Snippet() string {
	return f.snippet
}

// Message returns the message.
func (f *Finding) Message() string {
	return f.message
}

// Title returns the title.
func (f *Finding) Title() string {
	return f.title
}

// Description returns the description.
func (f *Finding) Description() string {
	return f.description
}

// Recommendation returns the recommendation.
func (f *Finding) Recommendation() string {
	return f.recommendation
}

// Remediation returns the remediation JSONB object.
func (f *Finding) Remediation() *FindingRemediation {
	return f.remediation
}

// SetRemediation sets the remediation JSONB object.
func (f *Finding) SetRemediation(r *FindingRemediation) {
	f.remediation = r
	f.updatedAt = time.Now().UTC()
}

// CVSSScore returns the CVSS score.
func (f *Finding) CVSSScore() *float64 {
	return f.cvssScore
}

// CVSSVector returns the CVSS vector.
func (f *Finding) CVSSVector() string {
	return f.cvssVector
}

// CVEID returns the CVE ID.
func (f *Finding) CVEID() string {
	return f.cveID
}

// CWEIDs returns the CWE IDs.
func (f *Finding) CWEIDs() []string {
	result := make([]string, len(f.cweIDs))
	copy(result, f.cweIDs)
	return result
}

// OWASPIDs returns the OWASP IDs.
func (f *Finding) OWASPIDs() []string {
	result := make([]string, len(f.owaspIDs))
	copy(result, f.owaspIDs)
	return result
}

// Tags returns the tags.
func (f *Finding) Tags() []string {
	result := make([]string, len(f.tags))
	copy(result, f.tags)
	return result
}

// IsTriaged returns true if the finding has been triaged (status != new).
func (f *Finding) IsTriaged() bool {
	return f.status != FindingStatusNew
}

// AssignedTo returns who the finding is assigned to.
func (f *Finding) AssignedTo() *shared.ID {
	return f.assignedTo
}

// AssignedAt returns when the finding was assigned.
func (f *Finding) AssignedAt() *time.Time {
	return f.assignedAt
}

// AssignedBy returns who assigned the finding.
func (f *Finding) AssignedBy() *shared.ID {
	return f.assignedBy
}

// VerifiedAt returns when the fix was verified.
func (f *Finding) VerifiedAt() *time.Time {
	return f.verifiedAt
}

// VerifiedBy returns who verified the fix.
func (f *Finding) VerifiedBy() *shared.ID {
	return f.verifiedBy
}

// SLADeadline returns the SLA deadline.
func (f *Finding) SLADeadline() *time.Time {
	return f.slaDeadline
}

// SLAStatus returns the SLA status.
func (f *Finding) SLAStatus() SLAStatus {
	return f.slaStatus
}

// FirstDetectedAt returns when the finding was first detected.
func (f *Finding) FirstDetectedAt() time.Time {
	return f.firstDetectedAt
}

// LastSeenAt returns when the finding was last seen.
func (f *Finding) LastSeenAt() time.Time {
	return f.lastSeenAt
}

// FirstDetectedBranch returns the branch where first detected.
func (f *Finding) FirstDetectedBranch() string {
	return f.firstDetectedBranch
}

// FirstDetectedCommit returns the commit where first detected.
func (f *Finding) FirstDetectedCommit() string {
	return f.firstDetectedCommit
}

// LastSeenBranch returns the branch where last seen.
func (f *Finding) LastSeenBranch() string {
	return f.lastSeenBranch
}

// LastSeenCommit returns the commit where last seen.
func (f *Finding) LastSeenCommit() string {
	return f.lastSeenCommit
}

// RelatedIssueURL returns the related issue URL.
func (f *Finding) RelatedIssueURL() string {
	return f.relatedIssueURL
}

// RelatedPRURL returns the related PR URL.
func (f *Finding) RelatedPRURL() string {
	return f.relatedPRURL
}

// DuplicateOf returns the ID of the finding this is a duplicate of.
func (f *Finding) DuplicateOf() *shared.ID {
	return f.duplicateOf
}

// DuplicateCount returns the number of duplicates.
func (f *Finding) DuplicateCount() int {
	return f.duplicateCount
}

// CommentsCount returns the number of comments.
func (f *Finding) CommentsCount() int {
	return f.commentsCount
}

// Severity returns the severity.
func (f *Finding) Severity() Severity {
	return f.severity
}

// Status returns the status.
func (f *Finding) Status() FindingStatus {
	return f.status
}

// Resolution returns the resolution.
func (f *Finding) Resolution() string {
	return f.resolution
}

// ResolvedAt returns the resolved time.
func (f *Finding) ResolvedAt() *time.Time {
	return f.resolvedAt
}

// ResolvedBy returns who resolved the finding.
func (f *Finding) ResolvedBy() *shared.ID {
	return f.resolvedBy
}

// ClosedAt returns the closed time.
func (f *Finding) ClosedAt() *time.Time {
	return f.closedAt
}

// ClosedBy returns who closed the finding.
func (f *Finding) ClosedBy() *shared.ID {
	return f.closedBy
}

// AcceptanceExpiresAt returns when the risk acceptance expires.
func (f *Finding) AcceptanceExpiresAt() *time.Time {
	return f.acceptanceExpiresAt
}

// ScanID returns the scan ID.
func (f *Finding) ScanID() string {
	return f.scanID
}

// Fingerprint returns the fingerprint.
func (f *Finding) Fingerprint() string {
	return f.fingerprint
}

// Metadata returns a copy of the metadata.
func (f *Finding) Metadata() map[string]any {
	metadata := make(map[string]any, len(f.metadata))
	for k, v := range f.metadata {
		metadata[k] = v
	}
	return metadata
}

// CreatedAt returns the creation time.
func (f *Finding) CreatedAt() time.Time {
	return f.createdAt
}

// UpdatedAt returns the last update time.
func (f *Finding) UpdatedAt() time.Time {
	return f.updatedAt
}

// Mutators

// SetVulnerabilityID sets the vulnerability ID.
func (f *Finding) SetVulnerabilityID(id shared.ID) {
	f.vulnerabilityID = &id
	f.updatedAt = time.Now().UTC()
}

// SetBranchID sets the branch ID.
func (f *Finding) SetBranchID(id shared.ID) {
	f.branchID = &id
	f.updatedAt = time.Now().UTC()
}

// SetComponentID sets the component ID.
func (f *Finding) SetComponentID(id shared.ID) {
	f.componentID = &id
	f.updatedAt = time.Now().UTC()
}

// SetToolVersion sets the tool version.
func (f *Finding) SetToolVersion(version string) {
	f.toolVersion = version
	f.updatedAt = time.Now().UTC()
}

// SetRuleID sets the rule ID.
func (f *Finding) SetRuleID(ruleID string) {
	f.ruleID = ruleID
	f.updatedAt = time.Now().UTC()
}

// SetRuleName sets the rule name.
func (f *Finding) SetRuleName(ruleName string) {
	f.ruleName = ruleName
	f.updatedAt = time.Now().UTC()
}

// SetAgentID sets the agent ID that submitted this finding.
func (f *Finding) SetAgentID(agentID shared.ID) {
	f.agentID = &agentID
	f.updatedAt = time.Now().UTC()
}

// SetTitle sets the title.
func (f *Finding) SetTitle(title string) {
	f.title = title
	f.updatedAt = time.Now().UTC()
}

// SetDescription sets the description.
func (f *Finding) SetDescription(description string) {
	f.description = description
	f.updatedAt = time.Now().UTC()
}

// SetRecommendation sets the recommendation.
func (f *Finding) SetRecommendation(recommendation string) {
	f.recommendation = recommendation
	f.updatedAt = time.Now().UTC()
}

// SetClassification sets the CVE/CWE/CVSS classification.
func (f *Finding) SetClassification(cveID string, cvssScore *float64, cvssVector string, cweIDs, owaspIDs []string) error {
	if cvssScore != nil && (*cvssScore < 0 || *cvssScore > 10) {
		return fmt.Errorf("%w: CVSS score must be between 0.0 and 10.0", shared.ErrValidation)
	}
	f.cveID = cveID
	f.cvssScore = cvssScore
	f.cvssVector = cvssVector
	if cweIDs != nil {
		f.cweIDs = make([]string, len(cweIDs))
		copy(f.cweIDs, cweIDs)
	}
	if owaspIDs != nil {
		f.owaspIDs = make([]string, len(owaspIDs))
		copy(f.owaspIDs, owaspIDs)
	}
	f.updatedAt = time.Now().UTC()
	return nil
}

// SetTags sets the tags.
func (f *Finding) SetTags(tags []string) {
	f.tags = make([]string, len(tags))
	copy(f.tags, tags)
	f.updatedAt = time.Now().UTC()
}

// AddTag adds a tag.
func (f *Finding) AddTag(tag string) {
	for _, t := range f.tags {
		if t == tag {
			return
		}
	}
	f.tags = append(f.tags, tag)
	f.updatedAt = time.Now().UTC()
}

// RemoveTag removes a tag.
func (f *Finding) RemoveTag(tag string) {
	for i, t := range f.tags {
		if t == tag {
			f.tags = append(f.tags[:i], f.tags[i+1:]...)
			f.updatedAt = time.Now().UTC()
			return
		}
	}
}

// SetLocation sets the file location.
func (f *Finding) SetLocation(filePath string, startLine, endLine, startColumn, endColumn int) {
	f.filePath = filePath
	f.startLine = startLine
	f.endLine = endLine
	f.startColumn = startColumn
	f.endColumn = endColumn
	f.updatedAt = time.Now().UTC()
}

// SetSnippet sets the code snippet.
func (f *Finding) SetSnippet(snippet string) {
	f.snippet = snippet
	f.updatedAt = time.Now().UTC()
}

// ContextSnippet returns the surrounding code context.
func (f *Finding) ContextSnippet() string {
	return f.contextSnippet
}

// SetContextSnippet sets the surrounding code context.
func (f *Finding) SetContextSnippet(snippet string) {
	f.contextSnippet = snippet
	f.updatedAt = time.Now().UTC()
}

// ContextStartLine returns the line number where context begins.
func (f *Finding) ContextStartLine() int {
	return f.contextStartLine
}

// SetContextStartLine sets the line number where context begins.
func (f *Finding) SetContextStartLine(line int) {
	f.contextStartLine = line
	f.updatedAt = time.Now().UTC()
}

// SetFirstDetectedBranch sets the branch where the finding was first detected.
func (f *Finding) SetFirstDetectedBranch(branch string) {
	f.firstDetectedBranch = branch
	f.updatedAt = time.Now().UTC()
}

// SetFirstDetectedCommit sets the commit where the finding was first detected.
func (f *Finding) SetFirstDetectedCommit(commit string) {
	f.firstDetectedCommit = commit
	f.updatedAt = time.Now().UTC()
}

// SetLastSeenBranch sets the branch where the finding was last seen.
func (f *Finding) SetLastSeenBranch(branch string) {
	f.lastSeenBranch = branch
	f.updatedAt = time.Now().UTC()
}

// SetLastSeenCommit sets the commit where the finding was last seen.
func (f *Finding) SetLastSeenCommit(commit string) {
	f.lastSeenCommit = commit
	f.updatedAt = time.Now().UTC()
}

// SetBranchInfo sets branch tracking information.
// Note: isDefaultBranch is determined by branch_id FK to asset_branches.is_default, not stored on finding.
func (f *Finding) SetBranchInfo(branchName string, commitSHA string) {
	now := time.Now().UTC()

	// Set first detected branch if not already set
	if f.firstDetectedBranch == "" {
		f.firstDetectedBranch = branchName
		f.firstDetectedCommit = commitSHA
	}

	// Always update last seen
	f.lastSeenBranch = branchName
	f.lastSeenCommit = commitSHA
	f.lastSeenAt = now
	f.updatedAt = now
}

// UpdateMessage updates the message.
func (f *Finding) UpdateMessage(message string) {
	f.message = message
	f.updatedAt = time.Now().UTC()
}

// UpdateSeverity updates the severity.
func (f *Finding) UpdateSeverity(severity Severity) error {
	if !severity.IsValid() {
		return fmt.Errorf("%w: invalid severity", shared.ErrValidation)
	}
	f.severity = severity
	f.updatedAt = time.Now().UTC()
	return nil
}

// CanTransitionTo checks if the finding can transition to the given status.
// Uses the ValidStatusTransitions defined in value_objects.go
func (f *Finding) CanTransitionTo(newStatus FindingStatus) bool {
	if f.status == newStatus {
		return true // No change
	}
	return f.status.CanTransitionTo(newStatus)
}

// UpdateStatus updates the status with optional resolution.
func (f *Finding) UpdateStatus(status FindingStatus, resolution string, resolvedBy *shared.ID) error {
	if !status.IsValid() {
		return fmt.Errorf("%w: invalid status", shared.ErrValidation)
	}
	f.status = status
	f.resolution = resolution

	if status.IsClosed() {
		now := time.Now().UTC()
		f.resolvedAt = &now
		f.resolvedBy = resolvedBy
	} else {
		f.resolvedAt = nil
		f.resolvedBy = nil
	}
	f.updatedAt = time.Now().UTC()
	return nil
}

// UpdateStatusWithReason updates the status. Reason should be recorded in finding_activities.
// This is a convenience method that calls UpdateStatus - reason tracking is handled by the service layer.
func (f *Finding) UpdateStatusWithReason(status FindingStatus, _ /* reason tracked in activities */, resolution string, resolvedBy *shared.ID) error {
	return f.UpdateStatus(status, resolution, resolvedBy)
}

// TransitionStatus transitions the status with workflow validation.
func (f *Finding) TransitionStatus(newStatus FindingStatus, resolution string, actorID *shared.ID) error {
	if !newStatus.IsValid() {
		return fmt.Errorf("%w: invalid status: %s", shared.ErrValidation, newStatus)
	}
	if !f.CanTransitionTo(newStatus) {
		return fmt.Errorf("%w: cannot transition from %s to %s", shared.ErrValidation, f.status, newStatus)
	}
	return f.UpdateStatus(newStatus, resolution, actorID)
}

// Assign assigns the finding to a user.
func (f *Finding) Assign(userID, assignerID shared.ID) error {
	if userID.IsZero() {
		return fmt.Errorf("%w: user id is required", shared.ErrValidation)
	}
	now := time.Now().UTC()
	f.assignedTo = &userID
	f.assignedAt = &now
	if !assignerID.IsZero() {
		f.assignedBy = &assignerID
	}
	f.updatedAt = now
	return nil
}

// Unassign removes the assignment.
func (f *Finding) Unassign() {
	f.assignedTo = nil
	f.assignedAt = nil
	f.assignedBy = nil
	f.updatedAt = time.Now().UTC()
}

// Verify marks the finding fix as verified.
func (f *Finding) Verify(verifiedBy shared.ID) error {
	if !f.IsClosed() {
		return fmt.Errorf("%w: cannot verify a finding that is not closed", shared.ErrValidation)
	}
	now := time.Now().UTC()
	f.verifiedAt = &now
	f.verifiedBy = &verifiedBy
	f.updatedAt = now
	return nil
}

// SetSLADeadline sets the SLA deadline.
func (f *Finding) SetSLADeadline(deadline time.Time) {
	f.slaDeadline = &deadline
	f.UpdateSLAStatus()
	f.updatedAt = time.Now().UTC()
}

// UpdateSLAStatus updates the SLA status based on current time and deadline.
func (f *Finding) UpdateSLAStatus() {
	if f.slaDeadline == nil {
		f.slaStatus = SLAStatusNotApplicable
		return
	}
	if f.IsClosed() {
		if f.resolvedAt != nil && f.resolvedAt.Before(*f.slaDeadline) {
			f.slaStatus = SLAStatusOnTrack
		} else {
			f.slaStatus = SLAStatusExceeded
		}
		return
	}
	now := time.Now().UTC()
	remaining := f.slaDeadline.Sub(now)
	switch {
	case remaining < 0:
		f.slaStatus = SLAStatusOverdue
	case remaining < 24*time.Hour:
		f.slaStatus = SLAStatusWarning
	default:
		f.slaStatus = SLAStatusOnTrack
	}
}

// UpdateLastSeen updates the last seen tracking.
func (f *Finding) UpdateLastSeen(branch, commit string) {
	now := time.Now().UTC()
	f.lastSeenAt = now
	f.lastSeenBranch = branch
	f.lastSeenCommit = commit
	f.updatedAt = now
}

// SetRelatedIssue sets the related issue URL.
func (f *Finding) SetRelatedIssue(url string) {
	f.relatedIssueURL = url
	f.updatedAt = time.Now().UTC()
}

// SetRelatedPR sets the related PR URL.
func (f *Finding) SetRelatedPR(url string) {
	f.relatedPRURL = url
	f.updatedAt = time.Now().UTC()
}

// MarkAsDuplicate marks the finding as a duplicate.
func (f *Finding) MarkAsDuplicate(originalID shared.ID) error {
	if originalID.IsZero() {
		return fmt.Errorf("%w: original finding id is required", shared.ErrValidation)
	}
	if originalID == f.id {
		return fmt.Errorf("%w: finding cannot be duplicate of itself", shared.ErrValidation)
	}
	f.duplicateOf = &originalID
	f.status = FindingStatusDuplicate
	f.updatedAt = time.Now().UTC()
	return nil
}

// IncrementDuplicateCount increments the duplicate count.
func (f *Finding) IncrementDuplicateCount() {
	f.duplicateCount++
	f.updatedAt = time.Now().UTC()
}

// IncrementCommentsCount increments the comments count.
func (f *Finding) IncrementCommentsCount() {
	f.commentsCount++
	f.updatedAt = time.Now().UTC()
}

// DecrementCommentsCount decrements the comments count.
func (f *Finding) DecrementCommentsCount() {
	if f.commentsCount > 0 {
		f.commentsCount--
		f.updatedAt = time.Now().UTC()
	}
}

// SetScanID sets the scan ID.
func (f *Finding) SetScanID(scanID string) {
	f.scanID = scanID
	f.updatedAt = time.Now().UTC()
}

// SetFingerprint sets the fingerprint.
func (f *Finding) SetFingerprint(fingerprint string) {
	f.fingerprint = fingerprint
	f.updatedAt = time.Now().UTC()
}

// GenerateFingerprint generates a fingerprint based on finding attributes.
func (f *Finding) GenerateFingerprint() string {
	h := sha256.New()
	h.Write([]byte(f.assetID.String()))
	h.Write([]byte(f.ruleID))
	h.Write([]byte(f.filePath))
	fmt.Fprintf(h, "%d", f.startLine)
	h.Write([]byte(f.message))
	fingerprint := hex.EncodeToString(h.Sum(nil))[:32]
	f.fingerprint = fingerprint
	return fingerprint
}

// SetMetadata sets a metadata key-value pair.
func (f *Finding) SetMetadata(key string, value any) {
	f.metadata[key] = value
	f.updatedAt = time.Now().UTC()
}

// DeleteMetadata removes a metadata key.
func (f *Finding) DeleteMetadata(key string) {
	delete(f.metadata, key)
	f.updatedAt = time.Now().UTC()
}

// Helper methods

// IsOpen checks if the finding is open.
func (f *Finding) IsOpen() bool {
	return f.status.IsOpen()
}

// IsClosed checks if the finding is closed.
func (f *Finding) IsClosed() bool {
	return f.status.IsClosed()
}

// IsResolved checks if the finding is resolved.
func (f *Finding) IsResolved() bool {
	return f.status == FindingStatusResolved
}

// IsFalsePositive checks if the finding is marked as false positive.
func (f *Finding) IsFalsePositive() bool {
	return f.status == FindingStatusFalsePositive
}

// IsCritical checks if the finding is critical.
func (f *Finding) IsCritical() bool {
	return f.severity == SeverityCritical
}

// IsHighOrCritical checks if the finding is high or critical.
func (f *Finding) IsHighOrCritical() bool {
	return f.severity == SeverityCritical || f.severity == SeverityHigh
}

// HasLocation checks if the finding has location info.
func (f *Finding) HasLocation() bool {
	return f.filePath != "" && f.startLine > 0
}

// Location returns a formatted location string.
func (f *Finding) Location() string {
	if f.filePath == "" {
		return ""
	}
	if f.startLine == 0 {
		return f.filePath
	}
	if f.startColumn == 0 {
		return fmt.Sprintf("%s:%d", f.filePath, f.startLine)
	}
	return fmt.Sprintf("%s:%d:%d", f.filePath, f.startLine, f.startColumn)
}

// HasVulnerability checks if the finding is linked to a vulnerability.
func (f *Finding) HasVulnerability() bool {
	return f.vulnerabilityID != nil && !f.vulnerabilityID.IsZero()
}

// HasComponent checks if the finding is linked to a component.
func (f *Finding) HasComponent() bool {
	return f.componentID != nil && !f.componentID.IsZero()
}

// Age returns the age of the finding since creation.
func (f *Finding) Age() time.Duration {
	return time.Since(f.createdAt)
}

// TimeToResolve returns the time to resolve if resolved.
func (f *Finding) TimeToResolve() *time.Duration {
	if f.resolvedAt == nil {
		return nil
	}
	ttr := f.resolvedAt.Sub(f.createdAt)
	return &ttr
}

// =============================================================================
// CTEM: Exposure Vector Methods
// =============================================================================

// ExposureVector returns the exposure vector.
func (f *Finding) ExposureVector() ExposureVector {
	return f.exposureVector
}

// SetExposureVector sets the exposure vector.
func (f *Finding) SetExposureVector(vector ExposureVector) error {
	if vector != "" && !vector.IsValid() {
		return fmt.Errorf("%w: invalid exposure vector", shared.ErrValidation)
	}
	f.exposureVector = vector
	f.updatedAt = time.Now().UTC()
	return nil
}

// IsNetworkAccessible returns whether the finding is network accessible.
func (f *Finding) IsNetworkAccessible() bool {
	return f.isNetworkAccessible
}

// SetNetworkAccessible sets whether the finding is network accessible.
func (f *Finding) SetNetworkAccessible(accessible bool) {
	f.isNetworkAccessible = accessible
	f.updatedAt = time.Now().UTC()
}

// IsInternetAccessible returns whether the finding is internet accessible.
func (f *Finding) IsInternetAccessible() bool {
	return f.isInternetAccessible
}

// SetInternetAccessible sets whether the finding is internet accessible.
func (f *Finding) SetInternetAccessible(accessible bool) {
	f.isInternetAccessible = accessible
	f.updatedAt = time.Now().UTC()
}

// AttackPrerequisites returns the attack prerequisites.
func (f *Finding) AttackPrerequisites() string {
	return f.attackPrerequisites
}

// SetAttackPrerequisites sets the attack prerequisites.
func (f *Finding) SetAttackPrerequisites(prerequisites string) {
	f.attackPrerequisites = prerequisites
	f.updatedAt = time.Now().UTC()
}

// SetExposureInfo sets all exposure-related fields at once.
func (f *Finding) SetExposureInfo(vector ExposureVector, networkAccessible, internetAccessible bool, prerequisites string) error {
	if vector != "" && !vector.IsValid() {
		return fmt.Errorf("%w: invalid exposure vector", shared.ErrValidation)
	}
	f.exposureVector = vector
	f.isNetworkAccessible = networkAccessible
	f.isInternetAccessible = internetAccessible
	f.attackPrerequisites = prerequisites
	f.updatedAt = time.Now().UTC()
	return nil
}

// =============================================================================
// CTEM: Remediation Context Methods
// =============================================================================

// RemediationType returns the remediation type.
func (f *Finding) RemediationType() RemediationType {
	return f.remediationType
}

// SetRemediationType sets the remediation type.
func (f *Finding) SetRemediationType(remType RemediationType) error {
	if remType != "" && !remType.IsValid() {
		return fmt.Errorf("%w: invalid remediation type", shared.ErrValidation)
	}
	f.remediationType = remType
	f.updatedAt = time.Now().UTC()
	return nil
}

// EstimatedFixTime returns the estimated fix time in minutes.
func (f *Finding) EstimatedFixTime() *int {
	return f.estimatedFixTime
}

// SetEstimatedFixTime sets the estimated fix time in minutes.
func (f *Finding) SetEstimatedFixTime(minutes *int) {
	f.estimatedFixTime = minutes
	f.updatedAt = time.Now().UTC()
}

// FixComplexity returns the fix complexity.
func (f *Finding) FixComplexity() FixComplexity {
	return f.fixComplexity
}

// SetFixComplexity sets the fix complexity.
func (f *Finding) SetFixComplexity(complexity FixComplexity) error {
	if complexity != "" && !complexity.IsValid() {
		return fmt.Errorf("%w: invalid fix complexity", shared.ErrValidation)
	}
	f.fixComplexity = complexity
	f.updatedAt = time.Now().UTC()
	return nil
}

// RemedyAvailable returns whether a remedy is available.
func (f *Finding) RemedyAvailable() bool {
	return f.remedyAvailable
}

// SetRemedyAvailable sets whether a remedy is available.
func (f *Finding) SetRemedyAvailable(available bool) {
	f.remedyAvailable = available
	f.updatedAt = time.Now().UTC()
}

// SetRemediationInfo sets all remediation-related fields at once.
func (f *Finding) SetRemediationInfo(remType RemediationType, estimatedMinutes *int, complexity FixComplexity, available bool) error {
	if remType != "" && !remType.IsValid() {
		return fmt.Errorf("%w: invalid remediation type", shared.ErrValidation)
	}
	if complexity != "" && !complexity.IsValid() {
		return fmt.Errorf("%w: invalid fix complexity", shared.ErrValidation)
	}
	f.remediationType = remType
	f.estimatedFixTime = estimatedMinutes
	f.fixComplexity = complexity
	f.remedyAvailable = available
	f.updatedAt = time.Now().UTC()
	return nil
}

// FixCode returns the auto-fix code snippet.
func (f *Finding) FixCode() string {
	return f.fixCode
}

// SetFixCode sets the auto-fix code snippet.
func (f *Finding) SetFixCode(code string) {
	f.fixCode = code
	f.updatedAt = time.Now().UTC()
}

// FixRegex returns the regex-based fix pattern.
func (f *Finding) FixRegex() *FixRegex {
	return f.fixRegex
}

// SetFixRegex sets the regex-based fix pattern.
func (f *Finding) SetFixRegex(regex *FixRegex) {
	f.fixRegex = regex
	f.updatedAt = time.Now().UTC()
}

// ASVSSection returns the ASVS section.
func (f *Finding) ASVSSection() string {
	return f.asvsSection
}

// SetASVSSection sets the ASVS section.
func (f *Finding) SetASVSSection(section string) {
	f.asvsSection = section
	f.updatedAt = time.Now().UTC()
}

// ASVSControlID returns the ASVS control ID.
func (f *Finding) ASVSControlID() string {
	return f.asvsControlID
}

// SetASVSControlID sets the ASVS control ID.
func (f *Finding) SetASVSControlID(controlID string) {
	f.asvsControlID = controlID
	f.updatedAt = time.Now().UTC()
}

// ASVSControlURL returns the ASVS control URL.
func (f *Finding) ASVSControlURL() string {
	return f.asvsControlURL
}

// SetASVSControlURL sets the ASVS control URL.
func (f *Finding) SetASVSControlURL(url string) {
	f.asvsControlURL = url
	f.updatedAt = time.Now().UTC()
}

// ASVSLevel returns the ASVS level (1, 2, or 3).
func (f *Finding) ASVSLevel() *int {
	return f.asvsLevel
}

// SetASVSLevel sets the ASVS level.
func (f *Finding) SetASVSLevel(level *int) {
	f.asvsLevel = level
	f.updatedAt = time.Now().UTC()
}

// =============================================================================
// CTEM: Business Impact Methods
// =============================================================================

// DataExposureRisk returns the data exposure risk.
func (f *Finding) DataExposureRisk() DataExposureRisk {
	return f.dataExposureRisk
}

// SetDataExposureRisk sets the data exposure risk.
func (f *Finding) SetDataExposureRisk(risk DataExposureRisk) error {
	if risk != "" && !risk.IsValid() {
		return fmt.Errorf("%w: invalid data exposure risk", shared.ErrValidation)
	}
	f.dataExposureRisk = risk
	f.updatedAt = time.Now().UTC()
	return nil
}

// ReputationalImpact returns whether there is reputational impact.
func (f *Finding) ReputationalImpact() bool {
	return f.reputationalImpact
}

// SetReputationalImpact sets whether there is reputational impact.
func (f *Finding) SetReputationalImpact(impact bool) {
	f.reputationalImpact = impact
	f.updatedAt = time.Now().UTC()
}

// ComplianceImpact returns the compliance frameworks impacted.
func (f *Finding) ComplianceImpact() []string {
	result := make([]string, len(f.complianceImpact))
	copy(result, f.complianceImpact)
	return result
}

// SetComplianceImpact sets the compliance frameworks impacted.
func (f *Finding) SetComplianceImpact(frameworks []string) {
	if frameworks == nil {
		frameworks = []string{}
	}
	f.complianceImpact = make([]string, len(frameworks))
	copy(f.complianceImpact, frameworks)
	f.updatedAt = time.Now().UTC()
}

// AddComplianceImpact adds a compliance framework to the impact list.
func (f *Finding) AddComplianceImpact(framework string) {
	if framework == "" {
		return
	}
	for _, fw := range f.complianceImpact {
		if fw == framework {
			return
		}
	}
	f.complianceImpact = append(f.complianceImpact, framework)
	f.updatedAt = time.Now().UTC()
}

// RemoveComplianceImpact removes a compliance framework from the impact list.
func (f *Finding) RemoveComplianceImpact(framework string) {
	for i, fw := range f.complianceImpact {
		if fw == framework {
			f.complianceImpact = append(f.complianceImpact[:i], f.complianceImpact[i+1:]...)
			f.updatedAt = time.Now().UTC()
			return
		}
	}
}

// =============================================================================
// CTEM: Risk Calculation Helpers
// =============================================================================

// CTEMRiskFactor returns a risk multiplier based on CTEM factors.
func (f *Finding) CTEMRiskFactor() float64 {
	factor := 1.0

	// Internet accessible is highest risk
	if f.isInternetAccessible {
		factor *= 2.0
	} else if f.isNetworkAccessible {
		factor *= 1.5
	}

	// Network exposure vector
	factor *= f.exposureVector.RiskMultiplier()

	// Data exposure risk
	factor *= f.dataExposureRisk.RiskMultiplier()

	// No remedy available increases risk
	if !f.remedyAvailable {
		factor *= 1.3
	}

	// Compliance impact increases risk
	if len(f.complianceImpact) > 0 {
		factor *= 1.0 + (float64(len(f.complianceImpact)) * 0.1)
	}

	// Reputational impact
	if f.reputationalImpact {
		factor *= 1.2
	}

	return factor
}

// IsHighPriorityCTEM returns true if this is a high-priority finding based on CTEM criteria.
func (f *Finding) IsHighPriorityCTEM() bool {
	// Internet-facing + high/critical severity
	if f.isInternetAccessible && f.IsHighOrCritical() {
		return true
	}
	// Network accessible + critical
	if f.isNetworkAccessible && f.IsCritical() {
		return true
	}
	// High data exposure risk
	if f.dataExposureRisk == DataExposureRiskCritical || f.dataExposureRisk == DataExposureRiskHigh {
		return true
	}
	// Compliance-critical frameworks impacted
	criticalFrameworks := []string{"PCI-DSS", "HIPAA", "SOC2"}
	for _, fw := range f.complianceImpact {
		for _, critical := range criticalFrameworks {
			if fw == critical {
				return true
			}
		}
	}
	return false
}

// =============================================================================
// SARIF 2.1.0 Field Getters and Setters
// =============================================================================

// Confidence returns the confidence score (0-100).
func (f *Finding) Confidence() *int {
	return f.confidence
}

// SetConfidence sets the confidence score.
func (f *Finding) SetConfidence(confidence *int) error {
	if confidence != nil && (*confidence < 0 || *confidence > 100) {
		return fmt.Errorf("%w: confidence must be between 0 and 100", shared.ErrValidation)
	}
	f.confidence = confidence
	f.updatedAt = time.Now().UTC()
	return nil
}

// Impact returns the impact level.
func (f *Finding) Impact() string {
	return f.impact
}

// SetImpact sets the impact level.
func (f *Finding) SetImpact(impact string) {
	f.impact = impact
	f.updatedAt = time.Now().UTC()
}

// Likelihood returns the likelihood level.
func (f *Finding) Likelihood() string {
	return f.likelihood
}

// SetLikelihood sets the likelihood level.
func (f *Finding) SetLikelihood(likelihood string) {
	f.likelihood = likelihood
	f.updatedAt = time.Now().UTC()
}

// VulnerabilityClass returns the vulnerability classes.
func (f *Finding) VulnerabilityClass() []string {
	result := make([]string, len(f.vulnerabilityClass))
	copy(result, f.vulnerabilityClass)
	return result
}

// SetVulnerabilityClass sets the vulnerability classes.
func (f *Finding) SetVulnerabilityClass(classes []string) {
	if classes == nil {
		classes = []string{}
	}
	f.vulnerabilityClass = make([]string, len(classes))
	copy(f.vulnerabilityClass, classes)
	f.updatedAt = time.Now().UTC()
}

// Subcategory returns the subcategories.
func (f *Finding) Subcategory() []string {
	result := make([]string, len(f.subcategory))
	copy(result, f.subcategory)
	return result
}

// SetSubcategory sets the subcategories.
func (f *Finding) SetSubcategory(subcategories []string) {
	if subcategories == nil {
		subcategories = []string{}
	}
	f.subcategory = make([]string, len(subcategories))
	copy(f.subcategory, subcategories)
	f.updatedAt = time.Now().UTC()
}

// BaselineState returns the baseline state.
func (f *Finding) BaselineState() string {
	return f.baselineState
}

// SetBaselineState sets the baseline state.
func (f *Finding) SetBaselineState(state string) {
	f.baselineState = state
	f.updatedAt = time.Now().UTC()
}

// Kind returns the finding kind.
func (f *Finding) Kind() string {
	return f.kind
}

// SetKind sets the finding kind.
func (f *Finding) SetKind(kind string) {
	f.kind = kind
	f.updatedAt = time.Now().UTC()
}

// Rank returns the rank score.
func (f *Finding) Rank() *float64 {
	return f.rank
}

// SetRank sets the rank score.
func (f *Finding) SetRank(rank *float64) error {
	if rank != nil && (*rank < 0 || *rank > 100) {
		return fmt.Errorf("%w: rank must be between 0 and 100", shared.ErrValidation)
	}
	f.rank = rank
	f.updatedAt = time.Now().UTC()
	return nil
}

// OccurrenceCount returns the occurrence count.
func (f *Finding) OccurrenceCount() int {
	return f.occurrenceCount
}

// SetOccurrenceCount sets the occurrence count.
func (f *Finding) SetOccurrenceCount(count int) {
	if count < 1 {
		count = 1
	}
	f.occurrenceCount = count
	f.updatedAt = time.Now().UTC()
}

// IncrementOccurrenceCount increments the occurrence count.
func (f *Finding) IncrementOccurrenceCount() {
	f.occurrenceCount++
	f.updatedAt = time.Now().UTC()
}

// CorrelationID returns the correlation ID.
func (f *Finding) CorrelationID() string {
	return f.correlationID
}

// SetCorrelationID sets the correlation ID.
func (f *Finding) SetCorrelationID(id string) {
	f.correlationID = id
	f.updatedAt = time.Now().UTC()
}

// PartialFingerprints returns a copy of the partial fingerprints.
func (f *Finding) PartialFingerprints() map[string]string {
	result := make(map[string]string, len(f.partialFingerprints))
	for k, v := range f.partialFingerprints {
		result[k] = v
	}
	return result
}

// SetPartialFingerprints sets the partial fingerprints.
func (f *Finding) SetPartialFingerprints(fingerprints map[string]string) {
	if fingerprints == nil {
		fingerprints = make(map[string]string)
	}
	f.partialFingerprints = make(map[string]string, len(fingerprints))
	for k, v := range fingerprints {
		f.partialFingerprints[k] = v
	}
	f.updatedAt = time.Now().UTC()
}

// AddPartialFingerprint adds a partial fingerprint.
func (f *Finding) AddPartialFingerprint(key, value string) {
	if f.partialFingerprints == nil {
		f.partialFingerprints = make(map[string]string)
	}
	f.partialFingerprints[key] = value
	f.updatedAt = time.Now().UTC()
}

// RelatedLocations returns the related locations.
func (f *Finding) RelatedLocations() []FindingLocation {
	result := make([]FindingLocation, len(f.relatedLocations))
	copy(result, f.relatedLocations)
	return result
}

// SetRelatedLocations sets the related locations.
func (f *Finding) SetRelatedLocations(locations []FindingLocation) {
	if locations == nil {
		locations = []FindingLocation{}
	}
	f.relatedLocations = make([]FindingLocation, len(locations))
	copy(f.relatedLocations, locations)
	f.updatedAt = time.Now().UTC()
}

// AddRelatedLocation adds a related location.
func (f *Finding) AddRelatedLocation(location FindingLocation) {
	f.relatedLocations = append(f.relatedLocations, location)
	f.updatedAt = time.Now().UTC()
}

// Stacks returns the stack traces.
func (f *Finding) Stacks() []StackTrace {
	result := make([]StackTrace, len(f.stacks))
	copy(result, f.stacks)
	return result
}

// SetStacks sets the stack traces.
func (f *Finding) SetStacks(stacks []StackTrace) {
	if stacks == nil {
		stacks = []StackTrace{}
	}
	f.stacks = make([]StackTrace, len(stacks))
	copy(f.stacks, stacks)
	f.updatedAt = time.Now().UTC()
}

// AddStack adds a stack trace.
func (f *Finding) AddStack(stack StackTrace) {
	f.stacks = append(f.stacks, stack)
	f.updatedAt = time.Now().UTC()
}

// Attachments returns the attachments.
func (f *Finding) Attachments() []Attachment {
	result := make([]Attachment, len(f.attachments))
	copy(result, f.attachments)
	return result
}

// SetAttachments sets the attachments.
func (f *Finding) SetAttachments(attachments []Attachment) {
	if attachments == nil {
		attachments = []Attachment{}
	}
	f.attachments = make([]Attachment, len(attachments))
	copy(f.attachments, attachments)
	f.updatedAt = time.Now().UTC()
}

// AddAttachment adds an attachment.
func (f *Finding) AddAttachment(attachment Attachment) {
	f.attachments = append(f.attachments, attachment)
	f.updatedAt = time.Now().UTC()
}

// WorkItemURIs returns the work item URIs.
func (f *Finding) WorkItemURIs() []string {
	result := make([]string, len(f.workItemURIs))
	copy(result, f.workItemURIs)
	return result
}

// SetWorkItemURIs sets the work item URIs.
func (f *Finding) SetWorkItemURIs(uris []string) {
	if uris == nil {
		uris = []string{}
	}
	f.workItemURIs = make([]string, len(uris))
	copy(f.workItemURIs, uris)
	f.updatedAt = time.Now().UTC()
}

// AddWorkItemURI adds a work item URI.
func (f *Finding) AddWorkItemURI(uri string) {
	for _, u := range f.workItemURIs {
		if u == uri {
			return
		}
	}
	f.workItemURIs = append(f.workItemURIs, uri)
	f.updatedAt = time.Now().UTC()
}

// HostedViewerURI returns the hosted viewer URI.
func (f *Finding) HostedViewerURI() string {
	return f.hostedViewerURI
}

// SetHostedViewerURI sets the hosted viewer URI.
func (f *Finding) SetHostedViewerURI(uri string) {
	f.hostedViewerURI = uri
	f.updatedAt = time.Now().UTC()
}

// SetSARIFRiskAssessment sets all risk assessment fields at once.
func (f *Finding) SetSARIFRiskAssessment(confidence *int, impact, likelihood string, vulnerabilityClass, subcategory []string) error {
	if confidence != nil && (*confidence < 0 || *confidence > 100) {
		return fmt.Errorf("%w: confidence must be between 0 and 100", shared.ErrValidation)
	}
	f.confidence = confidence
	f.impact = impact
	f.likelihood = likelihood
	f.SetVulnerabilityClass(vulnerabilityClass)
	f.SetSubcategory(subcategory)
	f.updatedAt = time.Now().UTC()
	return nil
}

// SetSARIFCoreFields sets the core SARIF fields at once.
func (f *Finding) SetSARIFCoreFields(baselineState, kind string, rank *float64, occurrenceCount int, correlationID string) error {
	if rank != nil && (*rank < 0 || *rank > 100) {
		return fmt.Errorf("%w: rank must be between 0 and 100", shared.ErrValidation)
	}
	f.baselineState = baselineState
	f.kind = kind
	f.rank = rank
	if occurrenceCount < 1 {
		occurrenceCount = 1
	}
	f.occurrenceCount = occurrenceCount
	f.correlationID = correlationID
	f.updatedAt = time.Now().UTC()
	return nil
}

// =============================================================================
// Finding Type and Specialized Field Setters
// =============================================================================

// SetFindingType sets the finding type discriminator.
func (f *Finding) SetFindingType(findingType FindingType) {
	f.findingType = findingType
	f.updatedAt = time.Now().UTC()
}

// SetSecretType sets the secret type (for secret findings).
func (f *Finding) SetSecretType(secretType string) {
	f.secretType = secretType
	f.updatedAt = time.Now().UTC()
}

// SetSecretService sets the secret service (for secret findings).
func (f *Finding) SetSecretService(service string) {
	f.secretService = service
	f.updatedAt = time.Now().UTC()
}

// SetSecretValid sets whether the secret is valid (for secret findings).
func (f *Finding) SetSecretValid(valid *bool) {
	f.secretValid = valid
	f.updatedAt = time.Now().UTC()
}

// SetSecretRevoked sets whether the secret has been revoked (for secret findings).
func (f *Finding) SetSecretRevoked(revoked *bool) {
	f.secretRevoked = revoked
	f.updatedAt = time.Now().UTC()
}

// SetSecretEntropy sets the secret entropy (for secret findings).
func (f *Finding) SetSecretEntropy(entropy *float64) {
	f.secretEntropy = entropy
	f.updatedAt = time.Now().UTC()
}

// SetSecretExpiresAt sets the secret expiration time (for secret findings).
func (f *Finding) SetSecretExpiresAt(expiresAt *time.Time) {
	f.secretExpiresAt = expiresAt
	f.updatedAt = time.Now().UTC()
}

// SetSecretVerifiedAt sets when the secret was verified (for secret findings).
func (f *Finding) SetSecretVerifiedAt(verifiedAt *time.Time) {
	f.secretVerifiedAt = verifiedAt
	f.updatedAt = time.Now().UTC()
}

// SetSecretRotationDueAt sets when the secret rotation is due (for secret findings).
func (f *Finding) SetSecretRotationDueAt(rotationDueAt *time.Time) {
	f.secretRotationDueAt = rotationDueAt
	f.updatedAt = time.Now().UTC()
}

// SetSecretAgeInDays sets the age of the secret in days (for secret findings).
func (f *Finding) SetSecretAgeInDays(ageInDays int) {
	f.secretAgeInDays = ageInDays
	f.updatedAt = time.Now().UTC()
}

// SetSecretScopes sets the secret scopes/permissions (for secret findings).
func (f *Finding) SetSecretScopes(scopes []string) {
	if scopes == nil {
		f.secretScopes = nil
	} else {
		f.secretScopes = make([]string, len(scopes))
		copy(f.secretScopes, scopes)
	}
	f.updatedAt = time.Now().UTC()
}

// SetSecretMaskedValue sets the masked value of the secret (for secret findings).
func (f *Finding) SetSecretMaskedValue(maskedValue string) {
	f.secretMaskedValue = maskedValue
	f.updatedAt = time.Now().UTC()
}

// SetSecretInHistoryOnly sets whether the secret is only in git history (for secret findings).
func (f *Finding) SetSecretInHistoryOnly(inHistoryOnly bool) {
	f.secretInHistoryOnly = inHistoryOnly
	f.updatedAt = time.Now().UTC()
}

// SetSecretCommitCount sets the number of commits containing this secret (for secret findings).
func (f *Finding) SetSecretCommitCount(commitCount int) {
	f.secretCommitCount = commitCount
	f.updatedAt = time.Now().UTC()
}

// SetSecretDetails sets all secret-related fields at once.
func (f *Finding) SetSecretDetails(secretType, service string, valid, revoked *bool, entropy *float64, expiresAt *time.Time) {
	f.secretType = secretType
	f.secretService = service
	f.secretValid = valid
	f.secretRevoked = revoked
	f.secretEntropy = entropy
	f.secretExpiresAt = expiresAt
	f.updatedAt = time.Now().UTC()
}

// SetComplianceFramework sets the compliance framework (for compliance findings).
func (f *Finding) SetComplianceFramework(framework string) {
	f.complianceFramework = framework
	f.updatedAt = time.Now().UTC()
}

// SetComplianceControlID sets the compliance control ID (for compliance findings).
func (f *Finding) SetComplianceControlID(controlID string) {
	f.complianceControlID = controlID
	f.updatedAt = time.Now().UTC()
}

// SetComplianceControlName sets the compliance control name (for compliance findings).
func (f *Finding) SetComplianceControlName(controlName string) {
	f.complianceControlName = controlName
	f.updatedAt = time.Now().UTC()
}

// SetComplianceResult sets the compliance result (for compliance findings).
func (f *Finding) SetComplianceResult(result string) {
	f.complianceResult = result
	f.updatedAt = time.Now().UTC()
}

// SetComplianceSection sets the compliance section (for compliance findings).
func (f *Finding) SetComplianceSection(section string) {
	f.complianceSection = section
	f.updatedAt = time.Now().UTC()
}

// SetComplianceFrameworkVersion sets the compliance framework version (for compliance findings).
func (f *Finding) SetComplianceFrameworkVersion(version string) {
	f.complianceFrameworkVersion = version
	f.updatedAt = time.Now().UTC()
}

// SetComplianceControlDescription sets the compliance control description (for compliance findings).
func (f *Finding) SetComplianceControlDescription(description string) {
	f.complianceControlDescription = description
	f.updatedAt = time.Now().UTC()
}

// SetComplianceDetails sets all compliance-related fields at once.
func (f *Finding) SetComplianceDetails(framework, controlID, controlName, result, section string) {
	f.complianceFramework = framework
	f.complianceControlID = controlID
	f.complianceControlName = controlName
	f.complianceResult = result
	f.complianceSection = section
	f.updatedAt = time.Now().UTC()
}

// SetWeb3Chain sets the blockchain chain (for web3 findings).
func (f *Finding) SetWeb3Chain(chain string) {
	f.web3Chain = chain
	f.updatedAt = time.Now().UTC()
}

// SetWeb3ChainID sets the blockchain chain ID (for web3 findings).
func (f *Finding) SetWeb3ChainID(chainID int64) {
	f.web3ChainID = chainID
	f.updatedAt = time.Now().UTC()
}

// SetWeb3ContractAddress sets the smart contract address (for web3 findings).
func (f *Finding) SetWeb3ContractAddress(address string) {
	f.web3ContractAddress = address
	f.updatedAt = time.Now().UTC()
}

// SetWeb3SWCID sets the SWC ID (for web3 findings).
func (f *Finding) SetWeb3SWCID(swcID string) {
	f.web3SWCID = swcID
	f.updatedAt = time.Now().UTC()
}

// SetWeb3FunctionSignature sets the function signature (for web3 findings).
func (f *Finding) SetWeb3FunctionSignature(signature string) {
	f.web3FunctionSignature = signature
	f.updatedAt = time.Now().UTC()
}

// SetWeb3TxHash sets the transaction hash (for web3 findings).
func (f *Finding) SetWeb3TxHash(txHash string) {
	f.web3TxHash = txHash
	f.updatedAt = time.Now().UTC()
}

// SetWeb3FunctionSelector sets the function selector (for web3 findings).
func (f *Finding) SetWeb3FunctionSelector(selector string) {
	f.web3FunctionSelector = selector
	f.updatedAt = time.Now().UTC()
}

// SetWeb3BytecodeOffset sets the bytecode offset (for web3 findings).
func (f *Finding) SetWeb3BytecodeOffset(offset int) {
	f.web3BytecodeOffset = offset
	f.updatedAt = time.Now().UTC()
}

// SetWeb3Details sets all web3-related fields at once.
func (f *Finding) SetWeb3Details(chain string, chainID int64, contractAddress, swcID, functionSignature, txHash string) {
	f.web3Chain = chain
	f.web3ChainID = chainID
	f.web3ContractAddress = contractAddress
	f.web3SWCID = swcID
	f.web3FunctionSignature = functionSignature
	f.web3TxHash = txHash
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigPolicyID sets the misconfiguration policy ID.
func (f *Finding) SetMisconfigPolicyID(policyID string) {
	f.misconfigPolicyID = policyID
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigResourceType sets the misconfiguration resource type.
func (f *Finding) SetMisconfigResourceType(resourceType string) {
	f.misconfigResourceType = resourceType
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigResourceName sets the misconfiguration resource name.
func (f *Finding) SetMisconfigResourceName(resourceName string) {
	f.misconfigResourceName = resourceName
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigResourcePath sets the misconfiguration resource path.
func (f *Finding) SetMisconfigResourcePath(resourcePath string) {
	f.misconfigResourcePath = resourcePath
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigExpected sets the expected configuration value.
func (f *Finding) SetMisconfigExpected(expected string) {
	f.misconfigExpected = expected
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigActual sets the actual configuration value.
func (f *Finding) SetMisconfigActual(actual string) {
	f.misconfigActual = actual
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigPolicyName sets the misconfiguration policy name.
func (f *Finding) SetMisconfigPolicyName(policyName string) {
	f.misconfigPolicyName = policyName
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigCause sets the misconfiguration cause/reason.
func (f *Finding) SetMisconfigCause(cause string) {
	f.misconfigCause = cause
	f.updatedAt = time.Now().UTC()
}

// SetMisconfigDetails sets all misconfiguration-related fields at once.
func (f *Finding) SetMisconfigDetails(policyID, resourceType, resourceName, resourcePath, expected, actual string) {
	f.misconfigPolicyID = policyID
	f.misconfigResourceType = resourceType
	f.misconfigResourceName = resourceName
	f.misconfigResourcePath = resourcePath
	f.misconfigExpected = expected
	f.misconfigActual = actual
	f.updatedAt = time.Now().UTC()
}

// SetDataFlows sets the data flows for taint tracking.
func (f *Finding) SetDataFlows(flows []DataFlow) {
	if flows == nil {
		f.dataFlows = nil
	} else {
		f.dataFlows = make([]DataFlow, len(flows))
		copy(f.dataFlows, flows)
	}
	f.updatedAt = time.Now().UTC()
}

// AddDataFlow adds a data flow.
func (f *Finding) AddDataFlow(flow DataFlow) {
	f.dataFlows = append(f.dataFlows, flow)
	f.updatedAt = time.Now().UTC()
}

// =============================================================================
// Enrichment Methods
// =============================================================================

// EnrichFrom updates this finding with non-null values from another finding
// using selective enrichment rules:
// - Protected fields (status, resolution, resolved_by, resolved_at) are NEVER overwritten
// - FirstWins fields (secret_type, web3_chain, etc.) only set if currently empty
// - LastWins fields (description, snippet, etc.) update with new non-null values
// - MaxValue fields (cvss_score) keep the maximum value
// - Append fields (tags, cwe_ids) accumulate unique values
// - Merge fields (metadata) deep merge objects
func (f *Finding) EnrichFrom(other *Finding) {
	if other == nil {
		return
	}

	// PROTECTED FIELDS - Never touch these (user decisions, audit trail)
	// status, resolution, resolved_by, resolved_at, closed_by, closed_at
	// assigned_to, assigned_by, assigned_at, verified_by, verified_at

	f.enrichCoreFields(other)
	f.enrichSecretFields(other)
	f.enrichWeb3Fields(other)
	f.enrichComplianceFields(other)
	f.enrichMisconfigFields(other)
	f.enrichCTEMFields(other)
	f.enrichSARIFFields(other)
	f.enrichArrayFields(other)
	f.enrichMaps(other)
	f.enrichLocation(other)

	// Update tracking
	f.lastSeenAt = time.Now().UTC()
	f.updatedAt = time.Now().UTC()
	if other.scanID != "" {
		f.scanID = other.scanID
	}
}

// enrichCoreFields handles LastWins, MaxValue, and FirstWins for core finding fields.
func (f *Finding) enrichCoreFields(other *Finding) {
	// LAST_WINS: Update with new non-empty values
	if other.description != "" {
		f.description = other.description
	}
	if other.snippet != "" {
		f.snippet = other.snippet
	}
	if other.recommendation != "" {
		f.recommendation = other.recommendation
	}
	if other.title != "" {
		f.title = other.title
	}

	// MAX_VALUE: Keep maximum severity
	if other.severity.Score() > f.severity.Score() {
		f.severity = other.severity
	}

	// MAX_VALUE: Keep maximum CVSS score
	if other.cvssScore != nil {
		if f.cvssScore == nil || *other.cvssScore > *f.cvssScore {
			f.cvssScore = other.cvssScore
			f.cvssVector = other.cvssVector
		}
	}

	// FIRST_WINS: Only set if currently empty (identity fields)
	if f.cveID == "" && other.cveID != "" {
		f.cveID = other.cveID
	}
	if f.ruleID == "" && other.ruleID != "" {
		f.ruleID = other.ruleID
	}
	if f.ruleName == "" && other.ruleName != "" {
		f.ruleName = other.ruleName
	}
}

// enrichSecretFields handles secret-specific field enrichment.
func (f *Finding) enrichSecretFields(other *Finding) {
	// FIRST_WINS for type/service (identity)
	if f.secretType == "" && other.secretType != "" {
		f.secretType = other.secretType
	}
	if f.secretService == "" && other.secretService != "" {
		f.secretService = other.secretService
	}
	if f.secretMaskedValue == "" && other.secretMaskedValue != "" {
		f.secretMaskedValue = other.secretMaskedValue
	}

	// Verification results: LastWins
	if other.secretValid != nil {
		f.secretValid = other.secretValid
		f.secretVerifiedAt = other.secretVerifiedAt
	}
	if other.secretRevoked != nil && *other.secretRevoked {
		f.secretRevoked = other.secretRevoked
	}
	if other.secretEntropy != nil && f.secretEntropy == nil {
		f.secretEntropy = other.secretEntropy
	}
	if other.secretExpiresAt != nil && f.secretExpiresAt == nil {
		f.secretExpiresAt = other.secretExpiresAt
	}
}

// enrichWeb3Fields handles Web3-specific field enrichment.
func (f *Finding) enrichWeb3Fields(other *Finding) {
	// FIRST_WINS for chain/contract/swcid (identity)
	if f.web3Chain == "" && other.web3Chain != "" {
		f.web3Chain = other.web3Chain
	}
	if f.web3ChainID == 0 && other.web3ChainID != 0 {
		f.web3ChainID = other.web3ChainID
	}
	if f.web3ContractAddress == "" && other.web3ContractAddress != "" {
		f.web3ContractAddress = other.web3ContractAddress
	}
	if f.web3SWCID == "" && other.web3SWCID != "" {
		f.web3SWCID = other.web3SWCID
	}

	// LastWins for analysis results
	if other.web3FunctionSignature != "" {
		f.web3FunctionSignature = other.web3FunctionSignature
	}
	if other.web3FunctionSelector != "" {
		f.web3FunctionSelector = other.web3FunctionSelector
	}
	if other.web3BytecodeOffset != 0 {
		f.web3BytecodeOffset = other.web3BytecodeOffset
	}
}

// enrichComplianceFields handles compliance-specific field enrichment.
func (f *Finding) enrichComplianceFields(other *Finding) {
	// FIRST_WINS for all compliance fields
	if f.complianceFramework == "" && other.complianceFramework != "" {
		f.complianceFramework = other.complianceFramework
	}
	if f.complianceFrameworkVersion == "" && other.complianceFrameworkVersion != "" {
		f.complianceFrameworkVersion = other.complianceFrameworkVersion
	}
	if f.complianceControlID == "" && other.complianceControlID != "" {
		f.complianceControlID = other.complianceControlID
	}
	if f.complianceControlName == "" && other.complianceControlName != "" {
		f.complianceControlName = other.complianceControlName
	}
	if f.complianceControlDescription == "" && other.complianceControlDescription != "" {
		f.complianceControlDescription = other.complianceControlDescription
	}
	if f.complianceResult == "" && other.complianceResult != "" {
		f.complianceResult = other.complianceResult
	}
}

// enrichMisconfigFields handles misconfiguration-specific field enrichment.
func (f *Finding) enrichMisconfigFields(other *Finding) {
	// FIRST_WINS for policy fields
	if f.misconfigPolicyID == "" && other.misconfigPolicyID != "" {
		f.misconfigPolicyID = other.misconfigPolicyID
	}
	if f.misconfigPolicyName == "" && other.misconfigPolicyName != "" {
		f.misconfigPolicyName = other.misconfigPolicyName
	}
	if f.misconfigResourceType == "" && other.misconfigResourceType != "" {
		f.misconfigResourceType = other.misconfigResourceType
	}
	if f.misconfigResourceName == "" && other.misconfigResourceName != "" {
		f.misconfigResourceName = other.misconfigResourceName
	}

	// LastWins for analysis fields
	if other.misconfigExpected != "" {
		f.misconfigExpected = other.misconfigExpected
	}
	if other.misconfigActual != "" {
		f.misconfigActual = other.misconfigActual
	}
	if other.misconfigCause != "" {
		f.misconfigCause = other.misconfigCause
	}
}

// enrichCTEMFields handles CTEM-specific field enrichment.
func (f *Finding) enrichCTEMFields(other *Finding) {
	// LAST_WINS (latest assessment)
	if other.exposureVector != "" && other.exposureVector != ExposureVectorUnknown {
		f.exposureVector = other.exposureVector
	}
	if other.isNetworkAccessible {
		f.isNetworkAccessible = other.isNetworkAccessible
	}
	if other.isInternetAccessible {
		f.isInternetAccessible = other.isInternetAccessible
	}
	if other.attackPrerequisites != "" {
		f.attackPrerequisites = other.attackPrerequisites
	}
	if other.remediationType != "" {
		f.remediationType = other.remediationType
	}
	if other.estimatedFixTime != nil {
		f.estimatedFixTime = other.estimatedFixTime
	}
	if other.fixComplexity != "" {
		f.fixComplexity = other.fixComplexity
	}
	if other.dataExposureRisk != "" && other.dataExposureRisk != DataExposureRiskNone {
		f.dataExposureRisk = other.dataExposureRisk
	}
	if other.reputationalImpact {
		f.reputationalImpact = other.reputationalImpact
	}
}

// enrichSARIFFields handles SARIF-specific field enrichment.
func (f *Finding) enrichSARIFFields(other *Finding) {
	// MAX_VALUE for confidence/rank
	if other.confidence != nil && (f.confidence == nil || *other.confidence > *f.confidence) {
		f.confidence = other.confidence
	}
	if other.rank != nil && (f.rank == nil || *other.rank > *f.rank) {
		f.rank = other.rank
	}

	// LAST_WINS for analysis
	if other.impact != "" {
		f.impact = other.impact
	}
	if other.likelihood != "" {
		f.likelihood = other.likelihood
	}

	// FIRST_WINS for identity
	if f.correlationID == "" && other.correlationID != "" {
		f.correlationID = other.correlationID
	}
}

// enrichArrayFields handles APPEND strategy for array fields.
func (f *Finding) enrichArrayFields(other *Finding) {
	f.cweIDs = appendUniqueStrings(f.cweIDs, other.cweIDs)
	f.owaspIDs = appendUniqueStrings(f.owaspIDs, other.owaspIDs)
	f.tags = appendUniqueStrings(f.tags, other.tags)
	f.vulnerabilityClass = appendUniqueStrings(f.vulnerabilityClass, other.vulnerabilityClass)
	f.subcategory = appendUniqueStrings(f.subcategory, other.subcategory)
	f.complianceImpact = appendUniqueStrings(f.complianceImpact, other.complianceImpact)
	f.workItemURIs = appendUniqueStrings(f.workItemURIs, other.workItemURIs)
}

// enrichMaps handles MERGE strategy for map fields.
func (f *Finding) enrichMaps(other *Finding) {
	// Metadata
	if other.metadata != nil {
		if f.metadata == nil {
			f.metadata = make(map[string]any)
		}
		for k, v := range other.metadata {
			if _, exists := f.metadata[k]; !exists {
				f.metadata[k] = v
			}
		}
	}

	// Partial fingerprints
	if other.partialFingerprints != nil {
		if f.partialFingerprints == nil {
			f.partialFingerprints = make(map[string]string)
		}
		for k, v := range other.partialFingerprints {
			if _, exists := f.partialFingerprints[k]; !exists {
				f.partialFingerprints[k] = v
			}
		}
	}
}

// enrichLocation handles FIRST_WINS for location fields.
func (f *Finding) enrichLocation(other *Finding) {
	if f.filePath == "" && other.filePath != "" {
		f.filePath = other.filePath
		f.startLine = other.startLine
		f.endLine = other.endLine
		f.startColumn = other.startColumn
		f.endColumn = other.endColumn
	}
}

// appendUniqueStrings appends unique strings from src to dst, avoiding duplicates.
func appendUniqueStrings(dst, src []string) []string {
	if len(src) == 0 {
		return dst
	}

	seen := make(map[string]bool, len(dst))
	for _, v := range dst {
		seen[v] = true
	}

	for _, v := range src {
		if v != "" && !seen[v] {
			dst = append(dst, v)
			seen[v] = true
		}
	}

	return dst
}
