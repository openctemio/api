package vulnerability

import (
	"context"
	"database/sql"
	"time"

	"github.com/openctemio/api/pkg/domain/shared"
	"github.com/openctemio/api/pkg/pagination"
)

// VulnerabilityRepository defines the interface for vulnerability persistence.
type VulnerabilityRepository interface {
	// Create persists a new vulnerability.
	Create(ctx context.Context, vuln *Vulnerability) error

	// GetByID retrieves a vulnerability by ID.
	GetByID(ctx context.Context, id shared.ID) (*Vulnerability, error)

	// GetByCVE retrieves a vulnerability by CVE ID.
	GetByCVE(ctx context.Context, cveID string) (*Vulnerability, error)

	// Update updates an existing vulnerability.
	Update(ctx context.Context, vuln *Vulnerability) error

	// Delete removes a vulnerability by ID.
	Delete(ctx context.Context, id shared.ID) error

	// List retrieves vulnerabilities matching the filter with pagination and sorting.
	List(ctx context.Context, filter VulnerabilityFilter, opts VulnerabilityListOptions, page pagination.Pagination) (pagination.Result[*Vulnerability], error)

	// Count returns the count of vulnerabilities matching the filter.
	Count(ctx context.Context, filter VulnerabilityFilter) (int64, error)

	// UpsertByCVE creates or updates a vulnerability by CVE ID.
	UpsertByCVE(ctx context.Context, vuln *Vulnerability) error

	// ExistsByCVE checks if a vulnerability with the given CVE ID exists.
	ExistsByCVE(ctx context.Context, cveID string) (bool, error)
}

// VulnerabilityListOptions contains options for listing vulnerabilities (sorting).
type VulnerabilityListOptions struct {
	Sort *pagination.SortOption
}

// NewVulnerabilityListOptions creates empty list options.
func NewVulnerabilityListOptions() VulnerabilityListOptions {
	return VulnerabilityListOptions{}
}

// WithSort adds sorting options.
func (o VulnerabilityListOptions) WithSort(sort *pagination.SortOption) VulnerabilityListOptions {
	o.Sort = sort
	return o
}

// VulnerabilityAllowedSortFields returns the allowed sort fields for vulnerabilities.
func VulnerabilityAllowedSortFields() map[string]string {
	return map[string]string{
		"cve_id":       "cve_id",
		"severity":     "severity",
		"cvss_score":   "cvss_score",
		"epss_score":   "epss_score",
		"published_at": "published_at",
		"created_at":   "created_at",
		"updated_at":   "updated_at",
	}
}

// VulnerabilityFilter defines criteria for filtering vulnerabilities.
type VulnerabilityFilter struct {
	CVEIDs           []string
	Severities       []Severity
	MinCVSS          *float64
	MaxCVSS          *float64
	MinEPSS          *float64
	ExploitAvailable *bool
	CISAKEVOnly      *bool
	Statuses         []VulnerabilityStatus
	Search           *string // Full-text search across CVE ID and description
}

// NewVulnerabilityFilter creates a new empty filter.
func NewVulnerabilityFilter() VulnerabilityFilter {
	return VulnerabilityFilter{}
}

// WithCVEIDs sets the CVE IDs filter.
func (f VulnerabilityFilter) WithCVEIDs(cveIDs ...string) VulnerabilityFilter {
	f.CVEIDs = cveIDs
	return f
}

// WithSeverities sets the severities filter.
func (f VulnerabilityFilter) WithSeverities(severities ...Severity) VulnerabilityFilter {
	f.Severities = severities
	return f
}

// WithMinCVSS sets the minimum CVSS filter.
func (f VulnerabilityFilter) WithMinCVSS(score float64) VulnerabilityFilter {
	f.MinCVSS = &score
	return f
}

// WithMaxCVSS sets the maximum CVSS filter.
func (f VulnerabilityFilter) WithMaxCVSS(score float64) VulnerabilityFilter {
	f.MaxCVSS = &score
	return f
}

// WithMinEPSS sets the minimum EPSS filter.
func (f VulnerabilityFilter) WithMinEPSS(score float64) VulnerabilityFilter {
	f.MinEPSS = &score
	return f
}

// WithExploitAvailable sets the exploit available filter.
func (f VulnerabilityFilter) WithExploitAvailable(available bool) VulnerabilityFilter {
	f.ExploitAvailable = &available
	return f
}

// WithCISAKEVOnly sets the CISA KEV only filter.
func (f VulnerabilityFilter) WithCISAKEVOnly(only bool) VulnerabilityFilter {
	f.CISAKEVOnly = &only
	return f
}

// WithStatuses sets the statuses filter.
func (f VulnerabilityFilter) WithStatuses(statuses ...VulnerabilityStatus) VulnerabilityFilter {
	f.Statuses = statuses
	return f
}

// WithSearch sets the full-text search filter.
func (f VulnerabilityFilter) WithSearch(search string) VulnerabilityFilter {
	f.Search = &search
	return f
}

// IsEmpty checks if no filters are applied.
func (f VulnerabilityFilter) IsEmpty() bool {
	return len(f.CVEIDs) == 0 &&
		len(f.Severities) == 0 &&
		f.MinCVSS == nil &&
		f.MaxCVSS == nil &&
		f.MinEPSS == nil &&
		f.ExploitAvailable == nil &&
		f.CISAKEVOnly == nil &&
		len(f.Statuses) == 0 &&
		f.Search == nil
}

// BatchCreateResult contains the result of a batch create operation.
// It supports partial success - some findings may fail while others succeed.
type BatchCreateResult struct {
	// Created is the number of findings successfully created.
	Created int
	// Updated is the number of existing findings updated (via ON CONFLICT).
	Updated int
	// Skipped is the number of findings skipped due to errors.
	Skipped int
	// Errors contains error messages for failed findings.
	// Key is the finding index (0-based), value is the error message.
	Errors map[int]string
}

// HasErrors returns true if any findings failed to create.
func (r *BatchCreateResult) HasErrors() bool {
	return len(r.Errors) > 0
}

// TotalProcessed returns the total number of findings processed.
func (r *BatchCreateResult) TotalProcessed() int {
	return r.Created + r.Updated + r.Skipped
}

// FindingRepository defines the interface for finding persistence.
type FindingRepository interface {
	// Create persists a new finding.
	Create(ctx context.Context, finding *Finding) error

	// CreateInTx persists a new finding within an existing transaction.
	// This is used for the transactional outbox pattern.
	CreateInTx(ctx context.Context, tx *sql.Tx, finding *Finding) error

	// CreateBatch persists multiple findings in a single transaction.
	// Deprecated: Use CreateBatchWithResult for better error handling.
	// This method uses all-or-nothing semantics - if one finding fails, all fail.
	CreateBatch(ctx context.Context, findings []*Finding) error

	// CreateBatchWithResult persists multiple findings with partial success support.
	// Uses chunked transactions to isolate failures - if one chunk fails,
	// only that chunk is retried individually to identify the bad finding.
	// Returns detailed result with created/skipped counts and per-finding errors.
	CreateBatchWithResult(ctx context.Context, findings []*Finding) (*BatchCreateResult, error)

	// GetByID retrieves a finding by ID.
	// Security: Requires tenantID to prevent cross-tenant data access (IDOR prevention).
	GetByID(ctx context.Context, tenantID, id shared.ID) (*Finding, error)

	// Update updates an existing finding.
	// Security: The Finding entity contains TenantID which is used to verify ownership.
	Update(ctx context.Context, finding *Finding) error

	// Delete removes a finding by ID.
	// Security: Requires tenantID to prevent cross-tenant deletion (IDOR prevention).
	Delete(ctx context.Context, tenantID, id shared.ID) error

	// List retrieves findings matching the filter with pagination and sorting.
	List(ctx context.Context, filter FindingFilter, opts FindingListOptions, page pagination.Pagination) (pagination.Result[*Finding], error)

	// ListByAssetID retrieves findings for an asset.
	// Security: Requires tenantID to prevent cross-tenant data access.
	ListByAssetID(ctx context.Context, tenantID, assetID shared.ID, opts FindingListOptions, page pagination.Pagination) (pagination.Result[*Finding], error)

	// ListByVulnerabilityID retrieves findings for a vulnerability.
	// Security: Requires tenantID to prevent cross-tenant data access.
	ListByVulnerabilityID(ctx context.Context, tenantID, vulnID shared.ID, opts FindingListOptions, page pagination.Pagination) (pagination.Result[*Finding], error)

	// ListByComponentID retrieves findings for a component.
	// Security: Requires tenantID to prevent cross-tenant data access.
	ListByComponentID(ctx context.Context, tenantID, compID shared.ID, opts FindingListOptions, page pagination.Pagination) (pagination.Result[*Finding], error)

	// Count returns the count of findings matching the filter.
	Count(ctx context.Context, filter FindingFilter) (int64, error)

	// CountByAssetID returns the count of findings for an asset.
	// Security: Requires tenantID to prevent cross-tenant data access.
	CountByAssetID(ctx context.Context, tenantID, assetID shared.ID) (int64, error)

	// CountOpenByAssetID returns the count of open findings for an asset.
	// Security: Requires tenantID to prevent cross-tenant data access.
	CountOpenByAssetID(ctx context.Context, tenantID, assetID shared.ID) (int64, error)

	// GetByFingerprint retrieves a finding by fingerprint.
	GetByFingerprint(ctx context.Context, tenantID shared.ID, fingerprint string) (*Finding, error)

	// ExistsByFingerprint checks if a finding with the given fingerprint exists.
	ExistsByFingerprint(ctx context.Context, tenantID shared.ID, fingerprint string) (bool, error)

	// CheckFingerprintsExist checks which fingerprints already exist in the database.
	// Returns a map of fingerprint -> exists boolean.
	CheckFingerprintsExist(ctx context.Context, tenantID shared.ID, fingerprints []string) (map[string]bool, error)

	// UpdateScanIDBatchByFingerprints updates scan_id for multiple findings by their fingerprints.
	// Returns the count of updated findings.
	UpdateScanIDBatchByFingerprints(ctx context.Context, tenantID shared.ID, fingerprints []string, scanID string) (int64, error)

	// UpdateSnippetBatchByFingerprints updates snippet for findings that have invalid snippets
	// ("requires login" or empty). Only updates if new snippet is valid.
	// snippets is a map of fingerprint -> new snippet
	UpdateSnippetBatchByFingerprints(ctx context.Context, tenantID shared.ID, snippets map[string]string) (int64, error)

	// BatchCountByAssetIDs returns the count of findings for multiple assets in one query.
	// Security: Requires tenantID to prevent cross-tenant data access.
	// Returns a map of assetID -> count.
	BatchCountByAssetIDs(ctx context.Context, tenantID shared.ID, assetIDs []shared.ID) (map[shared.ID]int64, error)

	// UpdateStatus updates the status of multiple findings.
	// Security: Requires tenantID to prevent cross-tenant status modification.
	UpdateStatusBatch(ctx context.Context, tenantID shared.ID, ids []shared.ID, status FindingStatus, resolution string, resolvedBy *shared.ID) error

	// DeleteByAssetID removes all findings for an asset.
	// Security: Requires tenantID to prevent cross-tenant deletion.
	DeleteByAssetID(ctx context.Context, tenantID, assetID shared.ID) error

	// DeleteByScanID removes all findings for a scan.
	DeleteByScanID(ctx context.Context, tenantID shared.ID, scanID string) error

	// GetStats returns aggregated statistics for findings matching the filter.
	GetStats(ctx context.Context, tenantID shared.ID) (*FindingStats, error)

	// CountBySeverityForScan returns the count of findings grouped by severity for a scan.
	// Used for quality gate evaluation.
	CountBySeverityForScan(ctx context.Context, tenantID shared.ID, scanID string) (SeverityCounts, error)

	// AutoResolveStale marks findings as resolved when not found in current full scan.
	// Only affects findings on the default branch (via branch_id FK to asset_branches.is_default).
	// Only affects active statuses (new, open, confirmed, in_progress).
	// Protected statuses (false_positive, accepted, duplicate) are never auto-resolved.
	// If branchID is provided, only auto-resolves findings on that branch if it's a default branch.
	// If branchID is nil, auto-resolves findings where branch_id points to any default branch.
	// Returns the count of auto-resolved findings and their IDs for activity logging.
	AutoResolveStale(ctx context.Context, tenantID shared.ID, assetID shared.ID, toolName string, currentScanID string, branchID *shared.ID) ([]shared.ID, error)

	// AutoReopenByFingerprint reopens a previously auto-resolved finding if it reappears.
	// Only reopens findings with resolution = 'auto_fixed'.
	// Protected resolutions (false_positive, accepted_risk) are never reopened.
	// Returns the finding ID if reopened, nil if not found or protected.
	AutoReopenByFingerprint(ctx context.Context, tenantID shared.ID, fingerprint string) (*shared.ID, error)

	// AutoReopenByFingerprintsBatch reopens multiple previously auto-resolved findings in a single query.
	// This is the batch version of AutoReopenByFingerprint for better performance.
	// Only reopens findings with resolution = 'auto_fixed'.
	// Protected resolutions (false_positive, accepted_risk) are never reopened.
	// Returns a map of fingerprint -> reopened finding ID.
	AutoReopenByFingerprintsBatch(ctx context.Context, tenantID shared.ID, fingerprints []string) (map[string]shared.ID, error)

	// ExpireFeatureBranchFindings marks stale feature branch findings as resolved.
	// This is called by a background job to clean up findings on non-default branches
	// that have not been seen for a configurable period.
	// Uses JOIN with asset_branches to determine:
	// - branch_id links to a non-default branch (is_default = false)
	// - branch allows expiry (keep_when_inactive = false)
	// - retention_days per branch or defaultExpiryDays as fallback
	// Only affects findings where status IN ('new', 'open').
	// Returns the count of expired findings.
	ExpireFeatureBranchFindings(ctx context.Context, tenantID shared.ID, defaultExpiryDays int) (int64, error)

	// ExistsByIDs checks which finding IDs exist in the database.
	// Returns a map of finding ID -> exists boolean.
	// Security: Requires tenantID to prevent cross-tenant data access.
	// Used for batch validation in bulk operations (e.g., bulk AI triage).
	ExistsByIDs(ctx context.Context, tenantID shared.ID, ids []shared.ID) (map[shared.ID]bool, error)
}

// SeverityCounts holds the count of findings by severity level.
// Used for quality gate evaluation.
type SeverityCounts struct {
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
	Info     int `json:"info"`
	Total    int `json:"total"`
}

// FindingListOptions contains options for listing findings (sorting).
type FindingListOptions struct {
	Sort *pagination.SortOption
}

// NewFindingListOptions creates empty list options.
func NewFindingListOptions() FindingListOptions {
	return FindingListOptions{}
}

// WithSort adds sorting options.
func (o FindingListOptions) WithSort(sort *pagination.SortOption) FindingListOptions {
	o.Sort = sort
	return o
}

// FindingAllowedSortFields returns the allowed sort fields for findings.
func FindingAllowedSortFields() map[string]string {
	return map[string]string{
		"severity":   "severity",
		"status":     "status",
		"source":     "source",
		"created_at": "created_at",
		"updated_at": "updated_at",
		"file_path":  "file_path",
		"tool_name":  "tool_name",
	}
}

// FindingFilter defines criteria for filtering findings.
type FindingFilter struct {
	TenantID        *shared.ID
	AssetID         *shared.ID // Reference to parent asset
	BranchID        *shared.ID // Optional: for repository assets, specific branch
	ComponentID     *shared.ID
	VulnerabilityID *shared.ID
	Severities      []Severity
	Statuses        []FindingStatus
	Sources         []FindingSource
	ToolName        *string
	RuleID          *string
	ScanID          *string
	FilePath        *string
	Search          *string // Full-text search across title, description, and file path

	// Finding type discriminator filters
	FindingTypes []FindingType

	// Specialized finding filters
	// Secret filters
	SecretType    *string
	SecretService *string
	SecretValid   *bool

	// Compliance filters
	ComplianceFramework *string
	ComplianceControlID *string
	ComplianceResult    *string

	// Web3 filters
	Web3Chain           *string
	Web3ContractAddress *string
	Web3SWCID           *string

	// Misconfiguration filters
	MisconfigPolicyID     *string
	MisconfigResourceType *string
}

// NewFindingFilter creates a new empty filter.
func NewFindingFilter() FindingFilter {
	return FindingFilter{}
}

// WithTenantID sets the tenant ID filter.
func (f FindingFilter) WithTenantID(tenantID shared.ID) FindingFilter {
	f.TenantID = &tenantID
	return f
}

// WithAssetID sets the asset ID filter.
func (f FindingFilter) WithAssetID(assetID shared.ID) FindingFilter {
	f.AssetID = &assetID
	return f
}

// WithBranchID sets the branch ID filter.
func (f FindingFilter) WithBranchID(branchID shared.ID) FindingFilter {
	f.BranchID = &branchID
	return f
}

// WithComponentID sets the component ID filter.
func (f FindingFilter) WithComponentID(compID shared.ID) FindingFilter {
	f.ComponentID = &compID
	return f
}

// WithVulnerabilityID sets the vulnerability ID filter.
func (f FindingFilter) WithVulnerabilityID(vulnID shared.ID) FindingFilter {
	f.VulnerabilityID = &vulnID
	return f
}

// WithSeverities sets the severities filter.
func (f FindingFilter) WithSeverities(severities ...Severity) FindingFilter {
	f.Severities = severities
	return f
}

// WithStatuses sets the statuses filter.
func (f FindingFilter) WithStatuses(statuses ...FindingStatus) FindingFilter {
	f.Statuses = statuses
	return f
}

// WithSources sets the sources filter.
func (f FindingFilter) WithSources(sources ...FindingSource) FindingFilter {
	f.Sources = sources
	return f
}

// WithToolName sets the tool name filter.
func (f FindingFilter) WithToolName(toolName string) FindingFilter {
	f.ToolName = &toolName
	return f
}

// WithRuleID sets the rule ID filter.
func (f FindingFilter) WithRuleID(ruleID string) FindingFilter {
	f.RuleID = &ruleID
	return f
}

// WithScanID sets the scan ID filter.
func (f FindingFilter) WithScanID(scanID string) FindingFilter {
	f.ScanID = &scanID
	return f
}

// WithFilePath sets the file path filter.
func (f FindingFilter) WithFilePath(filePath string) FindingFilter {
	f.FilePath = &filePath
	return f
}

// WithSearch sets the full-text search filter.
func (f FindingFilter) WithSearch(search string) FindingFilter {
	f.Search = &search
	return f
}

// IsEmpty checks if no filters are applied.
func (f FindingFilter) IsEmpty() bool {
	return f.TenantID == nil &&
		f.AssetID == nil &&
		f.BranchID == nil &&
		f.ComponentID == nil &&
		f.VulnerabilityID == nil &&
		len(f.Severities) == 0 &&
		len(f.Statuses) == 0 &&
		len(f.Sources) == 0 &&
		f.ToolName == nil &&
		f.RuleID == nil &&
		f.ScanID == nil &&
		f.FilePath == nil &&
		f.Search == nil
}

// FindingStats contains aggregated finding statistics.
type FindingStats struct {
	Total         int64
	BySeverity    map[Severity]int64
	ByStatus      map[FindingStatus]int64
	BySource      map[FindingSource]int64
	OpenCount     int64
	ResolvedCount int64
}

// NewFindingStats creates an empty FindingStats with initialized maps.
func NewFindingStats() *FindingStats {
	return &FindingStats{
		BySeverity: make(map[Severity]int64),
		ByStatus:   make(map[FindingStatus]int64),
		BySource:   make(map[FindingSource]int64),
	}
}

// FindingCommentRepository defines the interface for finding comment persistence.
type FindingCommentRepository interface {
	// Create persists a new comment.
	Create(ctx context.Context, comment *FindingComment) error

	// GetByID retrieves a comment by ID.
	GetByID(ctx context.Context, id shared.ID) (*FindingComment, error)

	// Update updates an existing comment.
	Update(ctx context.Context, comment *FindingComment) error

	// Delete removes a comment.
	Delete(ctx context.Context, id shared.ID) error

	// ListByFinding returns all comments for a finding.
	ListByFinding(ctx context.Context, findingID shared.ID) ([]*FindingComment, error)

	// CountByFinding counts comments for a finding.
	CountByFinding(ctx context.Context, findingID shared.ID) (int, error)
}

// FindingActivityRepository defines the interface for finding activity persistence.
// This is an APPEND-ONLY store - activities should never be updated or deleted.
type FindingActivityRepository interface {
	// Create persists a new activity record.
	Create(ctx context.Context, activity *FindingActivity) error

	// GetByID retrieves an activity by ID.
	GetByID(ctx context.Context, id shared.ID) (*FindingActivity, error)

	// ListByFinding returns activities for a finding with pagination.
	// Security: tenantID is required to ensure tenant isolation.
	ListByFinding(ctx context.Context, findingID shared.ID, tenantID shared.ID, filter FindingActivityFilter, page pagination.Pagination) (pagination.Result[*FindingActivity], error)

	// CountByFinding counts activities for a finding.
	// Security: tenantID is required to ensure tenant isolation.
	CountByFinding(ctx context.Context, findingID shared.ID, tenantID shared.ID, filter FindingActivityFilter) (int64, error)

	// ListByTenant returns activities for a tenant with pagination.
	ListByTenant(ctx context.Context, tenantID shared.ID, filter FindingActivityFilter, page pagination.Pagination) (pagination.Result[*FindingActivity], error)
}

// FindingActivityFilter defines criteria for filtering activities.
type FindingActivityFilter struct {
	ActivityTypes []ActivityType
	ActorTypes    []ActorType
	ActorIDs      []shared.ID
	Sources       []ActivitySource
	Since         *time.Time
	Until         *time.Time
}

// NewFindingActivityFilter creates a new empty filter.
func NewFindingActivityFilter() FindingActivityFilter {
	return FindingActivityFilter{}
}

// WithActivityTypes filters by activity types.
func (f FindingActivityFilter) WithActivityTypes(types ...ActivityType) FindingActivityFilter {
	f.ActivityTypes = types
	return f
}

// WithActorTypes filters by actor types.
func (f FindingActivityFilter) WithActorTypes(types ...ActorType) FindingActivityFilter {
	f.ActorTypes = types
	return f
}

// WithSince filters activities after a time.
func (f FindingActivityFilter) WithSince(t time.Time) FindingActivityFilter {
	f.Since = &t
	return f
}

// WithUntil filters activities before a time.
func (f FindingActivityFilter) WithUntil(t time.Time) FindingActivityFilter {
	f.Until = &t
	return f
}

// =============================================================================
// Extended FindingFilter Methods for Specialized Finding Types
// =============================================================================

// WithFindingTypes filters by finding types.
func (f FindingFilter) WithFindingTypes(types ...FindingType) FindingFilter {
	f.FindingTypes = types
	return f
}

// WithSecretType filters by secret type.
func (f FindingFilter) WithSecretType(secretType string) FindingFilter {
	f.SecretType = &secretType
	return f
}

// WithSecretService filters by secret service.
func (f FindingFilter) WithSecretService(secretService string) FindingFilter {
	f.SecretService = &secretService
	return f
}

// WithSecretValid filters by secret validity.
func (f FindingFilter) WithSecretValid(valid bool) FindingFilter {
	f.SecretValid = &valid
	return f
}

// WithComplianceFramework filters by compliance framework.
func (f FindingFilter) WithComplianceFramework(framework string) FindingFilter {
	f.ComplianceFramework = &framework
	return f
}

// WithComplianceControlID filters by compliance control ID.
func (f FindingFilter) WithComplianceControlID(controlID string) FindingFilter {
	f.ComplianceControlID = &controlID
	return f
}

// WithComplianceResult filters by compliance result.
func (f FindingFilter) WithComplianceResult(result string) FindingFilter {
	f.ComplianceResult = &result
	return f
}

// WithWeb3Chain filters by blockchain chain.
func (f FindingFilter) WithWeb3Chain(chain string) FindingFilter {
	f.Web3Chain = &chain
	return f
}

// WithWeb3ContractAddress filters by smart contract address.
func (f FindingFilter) WithWeb3ContractAddress(address string) FindingFilter {
	f.Web3ContractAddress = &address
	return f
}

// WithWeb3SWCID filters by SWC ID.
func (f FindingFilter) WithWeb3SWCID(swcID string) FindingFilter {
	f.Web3SWCID = &swcID
	return f
}

// WithMisconfigPolicyID filters by misconfiguration policy ID.
func (f FindingFilter) WithMisconfigPolicyID(policyID string) FindingFilter {
	f.MisconfigPolicyID = &policyID
	return f
}

// WithMisconfigResourceType filters by misconfiguration resource type.
func (f FindingFilter) WithMisconfigResourceType(resourceType string) FindingFilter {
	f.MisconfigResourceType = &resourceType
	return f
}

// =============================================================================
// Data Flow Repository Interface
// =============================================================================

// DataFlowRepository defines the interface for finding data flow persistence.
type DataFlowRepository interface {
	// CreateDataFlow persists a new data flow.
	CreateDataFlow(ctx context.Context, flow *FindingDataFlow) error

	// CreateDataFlowBatch persists multiple data flows.
	CreateDataFlowBatch(ctx context.Context, flows []*FindingDataFlow) error

	// GetDataFlowByID retrieves a data flow by ID.
	GetDataFlowByID(ctx context.Context, id shared.ID) (*FindingDataFlow, error)

	// ListDataFlowsByFinding retrieves all data flows for a finding.
	ListDataFlowsByFinding(ctx context.Context, findingID shared.ID) ([]*FindingDataFlow, error)

	// GetDataFlowsWithLocations retrieves all data flows for a finding with their locations in a single query.
	// This is an optimized method to avoid N+1 queries when loading data flows.
	// Returns a map of flow ID -> []FlowLocation for efficient lookup.
	GetDataFlowsWithLocations(ctx context.Context, findingID shared.ID) ([]*FindingDataFlow, map[string][]*FindingFlowLocation, error)

	// GetDataFlowsWithLocationsByTenant retrieves data flows with tenant verification.
	// SECURITY: Provides defense-in-depth by verifying finding belongs to tenant.
	// Use when tenant context is available to prevent IDOR attacks.
	GetDataFlowsWithLocationsByTenant(ctx context.Context, findingID, tenantID shared.ID) ([]*FindingDataFlow, map[string][]*FindingFlowLocation, error)

	// DeleteDataFlowsByFinding removes all data flows for a finding.
	DeleteDataFlowsByFinding(ctx context.Context, findingID shared.ID) error

	// CreateFlowLocation persists a new flow location.
	CreateFlowLocation(ctx context.Context, location *FindingFlowLocation) error

	// CreateFlowLocationBatch persists multiple flow locations.
	CreateFlowLocationBatch(ctx context.Context, locations []*FindingFlowLocation) error

	// GetFlowLocationByID retrieves a flow location by ID.
	GetFlowLocationByID(ctx context.Context, id shared.ID) (*FindingFlowLocation, error)

	// ListFlowLocationsByDataFlow retrieves all locations for a data flow.
	ListFlowLocationsByDataFlow(ctx context.Context, dataFlowID shared.ID) ([]*FindingFlowLocation, error)

	// ListFlowLocationsByFile retrieves all flow locations in a file for a specific tenant.
	// SECURITY: Requires tenantID to enforce tenant isolation.
	// Useful for attack path analysis: "find all data flows through this file".
	ListFlowLocationsByFile(ctx context.Context, tenantID shared.ID, filePath string, page pagination.Pagination) (pagination.Result[*FindingFlowLocation], error)

	// ListFlowLocationsByFunction retrieves all flow locations in a function for a specific tenant.
	// SECURITY: Requires tenantID to enforce tenant isolation.
	// Useful for attack path analysis: "find all data flows through this function".
	ListFlowLocationsByFunction(ctx context.Context, tenantID shared.ID, functionName string, page pagination.Pagination) (pagination.Result[*FindingFlowLocation], error)

	// ListSourcesAndSinks retrieves all source and sink locations for a finding.
	// Useful for displaying the entry/exit points of taint tracking.
	ListSourcesAndSinks(ctx context.Context, findingID shared.ID) ([]*FindingFlowLocation, error)

	// DeleteFlowLocationsByDataFlow removes all locations for a data flow.
	DeleteFlowLocationsByDataFlow(ctx context.Context, dataFlowID shared.ID) error
}
