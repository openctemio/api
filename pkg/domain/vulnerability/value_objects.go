// Package vulnerability provides the vulnerability domain model.
package vulnerability

import (
	"fmt"
	"slices"
	"strings"
	"time"
)

// Severity represents the vulnerability severity level.
type Severity string

const (
	SeverityCritical Severity = "critical"
	SeverityHigh     Severity = "high"
	SeverityMedium   Severity = "medium"
	SeverityLow      Severity = "low"
	SeverityInfo     Severity = "info"
	SeverityNone     Severity = "none"
)

// AllSeverities returns all valid severities.
func AllSeverities() []Severity {
	return []Severity{
		SeverityCritical,
		SeverityHigh,
		SeverityMedium,
		SeverityLow,
		SeverityInfo,
		SeverityNone,
	}
}

// IsValid checks if the severity is valid.
func (s Severity) IsValid() bool {
	switch s {
	case SeverityCritical, SeverityHigh, SeverityMedium, SeverityLow, SeverityInfo, SeverityNone:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (s Severity) String() string {
	return string(s)
}

// Score returns a numeric score for the severity (0-10).
func (s Severity) Score() float64 {
	switch s {
	case SeverityCritical:
		return 10.0
	case SeverityHigh:
		return 7.5
	case SeverityMedium:
		return 5.0
	case SeverityLow:
		return 2.5
	case SeverityInfo:
		return 1.0
	case SeverityNone:
		return 0.0
	default:
		return 5.0
	}
}

// Weight returns a weight for risk calculation.
func (s Severity) Weight() float64 {
	switch s {
	case SeverityCritical:
		return 10.0
	case SeverityHigh:
		return 7.5
	case SeverityMedium:
		return 5.0
	case SeverityLow:
		return 2.5
	case SeverityInfo:
		return 1.0
	case SeverityNone:
		return 0.5
	default:
		return 5.0
	}
}

// ParseSeverity parses a string into a Severity.
func ParseSeverity(s string) (Severity, error) {
	sev := Severity(strings.ToLower(strings.TrimSpace(s)))
	if !sev.IsValid() {
		return "", fmt.Errorf("invalid severity: %s", s)
	}
	return sev, nil
}

// SeverityFromCVSS returns a Severity based on CVSS score.
func SeverityFromCVSS(score float64) Severity {
	switch {
	case score >= 9.0:
		return SeverityCritical
	case score >= 7.0:
		return SeverityHigh
	case score >= 4.0:
		return SeverityMedium
	case score >= 0.1:
		return SeverityLow
	default:
		return SeverityNone
	}
}

// ExploitMaturity represents the exploit maturity level.
type ExploitMaturity string

const (
	ExploitMaturityNone           ExploitMaturity = "none"
	ExploitMaturityProofOfConcept ExploitMaturity = "poc"
	ExploitMaturityFunctional     ExploitMaturity = "functional"
	ExploitMaturityWeaponized     ExploitMaturity = "weaponized"
)

// IsValid checks if the exploit maturity is valid.
func (e ExploitMaturity) IsValid() bool {
	switch e {
	case ExploitMaturityNone, ExploitMaturityProofOfConcept, ExploitMaturityFunctional, ExploitMaturityWeaponized:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (e ExploitMaturity) String() string {
	return string(e)
}

// FindingSource represents the source/type of a finding.
//
// ## Architecture
//
// Finding sources are managed in two layers:
//
//  1. **Database layer** (finding_sources table): Dynamic configuration for UI dropdowns,
//     metadata (icons, colors, categories), and runtime validation. Managed by
//     FindingSourceService and FindingSourceCacheService.
//
//  2. **Code layer** (constants below): Compile-time type safety for domain logic,
//     switch statements, and tests. These constants must match the `code` field in
//     the finding_sources database table.
//
// ## When to use what:
//
// - Use FindingSourceCacheService.IsValidCode() for validating user input at runtime
// - Use the constants below for domain logic and tests (type safety)
// - The constants are kept in sync with the database via migration 000142_finding_sources
//
// ## Adding new sources:
//
// 1. Add a migration to insert the new source into finding_sources table
// 2. Add a constant below with matching code
// 3. Update IsValid() and AllFindingSources()
type FindingSource string

const (
	// AppSec Scanning sources
	FindingSourceSAST      FindingSource = "sast"      // Static Application Security Testing (Semgrep, CodeQL, etc.)
	FindingSourceDAST      FindingSource = "dast"      // Dynamic Application Security Testing (ZAP, Burp, Nuclei)
	FindingSourceSCA       FindingSource = "sca"       // Software Composition Analysis (Trivy, Snyk, Grype)
	FindingSourceSecret    FindingSource = "secret"    // Secret Detection (Gitleaks, Trufflehog)
	FindingSourceIaC       FindingSource = "iac"       // Infrastructure as Code (Checkov, Tfsec)
	FindingSourceContainer FindingSource = "container" // Container Scanning

	// Cloud & Infrastructure sources
	FindingSourceCSPM FindingSource = "cspm" // Cloud Security Posture Management (Wiz, Prisma Cloud)
	FindingSourceEASM FindingSource = "easm" // External Attack Surface Management (Censys, Shodan)

	// Runtime & Production sources
	FindingSourceRASP FindingSource = "rasp" // Runtime Application Self-Protection
	FindingSourceWAF  FindingSource = "waf"  // Web Application Firewall
	FindingSourceSIEM FindingSource = "siem" // Security Information and Event Management

	// Manual/Human sources
	FindingSourceManual    FindingSource = "manual"     // Manual findings/code review
	FindingSourcePentest   FindingSource = "pentest"    // Penetration testing engagement
	FindingSourceBugBounty FindingSource = "bug_bounty" // Bug bounty program
	FindingSourceRedTeam   FindingSource = "red_team"   // Red team exercise

	// External sources
	FindingSourceExternal    FindingSource = "external"     // Imported from external tools
	FindingSourceThreatIntel FindingSource = "threat_intel" // Threat intelligence feeds
	FindingSourceVendor      FindingSource = "vendor"       // Vendor security assessments

	// Legacy aliases for backward compatibility
	FindingSourceSARIF   FindingSource = "sarif"    // SARIF format (legacy)
	FindingSourceSCATool FindingSource = "sca_tool" // Legacy SCA alias
)

// AllFindingSources returns all valid finding sources (primary only, excluding legacy).
func AllFindingSources() []FindingSource {
	return []FindingSource{
		// AppSec
		FindingSourceSAST,
		FindingSourceDAST,
		FindingSourceSCA,
		FindingSourceSecret,
		FindingSourceIaC,
		FindingSourceContainer,
		// Cloud & Infra
		FindingSourceCSPM,
		FindingSourceEASM,
		// Runtime
		FindingSourceRASP,
		FindingSourceWAF,
		FindingSourceSIEM,
		// Manual
		FindingSourceManual,
		FindingSourcePentest,
		FindingSourceBugBounty,
		FindingSourceRedTeam,
		// External
		FindingSourceExternal,
		FindingSourceThreatIntel,
		FindingSourceVendor,
	}
}

// IsValid checks if the finding source is valid.
// NOTE: This performs static validation. For dynamic validation against the database,
// use the FindingSourceService.IsValidSourceCode() method.
func (f FindingSource) IsValid() bool {
	switch f {
	// AppSec sources
	case FindingSourceSAST, FindingSourceDAST, FindingSourceSCA,
		FindingSourceSecret, FindingSourceIaC, FindingSourceContainer:
		return true
	// Cloud & Infrastructure sources
	case FindingSourceCSPM, FindingSourceEASM:
		return true
	// Runtime sources
	case FindingSourceRASP, FindingSourceWAF, FindingSourceSIEM:
		return true
	// Manual sources
	case FindingSourceManual, FindingSourcePentest, FindingSourceBugBounty, FindingSourceRedTeam:
		return true
	// External sources
	case FindingSourceExternal, FindingSourceThreatIntel, FindingSourceVendor:
		return true
	// Legacy support
	case FindingSourceSARIF, FindingSourceSCATool:
		return true
	default:
		return false
	}
}

// Normalize converts legacy source values to canonical values.
func (f FindingSource) Normalize() FindingSource {
	switch f {
	case FindingSourceSCATool:
		return FindingSourceSCA
	case FindingSourceSARIF:
		return FindingSourceSAST // SARIF typically from SAST tools
	default:
		return f
	}
}

// String returns the string representation.
func (f FindingSource) String() string {
	return string(f)
}

// ParseFindingSource parses a string into a FindingSource.
func ParseFindingSource(s string) (FindingSource, error) {
	src := FindingSource(strings.ToLower(strings.TrimSpace(s)))
	if !src.IsValid() {
		return "", fmt.Errorf("invalid finding source: %s", s)
	}
	return src, nil
}

// FindingType represents the type/category of a finding.
// This is a discriminator for polymorphic behavior (fingerprinting, detail storage).
type FindingType string

const (
	// FindingTypeVulnerability represents code vulnerabilities (SAST/DAST/SCA findings).
	FindingTypeVulnerability FindingType = "vulnerability"
	// FindingTypeSecret represents exposed secrets/credentials.
	FindingTypeSecret FindingType = "secret"
	// FindingTypeMisconfiguration represents IaC/infrastructure misconfigurations.
	FindingTypeMisconfiguration FindingType = "misconfiguration"
	// FindingTypeCompliance represents compliance check failures.
	FindingTypeCompliance FindingType = "compliance"
	// FindingTypeWeb3 represents blockchain/smart contract vulnerabilities.
	FindingTypeWeb3 FindingType = "web3"
)

// AllFindingTypes returns all valid finding types.
func AllFindingTypes() []FindingType {
	return []FindingType{
		FindingTypeVulnerability,
		FindingTypeSecret,
		FindingTypeMisconfiguration,
		FindingTypeCompliance,
		FindingTypeWeb3,
	}
}

// IsValid checks if the finding type is valid.
func (t FindingType) IsValid() bool {
	switch t {
	case FindingTypeVulnerability, FindingTypeSecret, FindingTypeMisconfiguration,
		FindingTypeCompliance, FindingTypeWeb3, "":
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (t FindingType) String() string {
	return string(t)
}

// ParseFindingType parses a string into a FindingType.
func ParseFindingType(s string) (FindingType, error) {
	if s == "" {
		return "", nil
	}
	ft := FindingType(strings.ToLower(strings.TrimSpace(s)))
	if !ft.IsValid() {
		return "", fmt.Errorf("invalid finding type: %s", s)
	}
	return ft, nil
}

// InferFromSource infers the FindingType from a FindingSource.
func (t FindingType) InferFromSource(source FindingSource) FindingType {
	switch source {
	case FindingSourceSecret:
		return FindingTypeSecret
	case FindingSourceIaC:
		return FindingTypeMisconfiguration
	default:
		return FindingTypeVulnerability
	}
}

// FindingStatus represents the status of a finding.
// Simplified workflow: new → confirmed → in_progress → resolved
// Terminal states: false_positive, accepted, duplicate (can reopen to confirmed)
type FindingStatus string

const (
	// Open states (needs action)
	FindingStatusNew        FindingStatus = "new"         // Scanner just found it
	FindingStatusConfirmed  FindingStatus = "confirmed"   // Verified as real issue, needs fix
	FindingStatusInProgress FindingStatus = "in_progress" // Developer working on fix

	// Closed states
	FindingStatusResolved      FindingStatus = "resolved"       // Fix applied - finding is remediated
	FindingStatusFalsePositive FindingStatus = "false_positive" // Not a real issue (requires approval)
	FindingStatusAccepted      FindingStatus = "accepted"       // Risk accepted (requires approval, has expiration)
	FindingStatusDuplicate     FindingStatus = "duplicate"      // Linked to another finding
)

// StatusCategory represents the category of a finding status.
type StatusCategory string

const (
	StatusCategoryOpen       StatusCategory = "open"        // Needs action
	StatusCategoryInProgress StatusCategory = "in_progress" // Work underway
	StatusCategoryClosed     StatusCategory = "closed"      // No action needed
)

// statusCategories maps each status to its category.
var statusCategories = map[FindingStatus]StatusCategory{
	FindingStatusNew:           StatusCategoryOpen,
	FindingStatusConfirmed:     StatusCategoryOpen,
	FindingStatusInProgress:    StatusCategoryInProgress,
	FindingStatusResolved:      StatusCategoryClosed,
	FindingStatusFalsePositive: StatusCategoryClosed,
	FindingStatusAccepted:      StatusCategoryClosed,
	FindingStatusDuplicate:     StatusCategoryClosed,
}

// AllFindingStatuses returns all valid finding statuses.
func AllFindingStatuses() []FindingStatus {
	return []FindingStatus{
		FindingStatusNew,
		FindingStatusConfirmed,
		FindingStatusInProgress,
		FindingStatusResolved,
		FindingStatusFalsePositive,
		FindingStatusAccepted,
		FindingStatusDuplicate,
	}
}

// ActiveFindingStatuses returns statuses that count as "active" findings (need action).
func ActiveFindingStatuses() []FindingStatus {
	return []FindingStatus{
		FindingStatusNew,
		FindingStatusConfirmed,
		FindingStatusInProgress,
	}
}

// IsValid checks if the finding status is valid.
func (f FindingStatus) IsValid() bool {
	switch f {
	case FindingStatusNew, FindingStatusConfirmed, FindingStatusInProgress,
		FindingStatusResolved, FindingStatusFalsePositive, FindingStatusAccepted, FindingStatusDuplicate:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (f FindingStatus) String() string {
	return string(f)
}

// Category returns the status category.
func (f FindingStatus) Category() StatusCategory {
	if cat, ok := statusCategories[f]; ok {
		return cat
	}
	return StatusCategoryOpen
}

// IsOpen checks if the status represents an open finding (needs action).
func (f FindingStatus) IsOpen() bool {
	cat := f.Category()
	return cat == StatusCategoryOpen || cat == StatusCategoryInProgress
}

// IsClosed checks if the status represents a closed finding.
func (f FindingStatus) IsClosed() bool {
	return f.Category() == StatusCategoryClosed
}

// IsResolved checks if the finding has been remediated.
func (f FindingStatus) IsResolved() bool {
	return f == FindingStatusResolved
}

// RequiresApproval checks if transitioning to this status requires approval.
func (f FindingStatus) RequiresApproval() bool {
	return f == FindingStatusFalsePositive || f == FindingStatusAccepted
}

// ParseFindingStatus parses a string into a FindingStatus.
func ParseFindingStatus(s string) (FindingStatus, error) {
	status := FindingStatus(strings.ToLower(strings.TrimSpace(s)))
	if !status.IsValid() {
		return "", fmt.Errorf("invalid finding status: %s", s)
	}
	return status, nil
}

// ValidStatusTransitions defines valid status transitions.
// Workflow: new → confirmed → in_progress → resolved
// Terminal: false_positive, accepted, duplicate (can reopen to confirmed)
var ValidStatusTransitions = map[FindingStatus][]FindingStatus{
	// Open states
	FindingStatusNew: {
		FindingStatusConfirmed,
		FindingStatusDuplicate,
		FindingStatusFalsePositive, // requires approval
	},
	FindingStatusConfirmed: {
		FindingStatusInProgress,
		FindingStatusResolved, // direct fix without assignment
		FindingStatusDuplicate,
		FindingStatusFalsePositive, // requires approval
		FindingStatusAccepted,      // requires approval
	},
	// In progress
	FindingStatusInProgress: {
		FindingStatusResolved,
		FindingStatusConfirmed, // back to backlog
	},
	// Closed states (can reopen to confirmed)
	FindingStatusResolved:      {FindingStatusConfirmed}, // reopen if fix didn't work
	FindingStatusFalsePositive: {FindingStatusConfirmed},
	FindingStatusAccepted:      {FindingStatusConfirmed},
	FindingStatusDuplicate:     {FindingStatusConfirmed},
}

// CanTransitionTo checks if a status can transition to another status.
func (f FindingStatus) CanTransitionTo(target FindingStatus) bool {
	validTargets, ok := ValidStatusTransitions[f]
	if !ok {
		return false
	}
	return slices.Contains(validTargets, target)
}

// GetValidTransitions returns the valid transitions for this status.
func (f FindingStatus) GetValidTransitions() []FindingStatus {
	if transitions, ok := ValidStatusTransitions[f]; ok {
		return transitions
	}
	return nil
}

// VulnerabilityStatus represents the status of a vulnerability.
type VulnerabilityStatus string

const (
	VulnerabilityStatusOpen        VulnerabilityStatus = "open"
	VulnerabilityStatusPatched     VulnerabilityStatus = "patched"
	VulnerabilityStatusMitigated   VulnerabilityStatus = "mitigated"
	VulnerabilityStatusNotAffected VulnerabilityStatus = "not_affected"
)

// IsValid checks if the vulnerability status is valid.
func (v VulnerabilityStatus) IsValid() bool {
	switch v {
	case VulnerabilityStatusOpen, VulnerabilityStatusPatched,
		VulnerabilityStatusMitigated, VulnerabilityStatusNotAffected:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (v VulnerabilityStatus) String() string {
	return string(v)
}

// CISAKEV represents CISA Known Exploited Vulnerabilities data.
type CISAKEV struct {
	dateAdded     time.Time
	dueDate       time.Time
	ransomwareUse string
	notes         string
}

// NewCISAKEV creates a new CISAKEV.
func NewCISAKEV(dateAdded, dueDate time.Time, ransomwareUse, notes string) CISAKEV {
	return CISAKEV{
		dateAdded:     dateAdded,
		dueDate:       dueDate,
		ransomwareUse: ransomwareUse,
		notes:         notes,
	}
}

// DateAdded returns the date added to KEV.
func (c CISAKEV) DateAdded() time.Time {
	return c.dateAdded
}

// DueDate returns the remediation due date.
func (c CISAKEV) DueDate() time.Time {
	return c.dueDate
}

// RansomwareUse returns ransomware use info.
func (c CISAKEV) RansomwareUse() string {
	return c.ransomwareUse
}

// Notes returns additional notes.
func (c CISAKEV) Notes() string {
	return c.notes
}

// IsZero checks if the CISAKEV is empty.
func (c CISAKEV) IsZero() bool {
	return c.dateAdded.IsZero()
}

// IsPastDue checks if the due date has passed.
func (c CISAKEV) IsPastDue() bool {
	return !c.dueDate.IsZero() && time.Now().After(c.dueDate)
}

// Reference represents a reference URL.
type Reference struct {
	refType string
	url     string
}

// NewReference creates a new Reference.
func NewReference(refType, url string) Reference {
	return Reference{refType: refType, url: url}
}

// Type returns the reference type.
func (r Reference) Type() string {
	return r.refType
}

// URL returns the reference URL.
func (r Reference) URL() string {
	return r.url
}

// AffectedVersion represents an affected version range.
type AffectedVersion struct {
	ecosystem  string
	pkg        string
	introduced string
	fixed      string
}

// NewAffectedVersion creates a new AffectedVersion.
func NewAffectedVersion(ecosystem, pkg, introduced, fixed string) AffectedVersion {
	return AffectedVersion{
		ecosystem:  ecosystem,
		pkg:        pkg,
		introduced: introduced,
		fixed:      fixed,
	}
}

// Ecosystem returns the ecosystem.
func (a AffectedVersion) Ecosystem() string {
	return a.ecosystem
}

// Package returns the package name.
func (a AffectedVersion) Package() string {
	return a.pkg
}

// Introduced returns the introduced version.
func (a AffectedVersion) Introduced() string {
	return a.introduced
}

// Fixed returns the fixed version.
func (a AffectedVersion) Fixed() string {
	return a.fixed
}

// NOTE: TriageStatus has been removed - use FindingStatus workflow instead
// status = "new" means not triaged, any other status means triaged

// SLAStatus represents the SLA compliance status of a finding.
type SLAStatus string

const (
	SLAStatusOnTrack       SLAStatus = "on_track"
	SLAStatusWarning       SLAStatus = "warning"
	SLAStatusOverdue       SLAStatus = "overdue"
	SLAStatusExceeded      SLAStatus = "exceeded"
	SLAStatusNotApplicable SLAStatus = "not_applicable"
)

// AllSLAStatuses returns all valid SLA statuses.
func AllSLAStatuses() []SLAStatus {
	return []SLAStatus{
		SLAStatusOnTrack,
		SLAStatusWarning,
		SLAStatusOverdue,
		SLAStatusExceeded,
		SLAStatusNotApplicable,
	}
}

// IsValid checks if the SLA status is valid.
func (s SLAStatus) IsValid() bool {
	switch s {
	case SLAStatusOnTrack, SLAStatusWarning, SLAStatusOverdue,
		SLAStatusExceeded, SLAStatusNotApplicable:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (s SLAStatus) String() string {
	return string(s)
}

// IsAtRisk checks if the SLA status indicates risk.
func (s SLAStatus) IsAtRisk() bool {
	return s == SLAStatusWarning || s == SLAStatusOverdue || s == SLAStatusExceeded
}

// IsOverdue checks if the SLA has been missed.
func (s SLAStatus) IsOverdue() bool {
	return s == SLAStatusOverdue || s == SLAStatusExceeded
}

// ParseSLAStatus parses a string into an SLAStatus.
func ParseSLAStatus(s string) (SLAStatus, error) {
	status := SLAStatus(strings.ToLower(strings.TrimSpace(s)))
	if !status.IsValid() {
		return SLAStatusNotApplicable, fmt.Errorf("invalid SLA status: %s", s)
	}
	return status, nil
}

// =============================================================================
// CTEM: Exposure Vector
// =============================================================================

// ExposureVector represents how a finding can be exploited.
type ExposureVector string

const (
	ExposureVectorNetwork     ExposureVector = "network"      // Remotely exploitable over network
	ExposureVectorLocal       ExposureVector = "local"        // Local access required
	ExposureVectorPhysical    ExposureVector = "physical"     // Physical access required
	ExposureVectorAdjacentNet ExposureVector = "adjacent_net" // Same network segment required
	ExposureVectorUnknown     ExposureVector = "unknown"      // Unknown exposure vector
)

// AllExposureVectors returns all valid exposure vectors.
func AllExposureVectors() []ExposureVector {
	return []ExposureVector{
		ExposureVectorNetwork,
		ExposureVectorLocal,
		ExposureVectorPhysical,
		ExposureVectorAdjacentNet,
		ExposureVectorUnknown,
	}
}

// IsValid checks if the exposure vector is valid.
func (e ExposureVector) IsValid() bool {
	switch e {
	case ExposureVectorNetwork, ExposureVectorLocal, ExposureVectorPhysical,
		ExposureVectorAdjacentNet, ExposureVectorUnknown:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (e ExposureVector) String() string {
	return string(e)
}

// RiskMultiplier returns a risk multiplier based on exposure vector.
func (e ExposureVector) RiskMultiplier() float64 {
	switch e {
	case ExposureVectorNetwork:
		return 1.5
	case ExposureVectorAdjacentNet:
		return 1.3
	case ExposureVectorLocal:
		return 1.0
	case ExposureVectorPhysical:
		return 0.8
	case ExposureVectorUnknown:
		return 1.0
	default:
		return 1.0
	}
}

// ParseExposureVector parses a string into an ExposureVector.
func ParseExposureVector(s string) (ExposureVector, error) {
	if s == "" {
		return ExposureVectorUnknown, nil
	}
	ev := ExposureVector(strings.ToLower(strings.TrimSpace(s)))
	if !ev.IsValid() {
		return ExposureVectorUnknown, fmt.Errorf("invalid exposure vector: %s", s)
	}
	return ev, nil
}

// =============================================================================
// CTEM: Remediation Type
// =============================================================================

// RemediationType represents the type of remediation required.
type RemediationType string

const (
	RemediationTypePatch      RemediationType = "patch"         // Apply a patch
	RemediationTypeUpgrade    RemediationType = "upgrade"       // Upgrade to newer version
	RemediationTypeWorkaround RemediationType = "workaround"    // Apply a workaround
	RemediationTypeConfig     RemediationType = "config_change" // Configuration change
	RemediationTypeMitigate   RemediationType = "mitigate"      // Apply mitigation controls
	RemediationTypeAcceptRisk RemediationType = "accept_risk"   // Accept the risk
)

// AllRemediationTypes returns all valid remediation types.
func AllRemediationTypes() []RemediationType {
	return []RemediationType{
		RemediationTypePatch,
		RemediationTypeUpgrade,
		RemediationTypeWorkaround,
		RemediationTypeConfig,
		RemediationTypeMitigate,
		RemediationTypeAcceptRisk,
	}
}

// IsValid checks if the remediation type is valid.
func (r RemediationType) IsValid() bool {
	switch r {
	case RemediationTypePatch, RemediationTypeUpgrade, RemediationTypeWorkaround,
		RemediationTypeConfig, RemediationTypeMitigate, RemediationTypeAcceptRisk:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (r RemediationType) String() string {
	return string(r)
}

// ParseRemediationType parses a string into a RemediationType.
func ParseRemediationType(s string) (RemediationType, error) {
	if s == "" {
		return "", nil
	}
	rt := RemediationType(strings.ToLower(strings.TrimSpace(s)))
	if !rt.IsValid() {
		return "", fmt.Errorf("invalid remediation type: %s", s)
	}
	return rt, nil
}

// =============================================================================
// CTEM: Fix Complexity
// =============================================================================

// FixComplexity represents the complexity of fixing a finding.
type FixComplexity string

const (
	FixComplexitySimple   FixComplexity = "simple"   // < 1 hour
	FixComplexityModerate FixComplexity = "moderate" // 1-8 hours
	FixComplexityComplex  FixComplexity = "complex"  // > 8 hours
)

// AllFixComplexities returns all valid fix complexities.
func AllFixComplexities() []FixComplexity {
	return []FixComplexity{
		FixComplexitySimple,
		FixComplexityModerate,
		FixComplexityComplex,
	}
}

// IsValid checks if the fix complexity is valid.
func (f FixComplexity) IsValid() bool {
	switch f {
	case FixComplexitySimple, FixComplexityModerate, FixComplexityComplex:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (f FixComplexity) String() string {
	return string(f)
}

// EstimatedMinutes returns the estimated minutes to fix based on complexity.
func (f FixComplexity) EstimatedMinutes() int {
	switch f {
	case FixComplexitySimple:
		return 30
	case FixComplexityModerate:
		return 240 // 4 hours
	case FixComplexityComplex:
		return 960 // 16 hours (2 days)
	default:
		return 120 // 2 hours default
	}
}

// ParseFixComplexity parses a string into a FixComplexity.
func ParseFixComplexity(s string) (FixComplexity, error) {
	if s == "" {
		return "", nil
	}
	fc := FixComplexity(strings.ToLower(strings.TrimSpace(s)))
	if !fc.IsValid() {
		return "", fmt.Errorf("invalid fix complexity: %s", s)
	}
	return fc, nil
}

// =============================================================================
// Auto-Fix: Regex-based Fix Pattern
// =============================================================================

// FixRegex contains regex-based auto-fix information.
// Used by tools like Semgrep that provide regex replacement patterns.
type FixRegex struct {
	Regex       string `json:"regex,omitempty"`       // Regular expression pattern to match
	Replacement string `json:"replacement,omitempty"` // Replacement string (may contain capture groups like $1, $2)
	Count       int    `json:"count,omitempty"`       // Number of replacements (0 = all)
}

// IsEmpty checks if the fix regex is empty.
func (f *FixRegex) IsEmpty() bool {
	return f == nil || (f.Regex == "" && f.Replacement == "")
}

// =============================================================================
// Remediation: Consolidated Remediation Information
// =============================================================================

// FindingRemediation contains all remediation information for a finding.
// Stored as JSONB in the database for flexibility and extensibility.
type FindingRemediation struct {
	// Human-readable recommendation text (guidance on how to fix)
	Recommendation string `json:"recommendation,omitempty"`

	// Actual code fix to apply (for auto-fix features)
	FixCode string `json:"fix_code,omitempty"`

	// Regex-based fix pattern
	FixRegex *FixRegex `json:"fix_regex,omitempty"`

	// Step-by-step remediation instructions
	Steps []string `json:"steps,omitempty"`

	// Reference URLs for more information
	References []string `json:"references,omitempty"`

	// Effort estimate: trivial, low, medium, high
	Effort string `json:"effort,omitempty"`

	// Whether a fix is available
	FixAvailable bool `json:"fix_available,omitempty"`

	// Whether the fix can be auto-applied
	AutoFixable bool `json:"auto_fixable,omitempty"`
}

// IsEmpty checks if the remediation is empty.
func (r *FindingRemediation) IsEmpty() bool {
	if r == nil {
		return true
	}
	return r.Recommendation == "" &&
		r.FixCode == "" &&
		r.FixRegex.IsEmpty() &&
		len(r.Steps) == 0 &&
		len(r.References) == 0
}

// HasFix checks if remediation has any fix available.
func (r *FindingRemediation) HasFix() bool {
	if r == nil {
		return false
	}
	return r.FixCode != "" || !r.FixRegex.IsEmpty()
}

// =============================================================================
// CTEM: Data Exposure Risk
// =============================================================================

// DataExposureRisk represents the risk of data exposure from a finding.
type DataExposureRisk string

const (
	DataExposureRiskNone     DataExposureRisk = "none"     // No data exposure risk
	DataExposureRiskLow      DataExposureRisk = "low"      // Low data exposure risk
	DataExposureRiskMedium   DataExposureRisk = "medium"   // Medium data exposure risk
	DataExposureRiskHigh     DataExposureRisk = "high"     // High data exposure risk
	DataExposureRiskCritical DataExposureRisk = "critical" // Critical data exposure risk
)

// AllDataExposureRisks returns all valid data exposure risks.
func AllDataExposureRisks() []DataExposureRisk {
	return []DataExposureRisk{
		DataExposureRiskNone,
		DataExposureRiskLow,
		DataExposureRiskMedium,
		DataExposureRiskHigh,
		DataExposureRiskCritical,
	}
}

// IsValid checks if the data exposure risk is valid.
func (d DataExposureRisk) IsValid() bool {
	switch d {
	case DataExposureRiskNone, DataExposureRiskLow, DataExposureRiskMedium,
		DataExposureRiskHigh, DataExposureRiskCritical:
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (d DataExposureRisk) String() string {
	return string(d)
}

// RiskMultiplier returns a risk multiplier based on data exposure risk.
func (d DataExposureRisk) RiskMultiplier() float64 {
	switch d {
	case DataExposureRiskCritical:
		return 2.0
	case DataExposureRiskHigh:
		return 1.7
	case DataExposureRiskMedium:
		return 1.4
	case DataExposureRiskLow:
		return 1.1
	case DataExposureRiskNone:
		return 1.0
	default:
		return 1.0
	}
}

// ParseDataExposureRisk parses a string into a DataExposureRisk.
func ParseDataExposureRisk(s string) (DataExposureRisk, error) {
	if s == "" {
		return DataExposureRiskNone, nil
	}
	der := DataExposureRisk(strings.ToLower(strings.TrimSpace(s)))
	if !der.IsValid() {
		return DataExposureRiskNone, fmt.Errorf("invalid data exposure risk: %s", s)
	}
	return der, nil
}

// =============================================================================
// SARIF 2.1.0 Value Objects
// =============================================================================

// FindingLocation represents a location within code (SARIF location).
type FindingLocation struct {
	Path            string           `json:"path,omitempty"`
	StartLine       int              `json:"start_line,omitempty"`
	EndLine         int              `json:"end_line,omitempty"`
	StartColumn     int              `json:"start_column,omitempty"`
	EndColumn       int              `json:"end_column,omitempty"`
	Snippet         string           `json:"snippet,omitempty"`
	ContextSnippet  string           `json:"context_snippet,omitempty"`
	Branch          string           `json:"branch,omitempty"`
	CommitSHA       string           `json:"commit_sha,omitempty"`
	Message         string           `json:"message,omitempty"` // Optional description of why this location is relevant
	LogicalLocation *LogicalLocation `json:"logical_location,omitempty"`
}

// LogicalLocation represents a logical code location (function, class, etc.).
type LogicalLocation struct {
	Name               string `json:"name,omitempty"`
	Kind               string `json:"kind,omitempty"` // function, method, class, module, etc.
	FullyQualifiedName string `json:"fully_qualified_name,omitempty"`
}

// StackTrace represents a call stack (SARIF stack).
type StackTrace struct {
	Message string       `json:"message,omitempty"`
	Frames  []StackFrame `json:"frames,omitempty"`
}

// StackFrame represents a single frame in a call stack (SARIF stackFrame).
type StackFrame struct {
	Location   *FindingLocation `json:"location,omitempty"`
	Module     string           `json:"module,omitempty"`
	ThreadID   int              `json:"thread_id,omitempty"`
	Parameters []string         `json:"parameters,omitempty"`
}

// AttachmentType represents the type of attachment.
type AttachmentType string

const (
	AttachmentTypeEvidence   AttachmentType = "evidence"   // Supporting evidence (CVE details, advisory links)
	AttachmentTypeScreenshot AttachmentType = "screenshot" // Screenshot image
	AttachmentTypeDocument   AttachmentType = "document"   // Documentation, reports
	AttachmentTypeReference  AttachmentType = "reference"  // External reference links
	AttachmentTypeCode       AttachmentType = "code"       // Code snippet or file
	AttachmentTypeOther      AttachmentType = "other"      // Other attachment types
)

// Attachment represents an artifact or evidence file (SARIF attachment with extensions).
type Attachment struct {
	Type             AttachmentType    `json:"type,omitempty"`              // Attachment type for UI categorization
	Description      string            `json:"description,omitempty"`       // Human-readable description
	ArtifactLocation *ArtifactLocation `json:"artifact_location,omitempty"` // Location of the artifact
	Regions          []FindingLocation `json:"regions,omitempty"`           // Relevant regions in the artifact
	Rectangles       []Rectangle       `json:"rectangles,omitempty"`        // Highlight areas (for images)
}

// ArtifactLocation represents the location of an artifact file.
type ArtifactLocation struct {
	URI       string `json:"uri,omitempty"`
	URIBaseID string `json:"uri_base_id,omitempty"`
}

// Rectangle represents a rectangular area in an image.
type Rectangle struct {
	Top    float64 `json:"top,omitempty"`
	Left   float64 `json:"left,omitempty"`
	Bottom float64 `json:"bottom,omitempty"`
	Right  float64 `json:"right,omitempty"`
}

// BaselineState represents the finding's status relative to a baseline (SARIF baselineState).
type BaselineState string

const (
	BaselineStateNew       BaselineState = "new"       // Not present in baseline
	BaselineStateUnchanged BaselineState = "unchanged" // Identical to baseline
	BaselineStateUpdated   BaselineState = "updated"   // Modified since baseline
	BaselineStateAbsent    BaselineState = "absent"    // Was in baseline, now gone
)

// IsValid checks if the baseline state is valid.
func (b BaselineState) IsValid() bool {
	switch b {
	case BaselineStateNew, BaselineStateUnchanged, BaselineStateUpdated, BaselineStateAbsent, "":
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (b BaselineState) String() string {
	return string(b)
}

// ParseBaselineState parses a string into a BaselineState.
func ParseBaselineState(s string) (BaselineState, error) {
	if s == "" {
		return "", nil
	}
	bs := BaselineState(strings.ToLower(strings.TrimSpace(s)))
	if !bs.IsValid() {
		return "", fmt.Errorf("invalid baseline state: %s", s)
	}
	return bs, nil
}

// FindingKind represents the evaluation state of a finding (SARIF kind).
type FindingKind string

const (
	FindingKindNotApplicable FindingKind = "not_applicable" // Rule didn't apply
	FindingKindPass          FindingKind = "pass"           // Rule passed
	FindingKindFail          FindingKind = "fail"           // Rule failed (vulnerability)
	FindingKindReview        FindingKind = "review"         // Needs manual review
	FindingKindOpen          FindingKind = "open"           // Open question/issue
	FindingKindInformational FindingKind = "informational"  // FYI only
)

// IsValid checks if the finding kind is valid.
func (k FindingKind) IsValid() bool {
	switch k {
	case FindingKindNotApplicable, FindingKindPass, FindingKindFail,
		FindingKindReview, FindingKindOpen, FindingKindInformational, "":
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (k FindingKind) String() string {
	return string(k)
}

// ParseFindingKind parses a string into a FindingKind.
func ParseFindingKind(s string) (FindingKind, error) {
	if s == "" {
		return "", nil
	}
	fk := FindingKind(strings.ToLower(strings.TrimSpace(s)))
	if !fk.IsValid() {
		return "", fmt.Errorf("invalid finding kind: %s", s)
	}
	return fk, nil
}

// ImpactLevel represents the impact level for risk assessment.
type ImpactLevel string

const (
	ImpactCritical ImpactLevel = "critical"
	ImpactHigh     ImpactLevel = "high"
	ImpactMedium   ImpactLevel = "medium"
	ImpactLow      ImpactLevel = "low"
)

// IsValid checks if the impact level is valid.
func (i ImpactLevel) IsValid() bool {
	switch i {
	case ImpactCritical, ImpactHigh, ImpactMedium, ImpactLow, "":
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (i ImpactLevel) String() string {
	return string(i)
}

// ParseImpactLevel parses a string into an ImpactLevel.
func ParseImpactLevel(s string) (ImpactLevel, error) {
	if s == "" {
		return "", nil
	}
	il := ImpactLevel(strings.ToLower(strings.TrimSpace(s)))
	if !il.IsValid() {
		return "", fmt.Errorf("invalid impact level: %s", s)
	}
	return il, nil
}

// LikelihoodLevel represents the likelihood level for risk assessment.
type LikelihoodLevel string

const (
	LikelihoodHigh   LikelihoodLevel = "high"
	LikelihoodMedium LikelihoodLevel = "medium"
	LikelihoodLow    LikelihoodLevel = "low"
)

// IsValid checks if the likelihood level is valid.
func (l LikelihoodLevel) IsValid() bool {
	switch l {
	case LikelihoodHigh, LikelihoodMedium, LikelihoodLow, "":
		return true
	default:
		return false
	}
}

// String returns the string representation.
func (l LikelihoodLevel) String() string {
	return string(l)
}

// ParseLikelihoodLevel parses a string into a LikelihoodLevel.
func ParseLikelihoodLevel(s string) (LikelihoodLevel, error) {
	if s == "" {
		return "", nil
	}
	ll := LikelihoodLevel(strings.ToLower(strings.TrimSpace(s)))
	if !ll.IsValid() {
		return "", fmt.Errorf("invalid likelihood level: %s", s)
	}
	return ll, nil
}

// =============================================================================
// Specialized Finding Details Value Objects
// =============================================================================

// SecretDetails contains details specific to secret/credential findings.
type SecretDetails struct {
	SecretType string     `json:"secret_type,omitempty"` // api_key, token, password, private_key, certificate
	Service    string     `json:"service,omitempty"`     // aws, github, stripe, slack, etc.
	Valid      *bool      `json:"valid,omitempty"`       // Is the secret currently valid
	Revoked    *bool      `json:"revoked,omitempty"`     // Has the secret been revoked
	Entropy    *float64   `json:"entropy,omitempty"`     // Shannon entropy of the secret
	ExpiresAt  *time.Time `json:"expires_at,omitempty"`  // When the secret expires
	Scopes     []string   `json:"scopes,omitempty"`      // Permissions/scopes the secret has
	MaskedVal  string     `json:"masked_val,omitempty"`  // Masked value for display (e.g., "sk_live_****XXXX")
}

// ComplianceResult represents the result of a compliance check.
type ComplianceResult string

const (
	ComplianceResultPass          ComplianceResult = "pass"
	ComplianceResultFail          ComplianceResult = "fail"
	ComplianceResultManual        ComplianceResult = "manual"
	ComplianceResultNotApplicable ComplianceResult = "not_applicable"
	ComplianceResultError         ComplianceResult = "error"
	ComplianceResultUnknown       ComplianceResult = "unknown"
)

// IsValid checks if the compliance result is valid.
func (c ComplianceResult) IsValid() bool {
	switch c {
	case ComplianceResultPass, ComplianceResultFail, ComplianceResultManual,
		ComplianceResultNotApplicable, ComplianceResultError, ComplianceResultUnknown, "":
		return true
	default:
		return false
	}
}

// ComplianceDetails contains details specific to compliance findings.
type ComplianceDetails struct {
	Framework   string           `json:"framework,omitempty"`    // CIS, SOC2, PCI-DSS, HIPAA, GDPR, ISO27001, NIST
	ControlID   string           `json:"control_id,omitempty"`   // Control ID within framework
	ControlName string           `json:"control_name,omitempty"` // Human-readable control name
	Section     string           `json:"section,omitempty"`      // Section/domain within framework
	Result      ComplianceResult `json:"result,omitempty"`       // pass, fail, manual, not_applicable
	Evidence    string           `json:"evidence,omitempty"`     // Evidence for the result
}

// MisconfigDetails contains details specific to misconfiguration findings.
type MisconfigDetails struct {
	PolicyID     string `json:"policy_id,omitempty"`     // CKV_AWS_1, AVD-AWS-0001, etc.
	ResourceType string `json:"resource_type,omitempty"` // aws_s3_bucket, google_compute_instance
	ResourceName string `json:"resource_name,omitempty"` // Resource name/identifier in IaC
	ResourcePath string `json:"resource_path,omitempty"` // Full path to resource in IaC file
	Expected     string `json:"expected,omitempty"`      // Expected configuration value
	Actual       string `json:"actual,omitempty"`        // Actual configuration value found
	Cause        string `json:"cause,omitempty"`         // Root cause description
}

// Web3Details contains details specific to Web3/blockchain findings.
type Web3Details struct {
	Chain             string `json:"chain,omitempty"`              // ethereum, polygon, bsc, arbitrum, solana
	ChainID           int64  `json:"chain_id,omitempty"`           // EVM chain ID: 1, 137, 56
	ContractAddress   string `json:"contract_address,omitempty"`   // 0x-prefixed address (42 chars for EVM)
	SWCID             string `json:"swc_id,omitempty"`             // SWC-101, SWC-107, etc.
	FunctionSignature string `json:"function_signature,omitempty"` // transfer(address,uint256)
	FunctionSelector  string `json:"function_selector,omitempty"`  // 4-byte selector: 0xa9059cbb
	TxHash            string `json:"tx_hash,omitempty"`            // Transaction hash if specific tx
	BlockNumber       int64  `json:"block_number,omitempty"`       // Block number if specific block
}

// DataFlowStep represents a single step in a data flow trace.
type DataFlowStep struct {
	Index              int              `json:"index"`                          // Step order (0 = source)
	LocationType       string           `json:"location_type"`                  // source, intermediate, sink, sanitizer
	Location           *FindingLocation `json:"location,omitempty"`             // Physical location
	Label              string           `json:"label,omitempty"`                // Variable/expression name
	Message            string           `json:"message,omitempty"`              // What happens at this step
	NestingLevel       int              `json:"nesting_level,omitempty"`        // For display indentation
	Importance         string           `json:"importance,omitempty"`           // essential, important, unimportant
	FunctionName       string           `json:"function_name,omitempty"`        // Function context
	ClassName          string           `json:"class_name,omitempty"`           // Class context
	ModuleName         string           `json:"module_name,omitempty"`          // Module context
	FullyQualifiedName string           `json:"fully_qualified_name,omitempty"` // Full path

	// Extended operation tracking (from EIS DataFlowLocation)
	Operation      string `json:"operation,omitempty"`       // assignment, call, return, parameter, concat, etc.
	CalledFunction string `json:"called_function,omitempty"` // For call operations: the function being called
	ParameterIndex int    `json:"parameter_index,omitempty"` // For parameter operations: 0-indexed parameter position
	TaintState     string `json:"taint_state,omitempty"`     // tainted, sanitized, unknown
	Transformation string `json:"transformation,omitempty"`  // encode, decode, escape, hash, encrypt, etc.
}

// DataFlow represents a complete data flow trace (taint tracking path).
type DataFlow struct {
	Index      int            `json:"index"`                // Flow index within finding
	Message    string         `json:"message,omitempty"`    // Flow description
	Importance string         `json:"importance,omitempty"` // essential, important, unimportant
	Steps      []DataFlowStep `json:"steps,omitempty"`      // Ordered steps from source to sink

	// Extended taint tracking metadata (from EIS DataFlow)
	Tainted           bool     `json:"tainted"`                      // Whether data is still tainted at sink
	TaintType         string   `json:"taint_type,omitempty"`         // user_input, file_read, env_var, network, database, etc.
	VulnerabilityType string   `json:"vulnerability_type,omitempty"` // sql_injection, xss, command_injection, etc.
	Confidence        int      `json:"confidence,omitempty"`         // 0-100 confidence score
	Interprocedural   bool     `json:"interprocedural,omitempty"`    // Whether flow crosses function boundaries
	CrossFile         bool     `json:"cross_file,omitempty"`         // Whether flow crosses file boundaries
	CallPath          []string `json:"call_path,omitempty"`          // Ordered list of function names in call chain
}

// GetSource returns the source step (first step with location_type = "source").
func (d DataFlow) GetSource() *DataFlowStep {
	for i := range d.Steps {
		if d.Steps[i].LocationType == "source" {
			return &d.Steps[i]
		}
	}
	if len(d.Steps) > 0 {
		return &d.Steps[0]
	}
	return nil
}

// GetSink returns the sink step (last step with location_type = "sink").
func (d DataFlow) GetSink() *DataFlowStep {
	for i := len(d.Steps) - 1; i >= 0; i-- {
		if d.Steps[i].LocationType == "sink" {
			return &d.Steps[i]
		}
	}
	if len(d.Steps) > 0 {
		return &d.Steps[len(d.Steps)-1]
	}
	return nil
}
